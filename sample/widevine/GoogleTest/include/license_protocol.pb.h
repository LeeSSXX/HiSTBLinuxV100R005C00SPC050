// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: license_protocol.proto

#ifndef PROTOBUF_license_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_license_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace video_widevine_server {
namespace sdk {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_license_5fprotocol_2eproto();
void protobuf_AssignDesc_license_5fprotocol_2eproto();
void protobuf_ShutdownFile_license_5fprotocol_2eproto();

class LicenseIdentification;
class License;
class License_Policy;
class License_KeyContainer;
class License_KeyContainer_KeyControl;
class License_KeyContainer_OutputProtection;
class License_KeyContainer_VideoResolutionConstraint;
class License_KeyContainer_OperatorSessionKeyPermissions;
class LicenseRequest;
class LicenseRequest_ContentIdentification;
class LicenseRequest_ContentIdentification_CENC;
class LicenseRequest_ContentIdentification_WebM;
class LicenseRequest_ContentIdentification_ExistingLicense;
class LicenseError;
class MetricData;
class MetricData_TypeValue;
class RemoteAttestation;
class SignedMessage;
class GroupKeys;
class ProvisioningOptions;
class ProvisioningRequest;
class ProvisioningResponse;
class SignedProvisioningMessage;
class ClientIdentification;
class ClientIdentification_NameValue;
class ClientIdentification_ClientCapabilities;
class EncryptedClientIdentification;
class DeviceCertificate;
class SignedDeviceCertificate;
class ProvisionedDeviceInfo;
class DeviceCertificateStatus;
class DeviceCertificateStatusList;
class SignedCertificateStatusList;
class WidevineCencHeader;

enum License_KeyContainer_OutputProtection_HDCP {
  License_KeyContainer_OutputProtection_HDCP_HDCP_NONE = 0,
  License_KeyContainer_OutputProtection_HDCP_HDCP_V1 = 1,
  License_KeyContainer_OutputProtection_HDCP_HDCP_V2 = 2,
  License_KeyContainer_OutputProtection_HDCP_HDCP_V2_1 = 3,
  License_KeyContainer_OutputProtection_HDCP_HDCP_V2_2 = 4,
  License_KeyContainer_OutputProtection_HDCP_HDCP_NO_DIGITAL_OUTPUT = 255
};
bool License_KeyContainer_OutputProtection_HDCP_IsValid(int value);
const License_KeyContainer_OutputProtection_HDCP License_KeyContainer_OutputProtection_HDCP_HDCP_MIN = License_KeyContainer_OutputProtection_HDCP_HDCP_NONE;
const License_KeyContainer_OutputProtection_HDCP License_KeyContainer_OutputProtection_HDCP_HDCP_MAX = License_KeyContainer_OutputProtection_HDCP_HDCP_NO_DIGITAL_OUTPUT;
const int License_KeyContainer_OutputProtection_HDCP_HDCP_ARRAYSIZE = License_KeyContainer_OutputProtection_HDCP_HDCP_MAX + 1;

enum License_KeyContainer_OutputProtection_CGMS {
  License_KeyContainer_OutputProtection_CGMS_CGMS_NONE = 42,
  License_KeyContainer_OutputProtection_CGMS_COPY_FREE = 0,
  License_KeyContainer_OutputProtection_CGMS_COPY_ONCE = 2,
  License_KeyContainer_OutputProtection_CGMS_COPY_NEVER = 3
};
bool License_KeyContainer_OutputProtection_CGMS_IsValid(int value);
const License_KeyContainer_OutputProtection_CGMS License_KeyContainer_OutputProtection_CGMS_CGMS_MIN = License_KeyContainer_OutputProtection_CGMS_COPY_FREE;
const License_KeyContainer_OutputProtection_CGMS License_KeyContainer_OutputProtection_CGMS_CGMS_MAX = License_KeyContainer_OutputProtection_CGMS_CGMS_NONE;
const int License_KeyContainer_OutputProtection_CGMS_CGMS_ARRAYSIZE = License_KeyContainer_OutputProtection_CGMS_CGMS_MAX + 1;

enum License_KeyContainer_KeyType {
  License_KeyContainer_KeyType_SIGNING = 1,
  License_KeyContainer_KeyType_CONTENT = 2,
  License_KeyContainer_KeyType_KEY_CONTROL = 3,
  License_KeyContainer_KeyType_OPERATOR_SESSION = 4
};
bool License_KeyContainer_KeyType_IsValid(int value);
const License_KeyContainer_KeyType License_KeyContainer_KeyType_KeyType_MIN = License_KeyContainer_KeyType_SIGNING;
const License_KeyContainer_KeyType License_KeyContainer_KeyType_KeyType_MAX = License_KeyContainer_KeyType_OPERATOR_SESSION;
const int License_KeyContainer_KeyType_KeyType_ARRAYSIZE = License_KeyContainer_KeyType_KeyType_MAX + 1;

enum License_KeyContainer_SecurityLevel {
  License_KeyContainer_SecurityLevel_SW_SECURE_CRYPTO = 1,
  License_KeyContainer_SecurityLevel_SW_SECURE_DECODE = 2,
  License_KeyContainer_SecurityLevel_HW_SECURE_CRYPTO = 3,
  License_KeyContainer_SecurityLevel_HW_SECURE_DECODE = 4,
  License_KeyContainer_SecurityLevel_HW_SECURE_ALL = 5
};
bool License_KeyContainer_SecurityLevel_IsValid(int value);
const License_KeyContainer_SecurityLevel License_KeyContainer_SecurityLevel_SecurityLevel_MIN = License_KeyContainer_SecurityLevel_SW_SECURE_CRYPTO;
const License_KeyContainer_SecurityLevel License_KeyContainer_SecurityLevel_SecurityLevel_MAX = License_KeyContainer_SecurityLevel_HW_SECURE_ALL;
const int License_KeyContainer_SecurityLevel_SecurityLevel_ARRAYSIZE = License_KeyContainer_SecurityLevel_SecurityLevel_MAX + 1;

enum LicenseRequest_RequestType {
  LicenseRequest_RequestType_NEW = 1,
  LicenseRequest_RequestType_RENEWAL = 2,
  LicenseRequest_RequestType_RELEASE = 3
};
bool LicenseRequest_RequestType_IsValid(int value);
const LicenseRequest_RequestType LicenseRequest_RequestType_RequestType_MIN = LicenseRequest_RequestType_NEW;
const LicenseRequest_RequestType LicenseRequest_RequestType_RequestType_MAX = LicenseRequest_RequestType_RELEASE;
const int LicenseRequest_RequestType_RequestType_ARRAYSIZE = LicenseRequest_RequestType_RequestType_MAX + 1;

enum LicenseError_Error {
  LicenseError_Error_INVALID_DEVICE_CERTIFICATE = 1,
  LicenseError_Error_REVOKED_DEVICE_CERTIFICATE = 2,
  LicenseError_Error_SERVICE_UNAVAILABLE = 3
};
bool LicenseError_Error_IsValid(int value);
const LicenseError_Error LicenseError_Error_Error_MIN = LicenseError_Error_INVALID_DEVICE_CERTIFICATE;
const LicenseError_Error LicenseError_Error_Error_MAX = LicenseError_Error_SERVICE_UNAVAILABLE;
const int LicenseError_Error_Error_ARRAYSIZE = LicenseError_Error_Error_MAX + 1;

enum MetricData_MetricType {
  MetricData_MetricType_LATENCY = 1,
  MetricData_MetricType_TIMESTAMP = 2
};
bool MetricData_MetricType_IsValid(int value);
const MetricData_MetricType MetricData_MetricType_MetricType_MIN = MetricData_MetricType_LATENCY;
const MetricData_MetricType MetricData_MetricType_MetricType_MAX = MetricData_MetricType_TIMESTAMP;
const int MetricData_MetricType_MetricType_ARRAYSIZE = MetricData_MetricType_MetricType_MAX + 1;

enum SignedMessage_MessageType {
  SignedMessage_MessageType_LICENSE_REQUEST = 1,
  SignedMessage_MessageType_LICENSE = 2,
  SignedMessage_MessageType_ERROR_RESPONSE = 3,
  SignedMessage_MessageType_SERVICE_CERTIFICATE_REQUEST = 4,
  SignedMessage_MessageType_SERVICE_CERTIFICATE = 5
};
bool SignedMessage_MessageType_IsValid(int value);
const SignedMessage_MessageType SignedMessage_MessageType_MessageType_MIN = SignedMessage_MessageType_LICENSE_REQUEST;
const SignedMessage_MessageType SignedMessage_MessageType_MessageType_MAX = SignedMessage_MessageType_SERVICE_CERTIFICATE;
const int SignedMessage_MessageType_MessageType_ARRAYSIZE = SignedMessage_MessageType_MessageType_MAX + 1;

enum ProvisioningOptions_CertificateType {
  ProvisioningOptions_CertificateType_WIDEVINE_DRM = 0,
  ProvisioningOptions_CertificateType_X509 = 1
};
bool ProvisioningOptions_CertificateType_IsValid(int value);
const ProvisioningOptions_CertificateType ProvisioningOptions_CertificateType_CertificateType_MIN = ProvisioningOptions_CertificateType_WIDEVINE_DRM;
const ProvisioningOptions_CertificateType ProvisioningOptions_CertificateType_CertificateType_MAX = ProvisioningOptions_CertificateType_X509;
const int ProvisioningOptions_CertificateType_CertificateType_ARRAYSIZE = ProvisioningOptions_CertificateType_CertificateType_MAX + 1;

enum ClientIdentification_ClientCapabilities_HdcpVersion {
  ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_NONE = 0,
  ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_V1 = 1,
  ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_V2 = 2,
  ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_V2_1 = 3,
  ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_V2_2 = 4,
  ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_NO_DIGITAL_OUTPUT = 255
};
bool ClientIdentification_ClientCapabilities_HdcpVersion_IsValid(int value);
const ClientIdentification_ClientCapabilities_HdcpVersion ClientIdentification_ClientCapabilities_HdcpVersion_HdcpVersion_MIN = ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_NONE;
const ClientIdentification_ClientCapabilities_HdcpVersion ClientIdentification_ClientCapabilities_HdcpVersion_HdcpVersion_MAX = ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_NO_DIGITAL_OUTPUT;
const int ClientIdentification_ClientCapabilities_HdcpVersion_HdcpVersion_ARRAYSIZE = ClientIdentification_ClientCapabilities_HdcpVersion_HdcpVersion_MAX + 1;

enum ClientIdentification_TokenType {
  ClientIdentification_TokenType_KEYBOX = 0,
  ClientIdentification_TokenType_DEVICE_CERTIFICATE = 1,
  ClientIdentification_TokenType_REMOTE_ATTESTATION_CERTIFICATE = 2
};
bool ClientIdentification_TokenType_IsValid(int value);
const ClientIdentification_TokenType ClientIdentification_TokenType_TokenType_MIN = ClientIdentification_TokenType_KEYBOX;
const ClientIdentification_TokenType ClientIdentification_TokenType_TokenType_MAX = ClientIdentification_TokenType_REMOTE_ATTESTATION_CERTIFICATE;
const int ClientIdentification_TokenType_TokenType_ARRAYSIZE = ClientIdentification_TokenType_TokenType_MAX + 1;

enum DeviceCertificate_CertificateType {
  DeviceCertificate_CertificateType_ROOT = 0,
  DeviceCertificate_CertificateType_INTERMEDIATE = 1,
  DeviceCertificate_CertificateType_USER_DEVICE = 2,
  DeviceCertificate_CertificateType_SERVICE = 3
};
bool DeviceCertificate_CertificateType_IsValid(int value);
const DeviceCertificate_CertificateType DeviceCertificate_CertificateType_CertificateType_MIN = DeviceCertificate_CertificateType_ROOT;
const DeviceCertificate_CertificateType DeviceCertificate_CertificateType_CertificateType_MAX = DeviceCertificate_CertificateType_SERVICE;
const int DeviceCertificate_CertificateType_CertificateType_ARRAYSIZE = DeviceCertificate_CertificateType_CertificateType_MAX + 1;

enum ProvisionedDeviceInfo_WvSecurityLevel {
  ProvisionedDeviceInfo_WvSecurityLevel_LEVEL_UNSPECIFIED = 0,
  ProvisionedDeviceInfo_WvSecurityLevel_LEVEL_1 = 1,
  ProvisionedDeviceInfo_WvSecurityLevel_LEVEL_2 = 2,
  ProvisionedDeviceInfo_WvSecurityLevel_LEVEL_3 = 3
};
bool ProvisionedDeviceInfo_WvSecurityLevel_IsValid(int value);
const ProvisionedDeviceInfo_WvSecurityLevel ProvisionedDeviceInfo_WvSecurityLevel_WvSecurityLevel_MIN = ProvisionedDeviceInfo_WvSecurityLevel_LEVEL_UNSPECIFIED;
const ProvisionedDeviceInfo_WvSecurityLevel ProvisionedDeviceInfo_WvSecurityLevel_WvSecurityLevel_MAX = ProvisionedDeviceInfo_WvSecurityLevel_LEVEL_3;
const int ProvisionedDeviceInfo_WvSecurityLevel_WvSecurityLevel_ARRAYSIZE = ProvisionedDeviceInfo_WvSecurityLevel_WvSecurityLevel_MAX + 1;

enum DeviceCertificateStatus_CertificateStatus {
  DeviceCertificateStatus_CertificateStatus_VALID = 0,
  DeviceCertificateStatus_CertificateStatus_REVOKED = 1
};
bool DeviceCertificateStatus_CertificateStatus_IsValid(int value);
const DeviceCertificateStatus_CertificateStatus DeviceCertificateStatus_CertificateStatus_CertificateStatus_MIN = DeviceCertificateStatus_CertificateStatus_VALID;
const DeviceCertificateStatus_CertificateStatus DeviceCertificateStatus_CertificateStatus_CertificateStatus_MAX = DeviceCertificateStatus_CertificateStatus_REVOKED;
const int DeviceCertificateStatus_CertificateStatus_CertificateStatus_ARRAYSIZE = DeviceCertificateStatus_CertificateStatus_CertificateStatus_MAX + 1;

enum WidevineCencHeader_Algorithm {
  WidevineCencHeader_Algorithm_UNENCRYPTED = 0,
  WidevineCencHeader_Algorithm_AESCTR = 1
};
bool WidevineCencHeader_Algorithm_IsValid(int value);
const WidevineCencHeader_Algorithm WidevineCencHeader_Algorithm_Algorithm_MIN = WidevineCencHeader_Algorithm_UNENCRYPTED;
const WidevineCencHeader_Algorithm WidevineCencHeader_Algorithm_Algorithm_MAX = WidevineCencHeader_Algorithm_AESCTR;
const int WidevineCencHeader_Algorithm_Algorithm_ARRAYSIZE = WidevineCencHeader_Algorithm_Algorithm_MAX + 1;

enum LicenseType {
  STREAMING = 1,
  OFFLINE = 2
};
bool LicenseType_IsValid(int value);
const LicenseType LicenseType_MIN = STREAMING;
const LicenseType LicenseType_MAX = OFFLINE;
const int LicenseType_ARRAYSIZE = LicenseType_MAX + 1;

enum ProtocolVersion {
  VERSION_2_0 = 20,
  VERSION_2_1 = 21
};
bool ProtocolVersion_IsValid(int value);
const ProtocolVersion ProtocolVersion_MIN = VERSION_2_0;
const ProtocolVersion ProtocolVersion_MAX = VERSION_2_1;
const int ProtocolVersion_ARRAYSIZE = ProtocolVersion_MAX + 1;

// ===================================================================

class LicenseIdentification : public ::google::protobuf::MessageLite {
 public:
  LicenseIdentification();
  virtual ~LicenseIdentification();

  LicenseIdentification(const LicenseIdentification& from);

  inline LicenseIdentification& operator=(const LicenseIdentification& from) {
    CopyFrom(from);
    return *this;
  }

  static const LicenseIdentification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LicenseIdentification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LicenseIdentification* other);

  // implements Message ----------------------------------------------

  LicenseIdentification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LicenseIdentification& from);
  void MergeFrom(const LicenseIdentification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const void* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  inline void set_allocated_request_id(::std::string* request_id);

  // optional bytes session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const void* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // optional bytes purchase_id = 3;
  inline bool has_purchase_id() const;
  inline void clear_purchase_id();
  static const int kPurchaseIdFieldNumber = 3;
  inline const ::std::string& purchase_id() const;
  inline void set_purchase_id(const ::std::string& value);
  inline void set_purchase_id(const char* value);
  inline void set_purchase_id(const void* value, size_t size);
  inline ::std::string* mutable_purchase_id();
  inline ::std::string* release_purchase_id();
  inline void set_allocated_purchase_id(::std::string* purchase_id);

  // optional .video_widevine_server.sdk.LicenseType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::video_widevine_server::sdk::LicenseType type() const;
  inline void set_type(::video_widevine_server::sdk::LicenseType value);

  // optional int32 version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional bytes provider_session_token = 6;
  inline bool has_provider_session_token() const;
  inline void clear_provider_session_token();
  static const int kProviderSessionTokenFieldNumber = 6;
  inline const ::std::string& provider_session_token() const;
  inline void set_provider_session_token(const ::std::string& value);
  inline void set_provider_session_token(const char* value);
  inline void set_provider_session_token(const void* value, size_t size);
  inline ::std::string* mutable_provider_session_token();
  inline ::std::string* release_provider_session_token();
  inline void set_allocated_provider_session_token(::std::string* provider_session_token);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.LicenseIdentification)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_purchase_id();
  inline void clear_has_purchase_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_provider_session_token();
  inline void clear_has_provider_session_token();

  ::std::string* request_id_;
  ::std::string* session_id_;
  ::std::string* purchase_id_;
  int type_;
  ::google::protobuf::int32 version_;
  ::std::string* provider_session_token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static LicenseIdentification* default_instance_;
};
// -------------------------------------------------------------------

class License_Policy : public ::google::protobuf::MessageLite {
 public:
  License_Policy();
  virtual ~License_Policy();

  License_Policy(const License_Policy& from);

  inline License_Policy& operator=(const License_Policy& from) {
    CopyFrom(from);
    return *this;
  }

  static const License_Policy& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const License_Policy* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(License_Policy* other);

  // implements Message ----------------------------------------------

  License_Policy* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const License_Policy& from);
  void MergeFrom(const License_Policy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool can_play = 1 [default = false];
  inline bool has_can_play() const;
  inline void clear_can_play();
  static const int kCanPlayFieldNumber = 1;
  inline bool can_play() const;
  inline void set_can_play(bool value);

  // optional bool can_persist = 2 [default = false];
  inline bool has_can_persist() const;
  inline void clear_can_persist();
  static const int kCanPersistFieldNumber = 2;
  inline bool can_persist() const;
  inline void set_can_persist(bool value);

  // optional bool can_renew = 3 [default = false];
  inline bool has_can_renew() const;
  inline void clear_can_renew();
  static const int kCanRenewFieldNumber = 3;
  inline bool can_renew() const;
  inline void set_can_renew(bool value);

  // optional int64 rental_duration_seconds = 4 [default = 0];
  inline bool has_rental_duration_seconds() const;
  inline void clear_rental_duration_seconds();
  static const int kRentalDurationSecondsFieldNumber = 4;
  inline ::google::protobuf::int64 rental_duration_seconds() const;
  inline void set_rental_duration_seconds(::google::protobuf::int64 value);

  // optional int64 playback_duration_seconds = 5 [default = 0];
  inline bool has_playback_duration_seconds() const;
  inline void clear_playback_duration_seconds();
  static const int kPlaybackDurationSecondsFieldNumber = 5;
  inline ::google::protobuf::int64 playback_duration_seconds() const;
  inline void set_playback_duration_seconds(::google::protobuf::int64 value);

  // optional int64 license_duration_seconds = 6 [default = 0];
  inline bool has_license_duration_seconds() const;
  inline void clear_license_duration_seconds();
  static const int kLicenseDurationSecondsFieldNumber = 6;
  inline ::google::protobuf::int64 license_duration_seconds() const;
  inline void set_license_duration_seconds(::google::protobuf::int64 value);

  // optional int64 renewal_recovery_duration_seconds = 7 [default = 0];
  inline bool has_renewal_recovery_duration_seconds() const;
  inline void clear_renewal_recovery_duration_seconds();
  static const int kRenewalRecoveryDurationSecondsFieldNumber = 7;
  inline ::google::protobuf::int64 renewal_recovery_duration_seconds() const;
  inline void set_renewal_recovery_duration_seconds(::google::protobuf::int64 value);

  // optional string renewal_server_url = 8;
  inline bool has_renewal_server_url() const;
  inline void clear_renewal_server_url();
  static const int kRenewalServerUrlFieldNumber = 8;
  inline const ::std::string& renewal_server_url() const;
  inline void set_renewal_server_url(const ::std::string& value);
  inline void set_renewal_server_url(const char* value);
  inline void set_renewal_server_url(const char* value, size_t size);
  inline ::std::string* mutable_renewal_server_url();
  inline ::std::string* release_renewal_server_url();
  inline void set_allocated_renewal_server_url(::std::string* renewal_server_url);

  // optional int64 renewal_delay_seconds = 9 [default = 0];
  inline bool has_renewal_delay_seconds() const;
  inline void clear_renewal_delay_seconds();
  static const int kRenewalDelaySecondsFieldNumber = 9;
  inline ::google::protobuf::int64 renewal_delay_seconds() const;
  inline void set_renewal_delay_seconds(::google::protobuf::int64 value);

  // optional int64 renewal_retry_interval_seconds = 10 [default = 0];
  inline bool has_renewal_retry_interval_seconds() const;
  inline void clear_renewal_retry_interval_seconds();
  static const int kRenewalRetryIntervalSecondsFieldNumber = 10;
  inline ::google::protobuf::int64 renewal_retry_interval_seconds() const;
  inline void set_renewal_retry_interval_seconds(::google::protobuf::int64 value);

  // optional bool renew_with_usage = 11 [default = false];
  inline bool has_renew_with_usage() const;
  inline void clear_renew_with_usage();
  static const int kRenewWithUsageFieldNumber = 11;
  inline bool renew_with_usage() const;
  inline void set_renew_with_usage(bool value);

  // optional bool renew_with_client_id = 12 [default = false];
  inline bool has_renew_with_client_id() const;
  inline void clear_renew_with_client_id();
  static const int kRenewWithClientIdFieldNumber = 12;
  inline bool renew_with_client_id() const;
  inline void set_renew_with_client_id(bool value);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.License.Policy)
 private:
  inline void set_has_can_play();
  inline void clear_has_can_play();
  inline void set_has_can_persist();
  inline void clear_has_can_persist();
  inline void set_has_can_renew();
  inline void clear_has_can_renew();
  inline void set_has_rental_duration_seconds();
  inline void clear_has_rental_duration_seconds();
  inline void set_has_playback_duration_seconds();
  inline void clear_has_playback_duration_seconds();
  inline void set_has_license_duration_seconds();
  inline void clear_has_license_duration_seconds();
  inline void set_has_renewal_recovery_duration_seconds();
  inline void clear_has_renewal_recovery_duration_seconds();
  inline void set_has_renewal_server_url();
  inline void clear_has_renewal_server_url();
  inline void set_has_renewal_delay_seconds();
  inline void clear_has_renewal_delay_seconds();
  inline void set_has_renewal_retry_interval_seconds();
  inline void clear_has_renewal_retry_interval_seconds();
  inline void set_has_renew_with_usage();
  inline void clear_has_renew_with_usage();
  inline void set_has_renew_with_client_id();
  inline void clear_has_renew_with_client_id();

  ::google::protobuf::int64 rental_duration_seconds_;
  ::google::protobuf::int64 playback_duration_seconds_;
  bool can_play_;
  bool can_persist_;
  bool can_renew_;
  bool renew_with_usage_;
  bool renew_with_client_id_;
  ::google::protobuf::int64 license_duration_seconds_;
  ::google::protobuf::int64 renewal_recovery_duration_seconds_;
  ::std::string* renewal_server_url_;
  ::google::protobuf::int64 renewal_delay_seconds_;
  ::google::protobuf::int64 renewal_retry_interval_seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static License_Policy* default_instance_;
};
// -------------------------------------------------------------------

class License_KeyContainer_KeyControl : public ::google::protobuf::MessageLite {
 public:
  License_KeyContainer_KeyControl();
  virtual ~License_KeyContainer_KeyControl();

  License_KeyContainer_KeyControl(const License_KeyContainer_KeyControl& from);

  inline License_KeyContainer_KeyControl& operator=(const License_KeyContainer_KeyControl& from) {
    CopyFrom(from);
    return *this;
  }

  static const License_KeyContainer_KeyControl& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const License_KeyContainer_KeyControl* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(License_KeyContainer_KeyControl* other);

  // implements Message ----------------------------------------------

  License_KeyContainer_KeyControl* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const License_KeyContainer_KeyControl& from);
  void MergeFrom(const License_KeyContainer_KeyControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key_control_block = 1;
  inline bool has_key_control_block() const;
  inline void clear_key_control_block();
  static const int kKeyControlBlockFieldNumber = 1;
  inline const ::std::string& key_control_block() const;
  inline void set_key_control_block(const ::std::string& value);
  inline void set_key_control_block(const char* value);
  inline void set_key_control_block(const void* value, size_t size);
  inline ::std::string* mutable_key_control_block();
  inline ::std::string* release_key_control_block();
  inline void set_allocated_key_control_block(::std::string* key_control_block);

  // optional bytes iv = 2;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 2;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const void* value, size_t size);
  inline ::std::string* mutable_iv();
  inline ::std::string* release_iv();
  inline void set_allocated_iv(::std::string* iv);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.License.KeyContainer.KeyControl)
 private:
  inline void set_has_key_control_block();
  inline void clear_has_key_control_block();
  inline void set_has_iv();
  inline void clear_has_iv();

  ::std::string* key_control_block_;
  ::std::string* iv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static License_KeyContainer_KeyControl* default_instance_;
};
// -------------------------------------------------------------------

class License_KeyContainer_OutputProtection : public ::google::protobuf::MessageLite {
 public:
  License_KeyContainer_OutputProtection();
  virtual ~License_KeyContainer_OutputProtection();

  License_KeyContainer_OutputProtection(const License_KeyContainer_OutputProtection& from);

  inline License_KeyContainer_OutputProtection& operator=(const License_KeyContainer_OutputProtection& from) {
    CopyFrom(from);
    return *this;
  }

  static const License_KeyContainer_OutputProtection& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const License_KeyContainer_OutputProtection* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(License_KeyContainer_OutputProtection* other);

  // implements Message ----------------------------------------------

  License_KeyContainer_OutputProtection* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const License_KeyContainer_OutputProtection& from);
  void MergeFrom(const License_KeyContainer_OutputProtection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef License_KeyContainer_OutputProtection_HDCP HDCP;
  static const HDCP HDCP_NONE = License_KeyContainer_OutputProtection_HDCP_HDCP_NONE;
  static const HDCP HDCP_V1 = License_KeyContainer_OutputProtection_HDCP_HDCP_V1;
  static const HDCP HDCP_V2 = License_KeyContainer_OutputProtection_HDCP_HDCP_V2;
  static const HDCP HDCP_V2_1 = License_KeyContainer_OutputProtection_HDCP_HDCP_V2_1;
  static const HDCP HDCP_V2_2 = License_KeyContainer_OutputProtection_HDCP_HDCP_V2_2;
  static const HDCP HDCP_NO_DIGITAL_OUTPUT = License_KeyContainer_OutputProtection_HDCP_HDCP_NO_DIGITAL_OUTPUT;
  static inline bool HDCP_IsValid(int value) {
    return License_KeyContainer_OutputProtection_HDCP_IsValid(value);
  }
  static const HDCP HDCP_MIN =
    License_KeyContainer_OutputProtection_HDCP_HDCP_MIN;
  static const HDCP HDCP_MAX =
    License_KeyContainer_OutputProtection_HDCP_HDCP_MAX;
  static const int HDCP_ARRAYSIZE =
    License_KeyContainer_OutputProtection_HDCP_HDCP_ARRAYSIZE;

  typedef License_KeyContainer_OutputProtection_CGMS CGMS;
  static const CGMS CGMS_NONE = License_KeyContainer_OutputProtection_CGMS_CGMS_NONE;
  static const CGMS COPY_FREE = License_KeyContainer_OutputProtection_CGMS_COPY_FREE;
  static const CGMS COPY_ONCE = License_KeyContainer_OutputProtection_CGMS_COPY_ONCE;
  static const CGMS COPY_NEVER = License_KeyContainer_OutputProtection_CGMS_COPY_NEVER;
  static inline bool CGMS_IsValid(int value) {
    return License_KeyContainer_OutputProtection_CGMS_IsValid(value);
  }
  static const CGMS CGMS_MIN =
    License_KeyContainer_OutputProtection_CGMS_CGMS_MIN;
  static const CGMS CGMS_MAX =
    License_KeyContainer_OutputProtection_CGMS_CGMS_MAX;
  static const int CGMS_ARRAYSIZE =
    License_KeyContainer_OutputProtection_CGMS_CGMS_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];
  inline bool has_hdcp() const;
  inline void clear_hdcp();
  static const int kHdcpFieldNumber = 1;
  inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection_HDCP hdcp() const;
  inline void set_hdcp(::video_widevine_server::sdk::License_KeyContainer_OutputProtection_HDCP value);

  // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];
  inline bool has_cgms_flags() const;
  inline void clear_cgms_flags();
  static const int kCgmsFlagsFieldNumber = 2;
  inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection_CGMS cgms_flags() const;
  inline void set_cgms_flags(::video_widevine_server::sdk::License_KeyContainer_OutputProtection_CGMS value);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.License.KeyContainer.OutputProtection)
 private:
  inline void set_has_hdcp();
  inline void clear_has_hdcp();
  inline void set_has_cgms_flags();
  inline void clear_has_cgms_flags();

  int hdcp_;
  int cgms_flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static License_KeyContainer_OutputProtection* default_instance_;
};
// -------------------------------------------------------------------

class License_KeyContainer_VideoResolutionConstraint : public ::google::protobuf::MessageLite {
 public:
  License_KeyContainer_VideoResolutionConstraint();
  virtual ~License_KeyContainer_VideoResolutionConstraint();

  License_KeyContainer_VideoResolutionConstraint(const License_KeyContainer_VideoResolutionConstraint& from);

  inline License_KeyContainer_VideoResolutionConstraint& operator=(const License_KeyContainer_VideoResolutionConstraint& from) {
    CopyFrom(from);
    return *this;
  }

  static const License_KeyContainer_VideoResolutionConstraint& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const License_KeyContainer_VideoResolutionConstraint* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(License_KeyContainer_VideoResolutionConstraint* other);

  // implements Message ----------------------------------------------

  License_KeyContainer_VideoResolutionConstraint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const License_KeyContainer_VideoResolutionConstraint& from);
  void MergeFrom(const License_KeyContainer_VideoResolutionConstraint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 min_resolution_pixels = 1;
  inline bool has_min_resolution_pixels() const;
  inline void clear_min_resolution_pixels();
  static const int kMinResolutionPixelsFieldNumber = 1;
  inline ::google::protobuf::uint32 min_resolution_pixels() const;
  inline void set_min_resolution_pixels(::google::protobuf::uint32 value);

  // optional uint32 max_resolution_pixels = 2;
  inline bool has_max_resolution_pixels() const;
  inline void clear_max_resolution_pixels();
  static const int kMaxResolutionPixelsFieldNumber = 2;
  inline ::google::protobuf::uint32 max_resolution_pixels() const;
  inline void set_max_resolution_pixels(::google::protobuf::uint32 value);

  // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection required_protection = 3;
  inline bool has_required_protection() const;
  inline void clear_required_protection();
  static const int kRequiredProtectionFieldNumber = 3;
  inline const ::video_widevine_server::sdk::License_KeyContainer_OutputProtection& required_protection() const;
  inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* mutable_required_protection();
  inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* release_required_protection();
  inline void set_allocated_required_protection(::video_widevine_server::sdk::License_KeyContainer_OutputProtection* required_protection);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.License.KeyContainer.VideoResolutionConstraint)
 private:
  inline void set_has_min_resolution_pixels();
  inline void clear_has_min_resolution_pixels();
  inline void set_has_max_resolution_pixels();
  inline void clear_has_max_resolution_pixels();
  inline void set_has_required_protection();
  inline void clear_has_required_protection();

  ::google::protobuf::uint32 min_resolution_pixels_;
  ::google::protobuf::uint32 max_resolution_pixels_;
  ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* required_protection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static License_KeyContainer_VideoResolutionConstraint* default_instance_;
};
// -------------------------------------------------------------------

class License_KeyContainer_OperatorSessionKeyPermissions : public ::google::protobuf::MessageLite {
 public:
  License_KeyContainer_OperatorSessionKeyPermissions();
  virtual ~License_KeyContainer_OperatorSessionKeyPermissions();

  License_KeyContainer_OperatorSessionKeyPermissions(const License_KeyContainer_OperatorSessionKeyPermissions& from);

  inline License_KeyContainer_OperatorSessionKeyPermissions& operator=(const License_KeyContainer_OperatorSessionKeyPermissions& from) {
    CopyFrom(from);
    return *this;
  }

  static const License_KeyContainer_OperatorSessionKeyPermissions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const License_KeyContainer_OperatorSessionKeyPermissions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(License_KeyContainer_OperatorSessionKeyPermissions* other);

  // implements Message ----------------------------------------------

  License_KeyContainer_OperatorSessionKeyPermissions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const License_KeyContainer_OperatorSessionKeyPermissions& from);
  void MergeFrom(const License_KeyContainer_OperatorSessionKeyPermissions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool allow_encrypt = 1 [default = false];
  inline bool has_allow_encrypt() const;
  inline void clear_allow_encrypt();
  static const int kAllowEncryptFieldNumber = 1;
  inline bool allow_encrypt() const;
  inline void set_allow_encrypt(bool value);

  // optional bool allow_decrypt = 2 [default = false];
  inline bool has_allow_decrypt() const;
  inline void clear_allow_decrypt();
  static const int kAllowDecryptFieldNumber = 2;
  inline bool allow_decrypt() const;
  inline void set_allow_decrypt(bool value);

  // optional bool allow_sign = 3 [default = false];
  inline bool has_allow_sign() const;
  inline void clear_allow_sign();
  static const int kAllowSignFieldNumber = 3;
  inline bool allow_sign() const;
  inline void set_allow_sign(bool value);

  // optional bool allow_signature_verify = 4 [default = false];
  inline bool has_allow_signature_verify() const;
  inline void clear_allow_signature_verify();
  static const int kAllowSignatureVerifyFieldNumber = 4;
  inline bool allow_signature_verify() const;
  inline void set_allow_signature_verify(bool value);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.License.KeyContainer.OperatorSessionKeyPermissions)
 private:
  inline void set_has_allow_encrypt();
  inline void clear_has_allow_encrypt();
  inline void set_has_allow_decrypt();
  inline void clear_has_allow_decrypt();
  inline void set_has_allow_sign();
  inline void clear_has_allow_sign();
  inline void set_has_allow_signature_verify();
  inline void clear_has_allow_signature_verify();

  bool allow_encrypt_;
  bool allow_decrypt_;
  bool allow_sign_;
  bool allow_signature_verify_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static License_KeyContainer_OperatorSessionKeyPermissions* default_instance_;
};
// -------------------------------------------------------------------

class License_KeyContainer : public ::google::protobuf::MessageLite {
 public:
  License_KeyContainer();
  virtual ~License_KeyContainer();

  License_KeyContainer(const License_KeyContainer& from);

  inline License_KeyContainer& operator=(const License_KeyContainer& from) {
    CopyFrom(from);
    return *this;
  }

  static const License_KeyContainer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const License_KeyContainer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(License_KeyContainer* other);

  // implements Message ----------------------------------------------

  License_KeyContainer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const License_KeyContainer& from);
  void MergeFrom(const License_KeyContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef License_KeyContainer_KeyControl KeyControl;
  typedef License_KeyContainer_OutputProtection OutputProtection;
  typedef License_KeyContainer_VideoResolutionConstraint VideoResolutionConstraint;
  typedef License_KeyContainer_OperatorSessionKeyPermissions OperatorSessionKeyPermissions;

  typedef License_KeyContainer_KeyType KeyType;
  static const KeyType SIGNING = License_KeyContainer_KeyType_SIGNING;
  static const KeyType CONTENT = License_KeyContainer_KeyType_CONTENT;
  static const KeyType KEY_CONTROL = License_KeyContainer_KeyType_KEY_CONTROL;
  static const KeyType OPERATOR_SESSION = License_KeyContainer_KeyType_OPERATOR_SESSION;
  static inline bool KeyType_IsValid(int value) {
    return License_KeyContainer_KeyType_IsValid(value);
  }
  static const KeyType KeyType_MIN =
    License_KeyContainer_KeyType_KeyType_MIN;
  static const KeyType KeyType_MAX =
    License_KeyContainer_KeyType_KeyType_MAX;
  static const int KeyType_ARRAYSIZE =
    License_KeyContainer_KeyType_KeyType_ARRAYSIZE;

  typedef License_KeyContainer_SecurityLevel SecurityLevel;
  static const SecurityLevel SW_SECURE_CRYPTO = License_KeyContainer_SecurityLevel_SW_SECURE_CRYPTO;
  static const SecurityLevel SW_SECURE_DECODE = License_KeyContainer_SecurityLevel_SW_SECURE_DECODE;
  static const SecurityLevel HW_SECURE_CRYPTO = License_KeyContainer_SecurityLevel_HW_SECURE_CRYPTO;
  static const SecurityLevel HW_SECURE_DECODE = License_KeyContainer_SecurityLevel_HW_SECURE_DECODE;
  static const SecurityLevel HW_SECURE_ALL = License_KeyContainer_SecurityLevel_HW_SECURE_ALL;
  static inline bool SecurityLevel_IsValid(int value) {
    return License_KeyContainer_SecurityLevel_IsValid(value);
  }
  static const SecurityLevel SecurityLevel_MIN =
    License_KeyContainer_SecurityLevel_SecurityLevel_MIN;
  static const SecurityLevel SecurityLevel_MAX =
    License_KeyContainer_SecurityLevel_SecurityLevel_MAX;
  static const int SecurityLevel_ARRAYSIZE =
    License_KeyContainer_SecurityLevel_SecurityLevel_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional bytes iv = 2;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 2;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const void* value, size_t size);
  inline ::std::string* mutable_iv();
  inline ::std::string* release_iv();
  inline void set_allocated_iv(::std::string* iv);

  // optional bytes key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .video_widevine_server.sdk.License.KeyContainer.KeyType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::video_widevine_server::sdk::License_KeyContainer_KeyType type() const;
  inline void set_type(::video_widevine_server::sdk::License_KeyContainer_KeyType value);

  // optional .video_widevine_server.sdk.License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::video_widevine_server::sdk::License_KeyContainer_SecurityLevel level() const;
  inline void set_level(::video_widevine_server::sdk::License_KeyContainer_SecurityLevel value);

  // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection required_protection = 6;
  inline bool has_required_protection() const;
  inline void clear_required_protection();
  static const int kRequiredProtectionFieldNumber = 6;
  inline const ::video_widevine_server::sdk::License_KeyContainer_OutputProtection& required_protection() const;
  inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* mutable_required_protection();
  inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* release_required_protection();
  inline void set_allocated_required_protection(::video_widevine_server::sdk::License_KeyContainer_OutputProtection* required_protection);

  // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection requested_protection = 7;
  inline bool has_requested_protection() const;
  inline void clear_requested_protection();
  static const int kRequestedProtectionFieldNumber = 7;
  inline const ::video_widevine_server::sdk::License_KeyContainer_OutputProtection& requested_protection() const;
  inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* mutable_requested_protection();
  inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* release_requested_protection();
  inline void set_allocated_requested_protection(::video_widevine_server::sdk::License_KeyContainer_OutputProtection* requested_protection);

  // optional .video_widevine_server.sdk.License.KeyContainer.KeyControl key_control = 8;
  inline bool has_key_control() const;
  inline void clear_key_control();
  static const int kKeyControlFieldNumber = 8;
  inline const ::video_widevine_server::sdk::License_KeyContainer_KeyControl& key_control() const;
  inline ::video_widevine_server::sdk::License_KeyContainer_KeyControl* mutable_key_control();
  inline ::video_widevine_server::sdk::License_KeyContainer_KeyControl* release_key_control();
  inline void set_allocated_key_control(::video_widevine_server::sdk::License_KeyContainer_KeyControl* key_control);

  // optional .video_widevine_server.sdk.License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;
  inline bool has_operator_session_key_permissions() const;
  inline void clear_operator_session_key_permissions();
  static const int kOperatorSessionKeyPermissionsFieldNumber = 9;
  inline const ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions& operator_session_key_permissions() const;
  inline ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions* mutable_operator_session_key_permissions();
  inline ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions* release_operator_session_key_permissions();
  inline void set_allocated_operator_session_key_permissions(::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions* operator_session_key_permissions);

  // repeated .video_widevine_server.sdk.License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;
  inline int video_resolution_constraints_size() const;
  inline void clear_video_resolution_constraints();
  static const int kVideoResolutionConstraintsFieldNumber = 10;
  inline const ::video_widevine_server::sdk::License_KeyContainer_VideoResolutionConstraint& video_resolution_constraints(int index) const;
  inline ::video_widevine_server::sdk::License_KeyContainer_VideoResolutionConstraint* mutable_video_resolution_constraints(int index);
  inline ::video_widevine_server::sdk::License_KeyContainer_VideoResolutionConstraint* add_video_resolution_constraints();
  inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer_VideoResolutionConstraint >&
      video_resolution_constraints() const;
  inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer_VideoResolutionConstraint >*
      mutable_video_resolution_constraints();

  // optional bool anti_rollback_usage_table = 11 [default = false];
  inline bool has_anti_rollback_usage_table() const;
  inline void clear_anti_rollback_usage_table();
  static const int kAntiRollbackUsageTableFieldNumber = 11;
  inline bool anti_rollback_usage_table() const;
  inline void set_anti_rollback_usage_table(bool value);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.License.KeyContainer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_iv();
  inline void clear_has_iv();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_required_protection();
  inline void clear_has_required_protection();
  inline void set_has_requested_protection();
  inline void clear_has_requested_protection();
  inline void set_has_key_control();
  inline void clear_has_key_control();
  inline void set_has_operator_session_key_permissions();
  inline void clear_has_operator_session_key_permissions();
  inline void set_has_anti_rollback_usage_table();
  inline void clear_has_anti_rollback_usage_table();

  ::std::string* id_;
  ::std::string* iv_;
  ::std::string* key_;
  int type_;
  int level_;
  ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* required_protection_;
  ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* requested_protection_;
  ::video_widevine_server::sdk::License_KeyContainer_KeyControl* key_control_;
  ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions* operator_session_key_permissions_;
  ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer_VideoResolutionConstraint > video_resolution_constraints_;
  bool anti_rollback_usage_table_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static License_KeyContainer* default_instance_;
};
// -------------------------------------------------------------------

class License : public ::google::protobuf::MessageLite {
 public:
  License();
  virtual ~License();

  License(const License& from);

  inline License& operator=(const License& from) {
    CopyFrom(from);
    return *this;
  }

  static const License& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const License* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(License* other);

  // implements Message ----------------------------------------------

  License* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const License& from);
  void MergeFrom(const License& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef License_Policy Policy;
  typedef License_KeyContainer KeyContainer;

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.LicenseIdentification id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::video_widevine_server::sdk::LicenseIdentification& id() const;
  inline ::video_widevine_server::sdk::LicenseIdentification* mutable_id();
  inline ::video_widevine_server::sdk::LicenseIdentification* release_id();
  inline void set_allocated_id(::video_widevine_server::sdk::LicenseIdentification* id);

  // optional .video_widevine_server.sdk.License.Policy policy = 2;
  inline bool has_policy() const;
  inline void clear_policy();
  static const int kPolicyFieldNumber = 2;
  inline const ::video_widevine_server::sdk::License_Policy& policy() const;
  inline ::video_widevine_server::sdk::License_Policy* mutable_policy();
  inline ::video_widevine_server::sdk::License_Policy* release_policy();
  inline void set_allocated_policy(::video_widevine_server::sdk::License_Policy* policy);

  // repeated .video_widevine_server.sdk.License.KeyContainer key = 3;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::video_widevine_server::sdk::License_KeyContainer& key(int index) const;
  inline ::video_widevine_server::sdk::License_KeyContainer* mutable_key(int index);
  inline ::video_widevine_server::sdk::License_KeyContainer* add_key();
  inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer >&
      key() const;
  inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer >*
      mutable_key();

  // optional int64 license_start_time = 4;
  inline bool has_license_start_time() const;
  inline void clear_license_start_time();
  static const int kLicenseStartTimeFieldNumber = 4;
  inline ::google::protobuf::int64 license_start_time() const;
  inline void set_license_start_time(::google::protobuf::int64 value);

  // optional bool remote_attestation_verified = 5 [default = false];
  inline bool has_remote_attestation_verified() const;
  inline void clear_remote_attestation_verified();
  static const int kRemoteAttestationVerifiedFieldNumber = 5;
  inline bool remote_attestation_verified() const;
  inline void set_remote_attestation_verified(bool value);

  // optional bytes provider_client_token = 6;
  inline bool has_provider_client_token() const;
  inline void clear_provider_client_token();
  static const int kProviderClientTokenFieldNumber = 6;
  inline const ::std::string& provider_client_token() const;
  inline void set_provider_client_token(const ::std::string& value);
  inline void set_provider_client_token(const char* value);
  inline void set_provider_client_token(const void* value, size_t size);
  inline ::std::string* mutable_provider_client_token();
  inline ::std::string* release_provider_client_token();
  inline void set_allocated_provider_client_token(::std::string* provider_client_token);

  // optional uint32 protection_scheme = 7;
  inline bool has_protection_scheme() const;
  inline void clear_protection_scheme();
  static const int kProtectionSchemeFieldNumber = 7;
  inline ::google::protobuf::uint32 protection_scheme() const;
  inline void set_protection_scheme(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.License)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_policy();
  inline void clear_has_policy();
  inline void set_has_license_start_time();
  inline void clear_has_license_start_time();
  inline void set_has_remote_attestation_verified();
  inline void clear_has_remote_attestation_verified();
  inline void set_has_provider_client_token();
  inline void clear_has_provider_client_token();
  inline void set_has_protection_scheme();
  inline void clear_has_protection_scheme();

  ::video_widevine_server::sdk::LicenseIdentification* id_;
  ::video_widevine_server::sdk::License_Policy* policy_;
  ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer > key_;
  ::google::protobuf::int64 license_start_time_;
  ::std::string* provider_client_token_;
  bool remote_attestation_verified_;
  ::google::protobuf::uint32 protection_scheme_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static License* default_instance_;
};
// -------------------------------------------------------------------

class LicenseRequest_ContentIdentification_CENC : public ::google::protobuf::MessageLite {
 public:
  LicenseRequest_ContentIdentification_CENC();
  virtual ~LicenseRequest_ContentIdentification_CENC();

  LicenseRequest_ContentIdentification_CENC(const LicenseRequest_ContentIdentification_CENC& from);

  inline LicenseRequest_ContentIdentification_CENC& operator=(const LicenseRequest_ContentIdentification_CENC& from) {
    CopyFrom(from);
    return *this;
  }

  static const LicenseRequest_ContentIdentification_CENC& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LicenseRequest_ContentIdentification_CENC* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LicenseRequest_ContentIdentification_CENC* other);

  // implements Message ----------------------------------------------

  LicenseRequest_ContentIdentification_CENC* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LicenseRequest_ContentIdentification_CENC& from);
  void MergeFrom(const LicenseRequest_ContentIdentification_CENC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes pssh = 1;
  inline int pssh_size() const;
  inline void clear_pssh();
  static const int kPsshFieldNumber = 1;
  inline const ::std::string& pssh(int index) const;
  inline ::std::string* mutable_pssh(int index);
  inline void set_pssh(int index, const ::std::string& value);
  inline void set_pssh(int index, const char* value);
  inline void set_pssh(int index, const void* value, size_t size);
  inline ::std::string* add_pssh();
  inline void add_pssh(const ::std::string& value);
  inline void add_pssh(const char* value);
  inline void add_pssh(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pssh() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pssh();

  // optional .video_widevine_server.sdk.LicenseType license_type = 2;
  inline bool has_license_type() const;
  inline void clear_license_type();
  static const int kLicenseTypeFieldNumber = 2;
  inline ::video_widevine_server::sdk::LicenseType license_type() const;
  inline void set_license_type(::video_widevine_server::sdk::LicenseType value);

  // optional bytes request_id = 3;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 3;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const void* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  inline void set_allocated_request_id(::std::string* request_id);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.LicenseRequest.ContentIdentification.CENC)
 private:
  inline void set_has_license_type();
  inline void clear_has_license_type();
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::google::protobuf::RepeatedPtrField< ::std::string> pssh_;
  ::std::string* request_id_;
  int license_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static LicenseRequest_ContentIdentification_CENC* default_instance_;
};
// -------------------------------------------------------------------

class LicenseRequest_ContentIdentification_WebM : public ::google::protobuf::MessageLite {
 public:
  LicenseRequest_ContentIdentification_WebM();
  virtual ~LicenseRequest_ContentIdentification_WebM();

  LicenseRequest_ContentIdentification_WebM(const LicenseRequest_ContentIdentification_WebM& from);

  inline LicenseRequest_ContentIdentification_WebM& operator=(const LicenseRequest_ContentIdentification_WebM& from) {
    CopyFrom(from);
    return *this;
  }

  static const LicenseRequest_ContentIdentification_WebM& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LicenseRequest_ContentIdentification_WebM* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LicenseRequest_ContentIdentification_WebM* other);

  // implements Message ----------------------------------------------

  LicenseRequest_ContentIdentification_WebM* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LicenseRequest_ContentIdentification_WebM& from);
  void MergeFrom(const LicenseRequest_ContentIdentification_WebM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::std::string& header() const;
  inline void set_header(const ::std::string& value);
  inline void set_header(const char* value);
  inline void set_header(const void* value, size_t size);
  inline ::std::string* mutable_header();
  inline ::std::string* release_header();
  inline void set_allocated_header(::std::string* header);

  // optional .video_widevine_server.sdk.LicenseType license_type = 2;
  inline bool has_license_type() const;
  inline void clear_license_type();
  static const int kLicenseTypeFieldNumber = 2;
  inline ::video_widevine_server::sdk::LicenseType license_type() const;
  inline void set_license_type(::video_widevine_server::sdk::LicenseType value);

  // optional bytes request_id = 3;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 3;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const void* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  inline void set_allocated_request_id(::std::string* request_id);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.LicenseRequest.ContentIdentification.WebM)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_license_type();
  inline void clear_has_license_type();
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::std::string* header_;
  ::std::string* request_id_;
  int license_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static LicenseRequest_ContentIdentification_WebM* default_instance_;
};
// -------------------------------------------------------------------

class LicenseRequest_ContentIdentification_ExistingLicense : public ::google::protobuf::MessageLite {
 public:
  LicenseRequest_ContentIdentification_ExistingLicense();
  virtual ~LicenseRequest_ContentIdentification_ExistingLicense();

  LicenseRequest_ContentIdentification_ExistingLicense(const LicenseRequest_ContentIdentification_ExistingLicense& from);

  inline LicenseRequest_ContentIdentification_ExistingLicense& operator=(const LicenseRequest_ContentIdentification_ExistingLicense& from) {
    CopyFrom(from);
    return *this;
  }

  static const LicenseRequest_ContentIdentification_ExistingLicense& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LicenseRequest_ContentIdentification_ExistingLicense* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LicenseRequest_ContentIdentification_ExistingLicense* other);

  // implements Message ----------------------------------------------

  LicenseRequest_ContentIdentification_ExistingLicense* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LicenseRequest_ContentIdentification_ExistingLicense& from);
  void MergeFrom(const LicenseRequest_ContentIdentification_ExistingLicense& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.LicenseIdentification license_id = 1;
  inline bool has_license_id() const;
  inline void clear_license_id();
  static const int kLicenseIdFieldNumber = 1;
  inline const ::video_widevine_server::sdk::LicenseIdentification& license_id() const;
  inline ::video_widevine_server::sdk::LicenseIdentification* mutable_license_id();
  inline ::video_widevine_server::sdk::LicenseIdentification* release_license_id();
  inline void set_allocated_license_id(::video_widevine_server::sdk::LicenseIdentification* license_id);

  // optional int64 seconds_since_started = 2;
  inline bool has_seconds_since_started() const;
  inline void clear_seconds_since_started();
  static const int kSecondsSinceStartedFieldNumber = 2;
  inline ::google::protobuf::int64 seconds_since_started() const;
  inline void set_seconds_since_started(::google::protobuf::int64 value);

  // optional int64 seconds_since_last_played = 3;
  inline bool has_seconds_since_last_played() const;
  inline void clear_seconds_since_last_played();
  static const int kSecondsSinceLastPlayedFieldNumber = 3;
  inline ::google::protobuf::int64 seconds_since_last_played() const;
  inline void set_seconds_since_last_played(::google::protobuf::int64 value);

  // optional bytes session_usage_table_entry = 4;
  inline bool has_session_usage_table_entry() const;
  inline void clear_session_usage_table_entry();
  static const int kSessionUsageTableEntryFieldNumber = 4;
  inline const ::std::string& session_usage_table_entry() const;
  inline void set_session_usage_table_entry(const ::std::string& value);
  inline void set_session_usage_table_entry(const char* value);
  inline void set_session_usage_table_entry(const void* value, size_t size);
  inline ::std::string* mutable_session_usage_table_entry();
  inline ::std::string* release_session_usage_table_entry();
  inline void set_allocated_session_usage_table_entry(::std::string* session_usage_table_entry);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.LicenseRequest.ContentIdentification.ExistingLicense)
 private:
  inline void set_has_license_id();
  inline void clear_has_license_id();
  inline void set_has_seconds_since_started();
  inline void clear_has_seconds_since_started();
  inline void set_has_seconds_since_last_played();
  inline void clear_has_seconds_since_last_played();
  inline void set_has_session_usage_table_entry();
  inline void clear_has_session_usage_table_entry();

  ::video_widevine_server::sdk::LicenseIdentification* license_id_;
  ::google::protobuf::int64 seconds_since_started_;
  ::google::protobuf::int64 seconds_since_last_played_;
  ::std::string* session_usage_table_entry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static LicenseRequest_ContentIdentification_ExistingLicense* default_instance_;
};
// -------------------------------------------------------------------

class LicenseRequest_ContentIdentification : public ::google::protobuf::MessageLite {
 public:
  LicenseRequest_ContentIdentification();
  virtual ~LicenseRequest_ContentIdentification();

  LicenseRequest_ContentIdentification(const LicenseRequest_ContentIdentification& from);

  inline LicenseRequest_ContentIdentification& operator=(const LicenseRequest_ContentIdentification& from) {
    CopyFrom(from);
    return *this;
  }

  static const LicenseRequest_ContentIdentification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LicenseRequest_ContentIdentification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LicenseRequest_ContentIdentification* other);

  // implements Message ----------------------------------------------

  LicenseRequest_ContentIdentification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LicenseRequest_ContentIdentification& from);
  void MergeFrom(const LicenseRequest_ContentIdentification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LicenseRequest_ContentIdentification_CENC CENC;
  typedef LicenseRequest_ContentIdentification_WebM WebM;
  typedef LicenseRequest_ContentIdentification_ExistingLicense ExistingLicense;

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.CENC cenc_id = 1;
  inline bool has_cenc_id() const;
  inline void clear_cenc_id();
  static const int kCencIdFieldNumber = 1;
  inline const ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC& cenc_id() const;
  inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC* mutable_cenc_id();
  inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC* release_cenc_id();
  inline void set_allocated_cenc_id(::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC* cenc_id);

  // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.WebM webm_id = 2;
  inline bool has_webm_id() const;
  inline void clear_webm_id();
  static const int kWebmIdFieldNumber = 2;
  inline const ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM& webm_id() const;
  inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM* mutable_webm_id();
  inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM* release_webm_id();
  inline void set_allocated_webm_id(::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM* webm_id);

  // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.ExistingLicense license = 3;
  inline bool has_license() const;
  inline void clear_license();
  static const int kLicenseFieldNumber = 3;
  inline const ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense& license() const;
  inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense* mutable_license();
  inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense* release_license();
  inline void set_allocated_license(::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense* license);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.LicenseRequest.ContentIdentification)
 private:
  inline void set_has_cenc_id();
  inline void clear_has_cenc_id();
  inline void set_has_webm_id();
  inline void clear_has_webm_id();
  inline void set_has_license();
  inline void clear_has_license();

  ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC* cenc_id_;
  ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM* webm_id_;
  ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense* license_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static LicenseRequest_ContentIdentification* default_instance_;
};
// -------------------------------------------------------------------

class LicenseRequest : public ::google::protobuf::MessageLite {
 public:
  LicenseRequest();
  virtual ~LicenseRequest();

  LicenseRequest(const LicenseRequest& from);

  inline LicenseRequest& operator=(const LicenseRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const LicenseRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LicenseRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LicenseRequest* other);

  // implements Message ----------------------------------------------

  LicenseRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LicenseRequest& from);
  void MergeFrom(const LicenseRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LicenseRequest_ContentIdentification ContentIdentification;

  typedef LicenseRequest_RequestType RequestType;
  static const RequestType NEW = LicenseRequest_RequestType_NEW;
  static const RequestType RENEWAL = LicenseRequest_RequestType_RENEWAL;
  static const RequestType RELEASE = LicenseRequest_RequestType_RELEASE;
  static inline bool RequestType_IsValid(int value) {
    return LicenseRequest_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    LicenseRequest_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    LicenseRequest_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    LicenseRequest_RequestType_RequestType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.ClientIdentification client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::video_widevine_server::sdk::ClientIdentification& client_id() const;
  inline ::video_widevine_server::sdk::ClientIdentification* mutable_client_id();
  inline ::video_widevine_server::sdk::ClientIdentification* release_client_id();
  inline void set_allocated_client_id(::video_widevine_server::sdk::ClientIdentification* client_id);

  // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification content_id = 2;
  inline bool has_content_id() const;
  inline void clear_content_id();
  static const int kContentIdFieldNumber = 2;
  inline const ::video_widevine_server::sdk::LicenseRequest_ContentIdentification& content_id() const;
  inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification* mutable_content_id();
  inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification* release_content_id();
  inline void set_allocated_content_id(::video_widevine_server::sdk::LicenseRequest_ContentIdentification* content_id);

  // optional .video_widevine_server.sdk.LicenseRequest.RequestType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::video_widevine_server::sdk::LicenseRequest_RequestType type() const;
  inline void set_type(::video_widevine_server::sdk::LicenseRequest_RequestType value);

  // optional int64 request_time = 4;
  inline bool has_request_time() const;
  inline void clear_request_time();
  static const int kRequestTimeFieldNumber = 4;
  inline ::google::protobuf::int64 request_time() const;
  inline void set_request_time(::google::protobuf::int64 value);

  // optional bytes key_control_nonce_deprecated = 5;
  inline bool has_key_control_nonce_deprecated() const;
  inline void clear_key_control_nonce_deprecated();
  static const int kKeyControlNonceDeprecatedFieldNumber = 5;
  inline const ::std::string& key_control_nonce_deprecated() const;
  inline void set_key_control_nonce_deprecated(const ::std::string& value);
  inline void set_key_control_nonce_deprecated(const char* value);
  inline void set_key_control_nonce_deprecated(const void* value, size_t size);
  inline ::std::string* mutable_key_control_nonce_deprecated();
  inline ::std::string* release_key_control_nonce_deprecated();
  inline void set_allocated_key_control_nonce_deprecated(::std::string* key_control_nonce_deprecated);

  // optional .video_widevine_server.sdk.ProtocolVersion protocol_version = 6 [default = VERSION_2_0];
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 6;
  inline ::video_widevine_server::sdk::ProtocolVersion protocol_version() const;
  inline void set_protocol_version(::video_widevine_server::sdk::ProtocolVersion value);

  // optional uint32 key_control_nonce = 7;
  inline bool has_key_control_nonce() const;
  inline void clear_key_control_nonce();
  static const int kKeyControlNonceFieldNumber = 7;
  inline ::google::protobuf::uint32 key_control_nonce() const;
  inline void set_key_control_nonce(::google::protobuf::uint32 value);

  // optional .video_widevine_server.sdk.EncryptedClientIdentification encrypted_client_id = 8;
  inline bool has_encrypted_client_id() const;
  inline void clear_encrypted_client_id();
  static const int kEncryptedClientIdFieldNumber = 8;
  inline const ::video_widevine_server::sdk::EncryptedClientIdentification& encrypted_client_id() const;
  inline ::video_widevine_server::sdk::EncryptedClientIdentification* mutable_encrypted_client_id();
  inline ::video_widevine_server::sdk::EncryptedClientIdentification* release_encrypted_client_id();
  inline void set_allocated_encrypted_client_id(::video_widevine_server::sdk::EncryptedClientIdentification* encrypted_client_id);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.LicenseRequest)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_content_id();
  inline void clear_has_content_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_request_time();
  inline void clear_has_request_time();
  inline void set_has_key_control_nonce_deprecated();
  inline void clear_has_key_control_nonce_deprecated();
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_key_control_nonce();
  inline void clear_has_key_control_nonce();
  inline void set_has_encrypted_client_id();
  inline void clear_has_encrypted_client_id();

  ::video_widevine_server::sdk::ClientIdentification* client_id_;
  ::video_widevine_server::sdk::LicenseRequest_ContentIdentification* content_id_;
  ::google::protobuf::int64 request_time_;
  int type_;
  int protocol_version_;
  ::std::string* key_control_nonce_deprecated_;
  ::video_widevine_server::sdk::EncryptedClientIdentification* encrypted_client_id_;
  ::google::protobuf::uint32 key_control_nonce_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static LicenseRequest* default_instance_;
};
// -------------------------------------------------------------------

class LicenseError : public ::google::protobuf::MessageLite {
 public:
  LicenseError();
  virtual ~LicenseError();

  LicenseError(const LicenseError& from);

  inline LicenseError& operator=(const LicenseError& from) {
    CopyFrom(from);
    return *this;
  }

  static const LicenseError& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LicenseError* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LicenseError* other);

  // implements Message ----------------------------------------------

  LicenseError* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LicenseError& from);
  void MergeFrom(const LicenseError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LicenseError_Error Error;
  static const Error INVALID_DEVICE_CERTIFICATE = LicenseError_Error_INVALID_DEVICE_CERTIFICATE;
  static const Error REVOKED_DEVICE_CERTIFICATE = LicenseError_Error_REVOKED_DEVICE_CERTIFICATE;
  static const Error SERVICE_UNAVAILABLE = LicenseError_Error_SERVICE_UNAVAILABLE;
  static inline bool Error_IsValid(int value) {
    return LicenseError_Error_IsValid(value);
  }
  static const Error Error_MIN =
    LicenseError_Error_Error_MIN;
  static const Error Error_MAX =
    LicenseError_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    LicenseError_Error_Error_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.LicenseError.Error error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::video_widevine_server::sdk::LicenseError_Error error_code() const;
  inline void set_error_code(::video_widevine_server::sdk::LicenseError_Error value);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.LicenseError)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();

  int error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static LicenseError* default_instance_;
};
// -------------------------------------------------------------------

class MetricData_TypeValue : public ::google::protobuf::MessageLite {
 public:
  MetricData_TypeValue();
  virtual ~MetricData_TypeValue();

  MetricData_TypeValue(const MetricData_TypeValue& from);

  inline MetricData_TypeValue& operator=(const MetricData_TypeValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const MetricData_TypeValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MetricData_TypeValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MetricData_TypeValue* other);

  // implements Message ----------------------------------------------

  MetricData_TypeValue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MetricData_TypeValue& from);
  void MergeFrom(const MetricData_TypeValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.MetricData.MetricType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::video_widevine_server::sdk::MetricData_MetricType type() const;
  inline void set_type(::video_widevine_server::sdk::MetricData_MetricType value);

  // optional int64 value = 2 [default = 0];
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.MetricData.TypeValue)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::int64 value_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static MetricData_TypeValue* default_instance_;
};
// -------------------------------------------------------------------

class MetricData : public ::google::protobuf::MessageLite {
 public:
  MetricData();
  virtual ~MetricData();

  MetricData(const MetricData& from);

  inline MetricData& operator=(const MetricData& from) {
    CopyFrom(from);
    return *this;
  }

  static const MetricData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MetricData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MetricData* other);

  // implements Message ----------------------------------------------

  MetricData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MetricData& from);
  void MergeFrom(const MetricData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MetricData_TypeValue TypeValue;

  typedef MetricData_MetricType MetricType;
  static const MetricType LATENCY = MetricData_MetricType_LATENCY;
  static const MetricType TIMESTAMP = MetricData_MetricType_TIMESTAMP;
  static inline bool MetricType_IsValid(int value) {
    return MetricData_MetricType_IsValid(value);
  }
  static const MetricType MetricType_MIN =
    MetricData_MetricType_MetricType_MIN;
  static const MetricType MetricType_MAX =
    MetricData_MetricType_MetricType_MAX;
  static const int MetricType_ARRAYSIZE =
    MetricData_MetricType_MetricType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string stage_name = 1;
  inline bool has_stage_name() const;
  inline void clear_stage_name();
  static const int kStageNameFieldNumber = 1;
  inline const ::std::string& stage_name() const;
  inline void set_stage_name(const ::std::string& value);
  inline void set_stage_name(const char* value);
  inline void set_stage_name(const char* value, size_t size);
  inline ::std::string* mutable_stage_name();
  inline ::std::string* release_stage_name();
  inline void set_allocated_stage_name(::std::string* stage_name);

  // repeated .video_widevine_server.sdk.MetricData.TypeValue metric_data = 2;
  inline int metric_data_size() const;
  inline void clear_metric_data();
  static const int kMetricDataFieldNumber = 2;
  inline const ::video_widevine_server::sdk::MetricData_TypeValue& metric_data(int index) const;
  inline ::video_widevine_server::sdk::MetricData_TypeValue* mutable_metric_data(int index);
  inline ::video_widevine_server::sdk::MetricData_TypeValue* add_metric_data();
  inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::MetricData_TypeValue >&
      metric_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::MetricData_TypeValue >*
      mutable_metric_data();

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.MetricData)
 private:
  inline void set_has_stage_name();
  inline void clear_has_stage_name();

  ::std::string* stage_name_;
  ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::MetricData_TypeValue > metric_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static MetricData* default_instance_;
};
// -------------------------------------------------------------------

class RemoteAttestation : public ::google::protobuf::MessageLite {
 public:
  RemoteAttestation();
  virtual ~RemoteAttestation();

  RemoteAttestation(const RemoteAttestation& from);

  inline RemoteAttestation& operator=(const RemoteAttestation& from) {
    CopyFrom(from);
    return *this;
  }

  static const RemoteAttestation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoteAttestation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoteAttestation* other);

  // implements Message ----------------------------------------------

  RemoteAttestation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoteAttestation& from);
  void MergeFrom(const RemoteAttestation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.EncryptedClientIdentification certificate = 1;
  inline bool has_certificate() const;
  inline void clear_certificate();
  static const int kCertificateFieldNumber = 1;
  inline const ::video_widevine_server::sdk::EncryptedClientIdentification& certificate() const;
  inline ::video_widevine_server::sdk::EncryptedClientIdentification* mutable_certificate();
  inline ::video_widevine_server::sdk::EncryptedClientIdentification* release_certificate();
  inline void set_allocated_certificate(::video_widevine_server::sdk::EncryptedClientIdentification* certificate);

  // optional bytes salt = 2;
  inline bool has_salt() const;
  inline void clear_salt();
  static const int kSaltFieldNumber = 2;
  inline const ::std::string& salt() const;
  inline void set_salt(const ::std::string& value);
  inline void set_salt(const char* value);
  inline void set_salt(const void* value, size_t size);
  inline ::std::string* mutable_salt();
  inline ::std::string* release_salt();
  inline void set_allocated_salt(::std::string* salt);

  // optional bytes signature = 3;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 3;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.RemoteAttestation)
 private:
  inline void set_has_certificate();
  inline void clear_has_certificate();
  inline void set_has_salt();
  inline void clear_has_salt();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::video_widevine_server::sdk::EncryptedClientIdentification* certificate_;
  ::std::string* salt_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static RemoteAttestation* default_instance_;
};
// -------------------------------------------------------------------

class SignedMessage : public ::google::protobuf::MessageLite {
 public:
  SignedMessage();
  virtual ~SignedMessage();

  SignedMessage(const SignedMessage& from);

  inline SignedMessage& operator=(const SignedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const SignedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SignedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SignedMessage* other);

  // implements Message ----------------------------------------------

  SignedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SignedMessage& from);
  void MergeFrom(const SignedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SignedMessage_MessageType MessageType;
  static const MessageType LICENSE_REQUEST = SignedMessage_MessageType_LICENSE_REQUEST;
  static const MessageType LICENSE = SignedMessage_MessageType_LICENSE;
  static const MessageType ERROR_RESPONSE = SignedMessage_MessageType_ERROR_RESPONSE;
  static const MessageType SERVICE_CERTIFICATE_REQUEST = SignedMessage_MessageType_SERVICE_CERTIFICATE_REQUEST;
  static const MessageType SERVICE_CERTIFICATE = SignedMessage_MessageType_SERVICE_CERTIFICATE;
  static inline bool MessageType_IsValid(int value) {
    return SignedMessage_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    SignedMessage_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    SignedMessage_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    SignedMessage_MessageType_MessageType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.SignedMessage.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::video_widevine_server::sdk::SignedMessage_MessageType type() const;
  inline void set_type(::video_widevine_server::sdk::SignedMessage_MessageType value);

  // optional bytes msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional bytes signature = 3;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 3;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional bytes session_key = 4;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 4;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const void* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // optional .video_widevine_server.sdk.RemoteAttestation remote_attestation = 5;
  inline bool has_remote_attestation() const;
  inline void clear_remote_attestation();
  static const int kRemoteAttestationFieldNumber = 5;
  inline const ::video_widevine_server::sdk::RemoteAttestation& remote_attestation() const;
  inline ::video_widevine_server::sdk::RemoteAttestation* mutable_remote_attestation();
  inline ::video_widevine_server::sdk::RemoteAttestation* release_remote_attestation();
  inline void set_allocated_remote_attestation(::video_widevine_server::sdk::RemoteAttestation* remote_attestation);

  // repeated .video_widevine_server.sdk.MetricData metric_data = 6;
  inline int metric_data_size() const;
  inline void clear_metric_data();
  static const int kMetricDataFieldNumber = 6;
  inline const ::video_widevine_server::sdk::MetricData& metric_data(int index) const;
  inline ::video_widevine_server::sdk::MetricData* mutable_metric_data(int index);
  inline ::video_widevine_server::sdk::MetricData* add_metric_data();
  inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::MetricData >&
      metric_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::MetricData >*
      mutable_metric_data();

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.SignedMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_remote_attestation();
  inline void clear_has_remote_attestation();

  ::std::string* msg_;
  ::std::string* signature_;
  ::std::string* session_key_;
  ::video_widevine_server::sdk::RemoteAttestation* remote_attestation_;
  ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::MetricData > metric_data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static SignedMessage* default_instance_;
};
// -------------------------------------------------------------------

class GroupKeys : public ::google::protobuf::MessageLite {
 public:
  GroupKeys();
  virtual ~GroupKeys();

  GroupKeys(const GroupKeys& from);

  inline GroupKeys& operator=(const GroupKeys& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupKeys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupKeys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupKeys* other);

  // implements Message ----------------------------------------------

  GroupKeys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupKeys& from);
  void MergeFrom(const GroupKeys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .video_widevine_server.sdk.License.KeyContainer key = 1;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::video_widevine_server::sdk::License_KeyContainer& key(int index) const;
  inline ::video_widevine_server::sdk::License_KeyContainer* mutable_key(int index);
  inline ::video_widevine_server::sdk::License_KeyContainer* add_key();
  inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer >&
      key() const;
  inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer >*
      mutable_key();

  // optional bytes group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline const ::std::string& group_id() const;
  inline void set_group_id(const ::std::string& value);
  inline void set_group_id(const char* value);
  inline void set_group_id(const void* value, size_t size);
  inline ::std::string* mutable_group_id();
  inline ::std::string* release_group_id();
  inline void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.GroupKeys)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer > key_;
  ::std::string* group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static GroupKeys* default_instance_;
};
// -------------------------------------------------------------------

class ProvisioningOptions : public ::google::protobuf::MessageLite {
 public:
  ProvisioningOptions();
  virtual ~ProvisioningOptions();

  ProvisioningOptions(const ProvisioningOptions& from);

  inline ProvisioningOptions& operator=(const ProvisioningOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ProvisioningOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ProvisioningOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ProvisioningOptions* other);

  // implements Message ----------------------------------------------

  ProvisioningOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProvisioningOptions& from);
  void MergeFrom(const ProvisioningOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ProvisioningOptions_CertificateType CertificateType;
  static const CertificateType WIDEVINE_DRM = ProvisioningOptions_CertificateType_WIDEVINE_DRM;
  static const CertificateType X509 = ProvisioningOptions_CertificateType_X509;
  static inline bool CertificateType_IsValid(int value) {
    return ProvisioningOptions_CertificateType_IsValid(value);
  }
  static const CertificateType CertificateType_MIN =
    ProvisioningOptions_CertificateType_CertificateType_MIN;
  static const CertificateType CertificateType_MAX =
    ProvisioningOptions_CertificateType_CertificateType_MAX;
  static const int CertificateType_ARRAYSIZE =
    ProvisioningOptions_CertificateType_CertificateType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.ProvisioningOptions.CertificateType certificate_type = 1;
  inline bool has_certificate_type() const;
  inline void clear_certificate_type();
  static const int kCertificateTypeFieldNumber = 1;
  inline ::video_widevine_server::sdk::ProvisioningOptions_CertificateType certificate_type() const;
  inline void set_certificate_type(::video_widevine_server::sdk::ProvisioningOptions_CertificateType value);

  // optional string certificate_authority = 2;
  inline bool has_certificate_authority() const;
  inline void clear_certificate_authority();
  static const int kCertificateAuthorityFieldNumber = 2;
  inline const ::std::string& certificate_authority() const;
  inline void set_certificate_authority(const ::std::string& value);
  inline void set_certificate_authority(const char* value);
  inline void set_certificate_authority(const char* value, size_t size);
  inline ::std::string* mutable_certificate_authority();
  inline ::std::string* release_certificate_authority();
  inline void set_allocated_certificate_authority(::std::string* certificate_authority);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.ProvisioningOptions)
 private:
  inline void set_has_certificate_type();
  inline void clear_has_certificate_type();
  inline void set_has_certificate_authority();
  inline void clear_has_certificate_authority();

  ::std::string* certificate_authority_;
  int certificate_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ProvisioningOptions* default_instance_;
};
// -------------------------------------------------------------------

class ProvisioningRequest : public ::google::protobuf::MessageLite {
 public:
  ProvisioningRequest();
  virtual ~ProvisioningRequest();

  ProvisioningRequest(const ProvisioningRequest& from);

  inline ProvisioningRequest& operator=(const ProvisioningRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ProvisioningRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ProvisioningRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ProvisioningRequest* other);

  // implements Message ----------------------------------------------

  ProvisioningRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProvisioningRequest& from);
  void MergeFrom(const ProvisioningRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.ClientIdentification client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::video_widevine_server::sdk::ClientIdentification& client_id() const;
  inline ::video_widevine_server::sdk::ClientIdentification* mutable_client_id();
  inline ::video_widevine_server::sdk::ClientIdentification* release_client_id();
  inline void set_allocated_client_id(::video_widevine_server::sdk::ClientIdentification* client_id);

  // optional bytes nonce = 2;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 2;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const void* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  inline void set_allocated_nonce(::std::string* nonce);

  // optional .video_widevine_server.sdk.ProvisioningOptions options = 3;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 3;
  inline const ::video_widevine_server::sdk::ProvisioningOptions& options() const;
  inline ::video_widevine_server::sdk::ProvisioningOptions* mutable_options();
  inline ::video_widevine_server::sdk::ProvisioningOptions* release_options();
  inline void set_allocated_options(::video_widevine_server::sdk::ProvisioningOptions* options);

  // optional bytes stable_id = 4;
  inline bool has_stable_id() const;
  inline void clear_stable_id();
  static const int kStableIdFieldNumber = 4;
  inline const ::std::string& stable_id() const;
  inline void set_stable_id(const ::std::string& value);
  inline void set_stable_id(const char* value);
  inline void set_stable_id(const void* value, size_t size);
  inline ::std::string* mutable_stable_id();
  inline ::std::string* release_stable_id();
  inline void set_allocated_stable_id(::std::string* stable_id);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.ProvisioningRequest)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_stable_id();
  inline void clear_has_stable_id();

  ::video_widevine_server::sdk::ClientIdentification* client_id_;
  ::std::string* nonce_;
  ::video_widevine_server::sdk::ProvisioningOptions* options_;
  ::std::string* stable_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ProvisioningRequest* default_instance_;
};
// -------------------------------------------------------------------

class ProvisioningResponse : public ::google::protobuf::MessageLite {
 public:
  ProvisioningResponse();
  virtual ~ProvisioningResponse();

  ProvisioningResponse(const ProvisioningResponse& from);

  inline ProvisioningResponse& operator=(const ProvisioningResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ProvisioningResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ProvisioningResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ProvisioningResponse* other);

  // implements Message ----------------------------------------------

  ProvisioningResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProvisioningResponse& from);
  void MergeFrom(const ProvisioningResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes device_rsa_key = 1;
  inline bool has_device_rsa_key() const;
  inline void clear_device_rsa_key();
  static const int kDeviceRsaKeyFieldNumber = 1;
  inline const ::std::string& device_rsa_key() const;
  inline void set_device_rsa_key(const ::std::string& value);
  inline void set_device_rsa_key(const char* value);
  inline void set_device_rsa_key(const void* value, size_t size);
  inline ::std::string* mutable_device_rsa_key();
  inline ::std::string* release_device_rsa_key();
  inline void set_allocated_device_rsa_key(::std::string* device_rsa_key);

  // optional bytes device_rsa_key_iv = 2;
  inline bool has_device_rsa_key_iv() const;
  inline void clear_device_rsa_key_iv();
  static const int kDeviceRsaKeyIvFieldNumber = 2;
  inline const ::std::string& device_rsa_key_iv() const;
  inline void set_device_rsa_key_iv(const ::std::string& value);
  inline void set_device_rsa_key_iv(const char* value);
  inline void set_device_rsa_key_iv(const void* value, size_t size);
  inline ::std::string* mutable_device_rsa_key_iv();
  inline ::std::string* release_device_rsa_key_iv();
  inline void set_allocated_device_rsa_key_iv(::std::string* device_rsa_key_iv);

  // optional bytes device_certificate = 3;
  inline bool has_device_certificate() const;
  inline void clear_device_certificate();
  static const int kDeviceCertificateFieldNumber = 3;
  inline const ::std::string& device_certificate() const;
  inline void set_device_certificate(const ::std::string& value);
  inline void set_device_certificate(const char* value);
  inline void set_device_certificate(const void* value, size_t size);
  inline ::std::string* mutable_device_certificate();
  inline ::std::string* release_device_certificate();
  inline void set_allocated_device_certificate(::std::string* device_certificate);

  // optional bytes nonce = 4;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 4;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const void* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  inline void set_allocated_nonce(::std::string* nonce);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.ProvisioningResponse)
 private:
  inline void set_has_device_rsa_key();
  inline void clear_has_device_rsa_key();
  inline void set_has_device_rsa_key_iv();
  inline void clear_has_device_rsa_key_iv();
  inline void set_has_device_certificate();
  inline void clear_has_device_certificate();
  inline void set_has_nonce();
  inline void clear_has_nonce();

  ::std::string* device_rsa_key_;
  ::std::string* device_rsa_key_iv_;
  ::std::string* device_certificate_;
  ::std::string* nonce_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ProvisioningResponse* default_instance_;
};
// -------------------------------------------------------------------

class SignedProvisioningMessage : public ::google::protobuf::MessageLite {
 public:
  SignedProvisioningMessage();
  virtual ~SignedProvisioningMessage();

  SignedProvisioningMessage(const SignedProvisioningMessage& from);

  inline SignedProvisioningMessage& operator=(const SignedProvisioningMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const SignedProvisioningMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SignedProvisioningMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SignedProvisioningMessage* other);

  // implements Message ----------------------------------------------

  SignedProvisioningMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SignedProvisioningMessage& from);
  void MergeFrom(const SignedProvisioningMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.SignedProvisioningMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::std::string* message_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static SignedProvisioningMessage* default_instance_;
};
// -------------------------------------------------------------------

class ClientIdentification_NameValue : public ::google::protobuf::MessageLite {
 public:
  ClientIdentification_NameValue();
  virtual ~ClientIdentification_NameValue();

  ClientIdentification_NameValue(const ClientIdentification_NameValue& from);

  inline ClientIdentification_NameValue& operator=(const ClientIdentification_NameValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientIdentification_NameValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientIdentification_NameValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientIdentification_NameValue* other);

  // implements Message ----------------------------------------------

  ClientIdentification_NameValue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientIdentification_NameValue& from);
  void MergeFrom(const ClientIdentification_NameValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.ClientIdentification.NameValue)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientIdentification_NameValue* default_instance_;
};
// -------------------------------------------------------------------

class ClientIdentification_ClientCapabilities : public ::google::protobuf::MessageLite {
 public:
  ClientIdentification_ClientCapabilities();
  virtual ~ClientIdentification_ClientCapabilities();

  ClientIdentification_ClientCapabilities(const ClientIdentification_ClientCapabilities& from);

  inline ClientIdentification_ClientCapabilities& operator=(const ClientIdentification_ClientCapabilities& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientIdentification_ClientCapabilities& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientIdentification_ClientCapabilities* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientIdentification_ClientCapabilities* other);

  // implements Message ----------------------------------------------

  ClientIdentification_ClientCapabilities* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientIdentification_ClientCapabilities& from);
  void MergeFrom(const ClientIdentification_ClientCapabilities& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientIdentification_ClientCapabilities_HdcpVersion HdcpVersion;
  static const HdcpVersion HDCP_NONE = ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_NONE;
  static const HdcpVersion HDCP_V1 = ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_V1;
  static const HdcpVersion HDCP_V2 = ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_V2;
  static const HdcpVersion HDCP_V2_1 = ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_V2_1;
  static const HdcpVersion HDCP_V2_2 = ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_V2_2;
  static const HdcpVersion HDCP_NO_DIGITAL_OUTPUT = ClientIdentification_ClientCapabilities_HdcpVersion_HDCP_NO_DIGITAL_OUTPUT;
  static inline bool HdcpVersion_IsValid(int value) {
    return ClientIdentification_ClientCapabilities_HdcpVersion_IsValid(value);
  }
  static const HdcpVersion HdcpVersion_MIN =
    ClientIdentification_ClientCapabilities_HdcpVersion_HdcpVersion_MIN;
  static const HdcpVersion HdcpVersion_MAX =
    ClientIdentification_ClientCapabilities_HdcpVersion_HdcpVersion_MAX;
  static const int HdcpVersion_ARRAYSIZE =
    ClientIdentification_ClientCapabilities_HdcpVersion_HdcpVersion_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bool client_token = 1 [default = false];
  inline bool has_client_token() const;
  inline void clear_client_token();
  static const int kClientTokenFieldNumber = 1;
  inline bool client_token() const;
  inline void set_client_token(bool value);

  // optional bool session_token = 2 [default = false];
  inline bool has_session_token() const;
  inline void clear_session_token();
  static const int kSessionTokenFieldNumber = 2;
  inline bool session_token() const;
  inline void set_session_token(bool value);

  // optional bool video_resolution_constraints = 3 [default = false];
  inline bool has_video_resolution_constraints() const;
  inline void clear_video_resolution_constraints();
  static const int kVideoResolutionConstraintsFieldNumber = 3;
  inline bool video_resolution_constraints() const;
  inline void set_video_resolution_constraints(bool value);

  // optional .video_widevine_server.sdk.ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];
  inline bool has_max_hdcp_version() const;
  inline void clear_max_hdcp_version();
  static const int kMaxHdcpVersionFieldNumber = 4;
  inline ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities_HdcpVersion max_hdcp_version() const;
  inline void set_max_hdcp_version(::video_widevine_server::sdk::ClientIdentification_ClientCapabilities_HdcpVersion value);

  // optional uint32 oem_crypto_api_version = 5;
  inline bool has_oem_crypto_api_version() const;
  inline void clear_oem_crypto_api_version();
  static const int kOemCryptoApiVersionFieldNumber = 5;
  inline ::google::protobuf::uint32 oem_crypto_api_version() const;
  inline void set_oem_crypto_api_version(::google::protobuf::uint32 value);

  // optional bool anti_rollback_usage_table = 6 [default = false];
  inline bool has_anti_rollback_usage_table() const;
  inline void clear_anti_rollback_usage_table();
  static const int kAntiRollbackUsageTableFieldNumber = 6;
  inline bool anti_rollback_usage_table() const;
  inline void set_anti_rollback_usage_table(bool value);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.ClientIdentification.ClientCapabilities)
 private:
  inline void set_has_client_token();
  inline void clear_has_client_token();
  inline void set_has_session_token();
  inline void clear_has_session_token();
  inline void set_has_video_resolution_constraints();
  inline void clear_has_video_resolution_constraints();
  inline void set_has_max_hdcp_version();
  inline void clear_has_max_hdcp_version();
  inline void set_has_oem_crypto_api_version();
  inline void clear_has_oem_crypto_api_version();
  inline void set_has_anti_rollback_usage_table();
  inline void clear_has_anti_rollback_usage_table();

  bool client_token_;
  bool session_token_;
  bool video_resolution_constraints_;
  bool anti_rollback_usage_table_;
  int max_hdcp_version_;
  ::google::protobuf::uint32 oem_crypto_api_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientIdentification_ClientCapabilities* default_instance_;
};
// -------------------------------------------------------------------

class ClientIdentification : public ::google::protobuf::MessageLite {
 public:
  ClientIdentification();
  virtual ~ClientIdentification();

  ClientIdentification(const ClientIdentification& from);

  inline ClientIdentification& operator=(const ClientIdentification& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientIdentification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientIdentification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientIdentification* other);

  // implements Message ----------------------------------------------

  ClientIdentification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientIdentification& from);
  void MergeFrom(const ClientIdentification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientIdentification_NameValue NameValue;
  typedef ClientIdentification_ClientCapabilities ClientCapabilities;

  typedef ClientIdentification_TokenType TokenType;
  static const TokenType KEYBOX = ClientIdentification_TokenType_KEYBOX;
  static const TokenType DEVICE_CERTIFICATE = ClientIdentification_TokenType_DEVICE_CERTIFICATE;
  static const TokenType REMOTE_ATTESTATION_CERTIFICATE = ClientIdentification_TokenType_REMOTE_ATTESTATION_CERTIFICATE;
  static inline bool TokenType_IsValid(int value) {
    return ClientIdentification_TokenType_IsValid(value);
  }
  static const TokenType TokenType_MIN =
    ClientIdentification_TokenType_TokenType_MIN;
  static const TokenType TokenType_MAX =
    ClientIdentification_TokenType_TokenType_MAX;
  static const int TokenType_ARRAYSIZE =
    ClientIdentification_TokenType_TokenType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.ClientIdentification.TokenType type = 1 [default = KEYBOX];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::video_widevine_server::sdk::ClientIdentification_TokenType type() const;
  inline void set_type(::video_widevine_server::sdk::ClientIdentification_TokenType value);

  // optional bytes token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // repeated .video_widevine_server.sdk.ClientIdentification.NameValue client_info = 3;
  inline int client_info_size() const;
  inline void clear_client_info();
  static const int kClientInfoFieldNumber = 3;
  inline const ::video_widevine_server::sdk::ClientIdentification_NameValue& client_info(int index) const;
  inline ::video_widevine_server::sdk::ClientIdentification_NameValue* mutable_client_info(int index);
  inline ::video_widevine_server::sdk::ClientIdentification_NameValue* add_client_info();
  inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::ClientIdentification_NameValue >&
      client_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::ClientIdentification_NameValue >*
      mutable_client_info();

  // optional bytes provider_client_token = 4;
  inline bool has_provider_client_token() const;
  inline void clear_provider_client_token();
  static const int kProviderClientTokenFieldNumber = 4;
  inline const ::std::string& provider_client_token() const;
  inline void set_provider_client_token(const ::std::string& value);
  inline void set_provider_client_token(const char* value);
  inline void set_provider_client_token(const void* value, size_t size);
  inline ::std::string* mutable_provider_client_token();
  inline ::std::string* release_provider_client_token();
  inline void set_allocated_provider_client_token(::std::string* provider_client_token);

  // optional uint32 license_counter = 5;
  inline bool has_license_counter() const;
  inline void clear_license_counter();
  static const int kLicenseCounterFieldNumber = 5;
  inline ::google::protobuf::uint32 license_counter() const;
  inline void set_license_counter(::google::protobuf::uint32 value);

  // optional .video_widevine_server.sdk.ClientIdentification.ClientCapabilities client_capabilities = 6;
  inline bool has_client_capabilities() const;
  inline void clear_client_capabilities();
  static const int kClientCapabilitiesFieldNumber = 6;
  inline const ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities& client_capabilities() const;
  inline ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities* mutable_client_capabilities();
  inline ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities* release_client_capabilities();
  inline void set_allocated_client_capabilities(::video_widevine_server::sdk::ClientIdentification_ClientCapabilities* client_capabilities);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.ClientIdentification)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_provider_client_token();
  inline void clear_has_provider_client_token();
  inline void set_has_license_counter();
  inline void clear_has_license_counter();
  inline void set_has_client_capabilities();
  inline void clear_has_client_capabilities();

  ::std::string* token_;
  ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::ClientIdentification_NameValue > client_info_;
  int type_;
  ::google::protobuf::uint32 license_counter_;
  ::std::string* provider_client_token_;
  ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities* client_capabilities_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientIdentification* default_instance_;
};
// -------------------------------------------------------------------

class EncryptedClientIdentification : public ::google::protobuf::MessageLite {
 public:
  EncryptedClientIdentification();
  virtual ~EncryptedClientIdentification();

  EncryptedClientIdentification(const EncryptedClientIdentification& from);

  inline EncryptedClientIdentification& operator=(const EncryptedClientIdentification& from) {
    CopyFrom(from);
    return *this;
  }

  static const EncryptedClientIdentification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EncryptedClientIdentification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EncryptedClientIdentification* other);

  // implements Message ----------------------------------------------

  EncryptedClientIdentification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EncryptedClientIdentification& from);
  void MergeFrom(const EncryptedClientIdentification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional bytes service_certificate_serial_number = 2;
  inline bool has_service_certificate_serial_number() const;
  inline void clear_service_certificate_serial_number();
  static const int kServiceCertificateSerialNumberFieldNumber = 2;
  inline const ::std::string& service_certificate_serial_number() const;
  inline void set_service_certificate_serial_number(const ::std::string& value);
  inline void set_service_certificate_serial_number(const char* value);
  inline void set_service_certificate_serial_number(const void* value, size_t size);
  inline ::std::string* mutable_service_certificate_serial_number();
  inline ::std::string* release_service_certificate_serial_number();
  inline void set_allocated_service_certificate_serial_number(::std::string* service_certificate_serial_number);

  // optional bytes encrypted_client_id = 3;
  inline bool has_encrypted_client_id() const;
  inline void clear_encrypted_client_id();
  static const int kEncryptedClientIdFieldNumber = 3;
  inline const ::std::string& encrypted_client_id() const;
  inline void set_encrypted_client_id(const ::std::string& value);
  inline void set_encrypted_client_id(const char* value);
  inline void set_encrypted_client_id(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_client_id();
  inline ::std::string* release_encrypted_client_id();
  inline void set_allocated_encrypted_client_id(::std::string* encrypted_client_id);

  // optional bytes encrypted_client_id_iv = 4;
  inline bool has_encrypted_client_id_iv() const;
  inline void clear_encrypted_client_id_iv();
  static const int kEncryptedClientIdIvFieldNumber = 4;
  inline const ::std::string& encrypted_client_id_iv() const;
  inline void set_encrypted_client_id_iv(const ::std::string& value);
  inline void set_encrypted_client_id_iv(const char* value);
  inline void set_encrypted_client_id_iv(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_client_id_iv();
  inline ::std::string* release_encrypted_client_id_iv();
  inline void set_allocated_encrypted_client_id_iv(::std::string* encrypted_client_id_iv);

  // optional bytes encrypted_privacy_key = 5;
  inline bool has_encrypted_privacy_key() const;
  inline void clear_encrypted_privacy_key();
  static const int kEncryptedPrivacyKeyFieldNumber = 5;
  inline const ::std::string& encrypted_privacy_key() const;
  inline void set_encrypted_privacy_key(const ::std::string& value);
  inline void set_encrypted_privacy_key(const char* value);
  inline void set_encrypted_privacy_key(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_privacy_key();
  inline ::std::string* release_encrypted_privacy_key();
  inline void set_allocated_encrypted_privacy_key(::std::string* encrypted_privacy_key);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.EncryptedClientIdentification)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_service_certificate_serial_number();
  inline void clear_has_service_certificate_serial_number();
  inline void set_has_encrypted_client_id();
  inline void clear_has_encrypted_client_id();
  inline void set_has_encrypted_client_id_iv();
  inline void clear_has_encrypted_client_id_iv();
  inline void set_has_encrypted_privacy_key();
  inline void clear_has_encrypted_privacy_key();

  ::std::string* service_id_;
  ::std::string* service_certificate_serial_number_;
  ::std::string* encrypted_client_id_;
  ::std::string* encrypted_client_id_iv_;
  ::std::string* encrypted_privacy_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static EncryptedClientIdentification* default_instance_;
};
// -------------------------------------------------------------------

class DeviceCertificate : public ::google::protobuf::MessageLite {
 public:
  DeviceCertificate();
  virtual ~DeviceCertificate();

  DeviceCertificate(const DeviceCertificate& from);

  inline DeviceCertificate& operator=(const DeviceCertificate& from) {
    CopyFrom(from);
    return *this;
  }

  static const DeviceCertificate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceCertificate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceCertificate* other);

  // implements Message ----------------------------------------------

  DeviceCertificate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceCertificate& from);
  void MergeFrom(const DeviceCertificate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DeviceCertificate_CertificateType CertificateType;
  static const CertificateType ROOT = DeviceCertificate_CertificateType_ROOT;
  static const CertificateType INTERMEDIATE = DeviceCertificate_CertificateType_INTERMEDIATE;
  static const CertificateType USER_DEVICE = DeviceCertificate_CertificateType_USER_DEVICE;
  static const CertificateType SERVICE = DeviceCertificate_CertificateType_SERVICE;
  static inline bool CertificateType_IsValid(int value) {
    return DeviceCertificate_CertificateType_IsValid(value);
  }
  static const CertificateType CertificateType_MIN =
    DeviceCertificate_CertificateType_CertificateType_MIN;
  static const CertificateType CertificateType_MAX =
    DeviceCertificate_CertificateType_CertificateType_MAX;
  static const int CertificateType_ARRAYSIZE =
    DeviceCertificate_CertificateType_CertificateType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.DeviceCertificate.CertificateType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::video_widevine_server::sdk::DeviceCertificate_CertificateType type() const;
  inline void set_type(::video_widevine_server::sdk::DeviceCertificate_CertificateType value);

  // optional bytes serial_number = 2;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  inline const ::std::string& serial_number() const;
  inline void set_serial_number(const ::std::string& value);
  inline void set_serial_number(const char* value);
  inline void set_serial_number(const void* value, size_t size);
  inline ::std::string* mutable_serial_number();
  inline ::std::string* release_serial_number();
  inline void set_allocated_serial_number(::std::string* serial_number);

  // optional uint32 creation_time_seconds = 3;
  inline bool has_creation_time_seconds() const;
  inline void clear_creation_time_seconds();
  static const int kCreationTimeSecondsFieldNumber = 3;
  inline ::google::protobuf::uint32 creation_time_seconds() const;
  inline void set_creation_time_seconds(::google::protobuf::uint32 value);

  // optional bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // optional uint32 system_id = 5;
  inline bool has_system_id() const;
  inline void clear_system_id();
  static const int kSystemIdFieldNumber = 5;
  inline ::google::protobuf::uint32 system_id() const;
  inline void set_system_id(::google::protobuf::uint32 value);

  // optional bool test_device_deprecated = 6 [deprecated = true];
  inline bool has_test_device_deprecated() const PROTOBUF_DEPRECATED;
  inline void clear_test_device_deprecated() PROTOBUF_DEPRECATED;
  static const int kTestDeviceDeprecatedFieldNumber = 6;
  inline bool test_device_deprecated() const PROTOBUF_DEPRECATED;
  inline void set_test_device_deprecated(bool value) PROTOBUF_DEPRECATED;

  // optional string service_id = 7;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 7;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.DeviceCertificate)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_creation_time_seconds();
  inline void clear_has_creation_time_seconds();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_system_id();
  inline void clear_has_system_id();
  inline void set_has_test_device_deprecated();
  inline void clear_has_test_device_deprecated();
  inline void set_has_service_id();
  inline void clear_has_service_id();

  ::std::string* serial_number_;
  int type_;
  ::google::protobuf::uint32 creation_time_seconds_;
  ::std::string* public_key_;
  ::google::protobuf::uint32 system_id_;
  bool test_device_deprecated_;
  ::std::string* service_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static DeviceCertificate* default_instance_;
};
// -------------------------------------------------------------------

class SignedDeviceCertificate : public ::google::protobuf::MessageLite {
 public:
  SignedDeviceCertificate();
  virtual ~SignedDeviceCertificate();

  SignedDeviceCertificate(const SignedDeviceCertificate& from);

  inline SignedDeviceCertificate& operator=(const SignedDeviceCertificate& from) {
    CopyFrom(from);
    return *this;
  }

  static const SignedDeviceCertificate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SignedDeviceCertificate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SignedDeviceCertificate* other);

  // implements Message ----------------------------------------------

  SignedDeviceCertificate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SignedDeviceCertificate& from);
  void MergeFrom(const SignedDeviceCertificate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes device_certificate = 1;
  inline bool has_device_certificate() const;
  inline void clear_device_certificate();
  static const int kDeviceCertificateFieldNumber = 1;
  inline const ::std::string& device_certificate() const;
  inline void set_device_certificate(const ::std::string& value);
  inline void set_device_certificate(const char* value);
  inline void set_device_certificate(const void* value, size_t size);
  inline ::std::string* mutable_device_certificate();
  inline ::std::string* release_device_certificate();
  inline void set_allocated_device_certificate(::std::string* device_certificate);

  // optional bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional .video_widevine_server.sdk.SignedDeviceCertificate signer = 3;
  inline bool has_signer() const;
  inline void clear_signer();
  static const int kSignerFieldNumber = 3;
  inline const ::video_widevine_server::sdk::SignedDeviceCertificate& signer() const;
  inline ::video_widevine_server::sdk::SignedDeviceCertificate* mutable_signer();
  inline ::video_widevine_server::sdk::SignedDeviceCertificate* release_signer();
  inline void set_allocated_signer(::video_widevine_server::sdk::SignedDeviceCertificate* signer);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.SignedDeviceCertificate)
 private:
  inline void set_has_device_certificate();
  inline void clear_has_device_certificate();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_signer();
  inline void clear_has_signer();

  ::std::string* device_certificate_;
  ::std::string* signature_;
  ::video_widevine_server::sdk::SignedDeviceCertificate* signer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static SignedDeviceCertificate* default_instance_;
};
// -------------------------------------------------------------------

class ProvisionedDeviceInfo : public ::google::protobuf::MessageLite {
 public:
  ProvisionedDeviceInfo();
  virtual ~ProvisionedDeviceInfo();

  ProvisionedDeviceInfo(const ProvisionedDeviceInfo& from);

  inline ProvisionedDeviceInfo& operator=(const ProvisionedDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ProvisionedDeviceInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ProvisionedDeviceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ProvisionedDeviceInfo* other);

  // implements Message ----------------------------------------------

  ProvisionedDeviceInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProvisionedDeviceInfo& from);
  void MergeFrom(const ProvisionedDeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ProvisionedDeviceInfo_WvSecurityLevel WvSecurityLevel;
  static const WvSecurityLevel LEVEL_UNSPECIFIED = ProvisionedDeviceInfo_WvSecurityLevel_LEVEL_UNSPECIFIED;
  static const WvSecurityLevel LEVEL_1 = ProvisionedDeviceInfo_WvSecurityLevel_LEVEL_1;
  static const WvSecurityLevel LEVEL_2 = ProvisionedDeviceInfo_WvSecurityLevel_LEVEL_2;
  static const WvSecurityLevel LEVEL_3 = ProvisionedDeviceInfo_WvSecurityLevel_LEVEL_3;
  static inline bool WvSecurityLevel_IsValid(int value) {
    return ProvisionedDeviceInfo_WvSecurityLevel_IsValid(value);
  }
  static const WvSecurityLevel WvSecurityLevel_MIN =
    ProvisionedDeviceInfo_WvSecurityLevel_WvSecurityLevel_MIN;
  static const WvSecurityLevel WvSecurityLevel_MAX =
    ProvisionedDeviceInfo_WvSecurityLevel_WvSecurityLevel_MAX;
  static const int WvSecurityLevel_ARRAYSIZE =
    ProvisionedDeviceInfo_WvSecurityLevel_WvSecurityLevel_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 system_id = 1;
  inline bool has_system_id() const;
  inline void clear_system_id();
  static const int kSystemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 system_id() const;
  inline void set_system_id(::google::protobuf::uint32 value);

  // optional string soc = 2;
  inline bool has_soc() const;
  inline void clear_soc();
  static const int kSocFieldNumber = 2;
  inline const ::std::string& soc() const;
  inline void set_soc(const ::std::string& value);
  inline void set_soc(const char* value);
  inline void set_soc(const char* value, size_t size);
  inline ::std::string* mutable_soc();
  inline ::std::string* release_soc();
  inline void set_allocated_soc(::std::string* soc);

  // optional string manufacturer = 3;
  inline bool has_manufacturer() const;
  inline void clear_manufacturer();
  static const int kManufacturerFieldNumber = 3;
  inline const ::std::string& manufacturer() const;
  inline void set_manufacturer(const ::std::string& value);
  inline void set_manufacturer(const char* value);
  inline void set_manufacturer(const char* value, size_t size);
  inline ::std::string* mutable_manufacturer();
  inline ::std::string* release_manufacturer();
  inline void set_allocated_manufacturer(::std::string* manufacturer);

  // optional string model = 4;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 4;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // optional string device_type = 5;
  inline bool has_device_type() const;
  inline void clear_device_type();
  static const int kDeviceTypeFieldNumber = 5;
  inline const ::std::string& device_type() const;
  inline void set_device_type(const ::std::string& value);
  inline void set_device_type(const char* value);
  inline void set_device_type(const char* value, size_t size);
  inline ::std::string* mutable_device_type();
  inline ::std::string* release_device_type();
  inline void set_allocated_device_type(::std::string* device_type);

  // optional uint32 model_year = 6;
  inline bool has_model_year() const;
  inline void clear_model_year();
  static const int kModelYearFieldNumber = 6;
  inline ::google::protobuf::uint32 model_year() const;
  inline void set_model_year(::google::protobuf::uint32 value);

  // optional .video_widevine_server.sdk.ProvisionedDeviceInfo.WvSecurityLevel security_level = 7 [default = LEVEL_UNSPECIFIED];
  inline bool has_security_level() const;
  inline void clear_security_level();
  static const int kSecurityLevelFieldNumber = 7;
  inline ::video_widevine_server::sdk::ProvisionedDeviceInfo_WvSecurityLevel security_level() const;
  inline void set_security_level(::video_widevine_server::sdk::ProvisionedDeviceInfo_WvSecurityLevel value);

  // optional bool test_device = 8 [default = false];
  inline bool has_test_device() const;
  inline void clear_test_device();
  static const int kTestDeviceFieldNumber = 8;
  inline bool test_device() const;
  inline void set_test_device(bool value);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.ProvisionedDeviceInfo)
 private:
  inline void set_has_system_id();
  inline void clear_has_system_id();
  inline void set_has_soc();
  inline void clear_has_soc();
  inline void set_has_manufacturer();
  inline void clear_has_manufacturer();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_device_type();
  inline void clear_has_device_type();
  inline void set_has_model_year();
  inline void clear_has_model_year();
  inline void set_has_security_level();
  inline void clear_has_security_level();
  inline void set_has_test_device();
  inline void clear_has_test_device();

  ::std::string* soc_;
  ::std::string* manufacturer_;
  ::google::protobuf::uint32 system_id_;
  ::google::protobuf::uint32 model_year_;
  ::std::string* model_;
  ::std::string* device_type_;
  int security_level_;
  bool test_device_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ProvisionedDeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class DeviceCertificateStatus : public ::google::protobuf::MessageLite {
 public:
  DeviceCertificateStatus();
  virtual ~DeviceCertificateStatus();

  DeviceCertificateStatus(const DeviceCertificateStatus& from);

  inline DeviceCertificateStatus& operator=(const DeviceCertificateStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const DeviceCertificateStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceCertificateStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceCertificateStatus* other);

  // implements Message ----------------------------------------------

  DeviceCertificateStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceCertificateStatus& from);
  void MergeFrom(const DeviceCertificateStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DeviceCertificateStatus_CertificateStatus CertificateStatus;
  static const CertificateStatus VALID = DeviceCertificateStatus_CertificateStatus_VALID;
  static const CertificateStatus REVOKED = DeviceCertificateStatus_CertificateStatus_REVOKED;
  static inline bool CertificateStatus_IsValid(int value) {
    return DeviceCertificateStatus_CertificateStatus_IsValid(value);
  }
  static const CertificateStatus CertificateStatus_MIN =
    DeviceCertificateStatus_CertificateStatus_CertificateStatus_MIN;
  static const CertificateStatus CertificateStatus_MAX =
    DeviceCertificateStatus_CertificateStatus_CertificateStatus_MAX;
  static const int CertificateStatus_ARRAYSIZE =
    DeviceCertificateStatus_CertificateStatus_CertificateStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bytes serial_number = 1;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  inline const ::std::string& serial_number() const;
  inline void set_serial_number(const ::std::string& value);
  inline void set_serial_number(const char* value);
  inline void set_serial_number(const void* value, size_t size);
  inline ::std::string* mutable_serial_number();
  inline ::std::string* release_serial_number();
  inline void set_allocated_serial_number(::std::string* serial_number);

  // optional .video_widevine_server.sdk.DeviceCertificateStatus.CertificateStatus status = 2 [default = VALID];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::video_widevine_server::sdk::DeviceCertificateStatus_CertificateStatus status() const;
  inline void set_status(::video_widevine_server::sdk::DeviceCertificateStatus_CertificateStatus value);

  // optional .video_widevine_server.sdk.ProvisionedDeviceInfo device_info = 4;
  inline bool has_device_info() const;
  inline void clear_device_info();
  static const int kDeviceInfoFieldNumber = 4;
  inline const ::video_widevine_server::sdk::ProvisionedDeviceInfo& device_info() const;
  inline ::video_widevine_server::sdk::ProvisionedDeviceInfo* mutable_device_info();
  inline ::video_widevine_server::sdk::ProvisionedDeviceInfo* release_device_info();
  inline void set_allocated_device_info(::video_widevine_server::sdk::ProvisionedDeviceInfo* device_info);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.DeviceCertificateStatus)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_device_info();
  inline void clear_has_device_info();

  ::std::string* serial_number_;
  ::video_widevine_server::sdk::ProvisionedDeviceInfo* device_info_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static DeviceCertificateStatus* default_instance_;
};
// -------------------------------------------------------------------

class DeviceCertificateStatusList : public ::google::protobuf::MessageLite {
 public:
  DeviceCertificateStatusList();
  virtual ~DeviceCertificateStatusList();

  DeviceCertificateStatusList(const DeviceCertificateStatusList& from);

  inline DeviceCertificateStatusList& operator=(const DeviceCertificateStatusList& from) {
    CopyFrom(from);
    return *this;
  }

  static const DeviceCertificateStatusList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceCertificateStatusList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceCertificateStatusList* other);

  // implements Message ----------------------------------------------

  DeviceCertificateStatusList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceCertificateStatusList& from);
  void MergeFrom(const DeviceCertificateStatusList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 creation_time_seconds = 1;
  inline bool has_creation_time_seconds() const;
  inline void clear_creation_time_seconds();
  static const int kCreationTimeSecondsFieldNumber = 1;
  inline ::google::protobuf::uint32 creation_time_seconds() const;
  inline void set_creation_time_seconds(::google::protobuf::uint32 value);

  // repeated .video_widevine_server.sdk.DeviceCertificateStatus certificate_status = 2;
  inline int certificate_status_size() const;
  inline void clear_certificate_status();
  static const int kCertificateStatusFieldNumber = 2;
  inline const ::video_widevine_server::sdk::DeviceCertificateStatus& certificate_status(int index) const;
  inline ::video_widevine_server::sdk::DeviceCertificateStatus* mutable_certificate_status(int index);
  inline ::video_widevine_server::sdk::DeviceCertificateStatus* add_certificate_status();
  inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::DeviceCertificateStatus >&
      certificate_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::DeviceCertificateStatus >*
      mutable_certificate_status();

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.DeviceCertificateStatusList)
 private:
  inline void set_has_creation_time_seconds();
  inline void clear_has_creation_time_seconds();

  ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::DeviceCertificateStatus > certificate_status_;
  ::google::protobuf::uint32 creation_time_seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static DeviceCertificateStatusList* default_instance_;
};
// -------------------------------------------------------------------

class SignedCertificateStatusList : public ::google::protobuf::MessageLite {
 public:
  SignedCertificateStatusList();
  virtual ~SignedCertificateStatusList();

  SignedCertificateStatusList(const SignedCertificateStatusList& from);

  inline SignedCertificateStatusList& operator=(const SignedCertificateStatusList& from) {
    CopyFrom(from);
    return *this;
  }

  static const SignedCertificateStatusList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SignedCertificateStatusList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SignedCertificateStatusList* other);

  // implements Message ----------------------------------------------

  SignedCertificateStatusList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SignedCertificateStatusList& from);
  void MergeFrom(const SignedCertificateStatusList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes certificate_status_list = 1;
  inline bool has_certificate_status_list() const;
  inline void clear_certificate_status_list();
  static const int kCertificateStatusListFieldNumber = 1;
  inline const ::std::string& certificate_status_list() const;
  inline void set_certificate_status_list(const ::std::string& value);
  inline void set_certificate_status_list(const char* value);
  inline void set_certificate_status_list(const void* value, size_t size);
  inline ::std::string* mutable_certificate_status_list();
  inline ::std::string* release_certificate_status_list();
  inline void set_allocated_certificate_status_list(::std::string* certificate_status_list);

  // optional bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.SignedCertificateStatusList)
 private:
  inline void set_has_certificate_status_list();
  inline void clear_has_certificate_status_list();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::std::string* certificate_status_list_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static SignedCertificateStatusList* default_instance_;
};
// -------------------------------------------------------------------

class WidevineCencHeader : public ::google::protobuf::MessageLite {
 public:
  WidevineCencHeader();
  virtual ~WidevineCencHeader();

  WidevineCencHeader(const WidevineCencHeader& from);

  inline WidevineCencHeader& operator=(const WidevineCencHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const WidevineCencHeader& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WidevineCencHeader* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WidevineCencHeader* other);

  // implements Message ----------------------------------------------

  WidevineCencHeader* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WidevineCencHeader& from);
  void MergeFrom(const WidevineCencHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef WidevineCencHeader_Algorithm Algorithm;
  static const Algorithm UNENCRYPTED = WidevineCencHeader_Algorithm_UNENCRYPTED;
  static const Algorithm AESCTR = WidevineCencHeader_Algorithm_AESCTR;
  static inline bool Algorithm_IsValid(int value) {
    return WidevineCencHeader_Algorithm_IsValid(value);
  }
  static const Algorithm Algorithm_MIN =
    WidevineCencHeader_Algorithm_Algorithm_MIN;
  static const Algorithm Algorithm_MAX =
    WidevineCencHeader_Algorithm_Algorithm_MAX;
  static const int Algorithm_ARRAYSIZE =
    WidevineCencHeader_Algorithm_Algorithm_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .video_widevine_server.sdk.WidevineCencHeader.Algorithm algorithm = 1 [deprecated = true];
  inline bool has_algorithm() const PROTOBUF_DEPRECATED;
  inline void clear_algorithm() PROTOBUF_DEPRECATED;
  static const int kAlgorithmFieldNumber = 1;
  inline ::video_widevine_server::sdk::WidevineCencHeader_Algorithm algorithm() const PROTOBUF_DEPRECATED;
  inline void set_algorithm(::video_widevine_server::sdk::WidevineCencHeader_Algorithm value) PROTOBUF_DEPRECATED;

  // repeated bytes key_id = 2;
  inline int key_id_size() const;
  inline void clear_key_id();
  static const int kKeyIdFieldNumber = 2;
  inline const ::std::string& key_id(int index) const;
  inline ::std::string* mutable_key_id(int index);
  inline void set_key_id(int index, const ::std::string& value);
  inline void set_key_id(int index, const char* value);
  inline void set_key_id(int index, const void* value, size_t size);
  inline ::std::string* add_key_id();
  inline void add_key_id(const ::std::string& value);
  inline void add_key_id(const char* value);
  inline void add_key_id(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& key_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key_id();

  // optional string provider = 3;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 3;
  inline const ::std::string& provider() const;
  inline void set_provider(const ::std::string& value);
  inline void set_provider(const char* value);
  inline void set_provider(const char* value, size_t size);
  inline ::std::string* mutable_provider();
  inline ::std::string* release_provider();
  inline void set_allocated_provider(::std::string* provider);

  // optional bytes content_id = 4;
  inline bool has_content_id() const;
  inline void clear_content_id();
  static const int kContentIdFieldNumber = 4;
  inline const ::std::string& content_id() const;
  inline void set_content_id(const ::std::string& value);
  inline void set_content_id(const char* value);
  inline void set_content_id(const void* value, size_t size);
  inline ::std::string* mutable_content_id();
  inline ::std::string* release_content_id();
  inline void set_allocated_content_id(::std::string* content_id);

  // optional string track_type_deprecated = 5;
  inline bool has_track_type_deprecated() const;
  inline void clear_track_type_deprecated();
  static const int kTrackTypeDeprecatedFieldNumber = 5;
  inline const ::std::string& track_type_deprecated() const;
  inline void set_track_type_deprecated(const ::std::string& value);
  inline void set_track_type_deprecated(const char* value);
  inline void set_track_type_deprecated(const char* value, size_t size);
  inline ::std::string* mutable_track_type_deprecated();
  inline ::std::string* release_track_type_deprecated();
  inline void set_allocated_track_type_deprecated(::std::string* track_type_deprecated);

  // optional string policy = 6 [deprecated = true];
  inline bool has_policy() const PROTOBUF_DEPRECATED;
  inline void clear_policy() PROTOBUF_DEPRECATED;
  static const int kPolicyFieldNumber = 6;
  inline const ::std::string& policy() const PROTOBUF_DEPRECATED;
  inline void set_policy(const ::std::string& value) PROTOBUF_DEPRECATED;
  inline void set_policy(const char* value) PROTOBUF_DEPRECATED;
  inline void set_policy(const char* value, size_t size) PROTOBUF_DEPRECATED;
  inline ::std::string* mutable_policy() PROTOBUF_DEPRECATED;
  inline ::std::string* release_policy() PROTOBUF_DEPRECATED;
  inline void set_allocated_policy(::std::string* policy) PROTOBUF_DEPRECATED;

  // optional uint32 crypto_period_index = 7;
  inline bool has_crypto_period_index() const;
  inline void clear_crypto_period_index();
  static const int kCryptoPeriodIndexFieldNumber = 7;
  inline ::google::protobuf::uint32 crypto_period_index() const;
  inline void set_crypto_period_index(::google::protobuf::uint32 value);

  // optional bytes grouped_license = 8;
  inline bool has_grouped_license() const;
  inline void clear_grouped_license();
  static const int kGroupedLicenseFieldNumber = 8;
  inline const ::std::string& grouped_license() const;
  inline void set_grouped_license(const ::std::string& value);
  inline void set_grouped_license(const char* value);
  inline void set_grouped_license(const void* value, size_t size);
  inline ::std::string* mutable_grouped_license();
  inline ::std::string* release_grouped_license();
  inline void set_allocated_grouped_license(::std::string* grouped_license);

  // optional uint32 protection_scheme = 9;
  inline bool has_protection_scheme() const;
  inline void clear_protection_scheme();
  static const int kProtectionSchemeFieldNumber = 9;
  inline ::google::protobuf::uint32 protection_scheme() const;
  inline void set_protection_scheme(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:video_widevine_server.sdk.WidevineCencHeader)
 private:
  inline void set_has_algorithm();
  inline void clear_has_algorithm();
  inline void set_has_provider();
  inline void clear_has_provider();
  inline void set_has_content_id();
  inline void clear_has_content_id();
  inline void set_has_track_type_deprecated();
  inline void clear_has_track_type_deprecated();
  inline void set_has_policy();
  inline void clear_has_policy();
  inline void set_has_crypto_period_index();
  inline void clear_has_crypto_period_index();
  inline void set_has_grouped_license();
  inline void clear_has_grouped_license();
  inline void set_has_protection_scheme();
  inline void clear_has_protection_scheme();

  ::google::protobuf::RepeatedPtrField< ::std::string> key_id_;
  ::std::string* provider_;
  ::std::string* content_id_;
  int algorithm_;
  ::google::protobuf::uint32 crypto_period_index_;
  ::std::string* track_type_deprecated_;
  ::std::string* policy_;
  ::std::string* grouped_license_;
  ::google::protobuf::uint32 protection_scheme_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_license_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_license_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_license_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static WidevineCencHeader* default_instance_;
};
// ===================================================================


// ===================================================================

// LicenseIdentification

// optional bytes request_id = 1;
inline bool LicenseIdentification::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LicenseIdentification::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LicenseIdentification::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LicenseIdentification::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& LicenseIdentification::request_id() const {
  return *request_id_;
}
inline void LicenseIdentification::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void LicenseIdentification::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void LicenseIdentification::set_request_id(const void* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LicenseIdentification::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* LicenseIdentification::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LicenseIdentification::set_allocated_request_id(::std::string* request_id) {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    delete request_id_;
  }
  if (request_id) {
    set_has_request_id();
    request_id_ = request_id;
  } else {
    clear_has_request_id();
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes session_id = 2;
inline bool LicenseIdentification::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LicenseIdentification::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LicenseIdentification::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LicenseIdentification::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& LicenseIdentification::session_id() const {
  return *session_id_;
}
inline void LicenseIdentification::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LicenseIdentification::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LicenseIdentification::set_session_id(const void* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LicenseIdentification::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* LicenseIdentification::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LicenseIdentification::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes purchase_id = 3;
inline bool LicenseIdentification::has_purchase_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LicenseIdentification::set_has_purchase_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LicenseIdentification::clear_has_purchase_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LicenseIdentification::clear_purchase_id() {
  if (purchase_id_ != &::google::protobuf::internal::kEmptyString) {
    purchase_id_->clear();
  }
  clear_has_purchase_id();
}
inline const ::std::string& LicenseIdentification::purchase_id() const {
  return *purchase_id_;
}
inline void LicenseIdentification::set_purchase_id(const ::std::string& value) {
  set_has_purchase_id();
  if (purchase_id_ == &::google::protobuf::internal::kEmptyString) {
    purchase_id_ = new ::std::string;
  }
  purchase_id_->assign(value);
}
inline void LicenseIdentification::set_purchase_id(const char* value) {
  set_has_purchase_id();
  if (purchase_id_ == &::google::protobuf::internal::kEmptyString) {
    purchase_id_ = new ::std::string;
  }
  purchase_id_->assign(value);
}
inline void LicenseIdentification::set_purchase_id(const void* value, size_t size) {
  set_has_purchase_id();
  if (purchase_id_ == &::google::protobuf::internal::kEmptyString) {
    purchase_id_ = new ::std::string;
  }
  purchase_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LicenseIdentification::mutable_purchase_id() {
  set_has_purchase_id();
  if (purchase_id_ == &::google::protobuf::internal::kEmptyString) {
    purchase_id_ = new ::std::string;
  }
  return purchase_id_;
}
inline ::std::string* LicenseIdentification::release_purchase_id() {
  clear_has_purchase_id();
  if (purchase_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = purchase_id_;
    purchase_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LicenseIdentification::set_allocated_purchase_id(::std::string* purchase_id) {
  if (purchase_id_ != &::google::protobuf::internal::kEmptyString) {
    delete purchase_id_;
  }
  if (purchase_id) {
    set_has_purchase_id();
    purchase_id_ = purchase_id;
  } else {
    clear_has_purchase_id();
    purchase_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .video_widevine_server.sdk.LicenseType type = 4;
inline bool LicenseIdentification::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LicenseIdentification::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LicenseIdentification::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LicenseIdentification::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::video_widevine_server::sdk::LicenseType LicenseIdentification::type() const {
  return static_cast< ::video_widevine_server::sdk::LicenseType >(type_);
}
inline void LicenseIdentification::set_type(::video_widevine_server::sdk::LicenseType value) {
  assert(::video_widevine_server::sdk::LicenseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 version = 5;
inline bool LicenseIdentification::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LicenseIdentification::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LicenseIdentification::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LicenseIdentification::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 LicenseIdentification::version() const {
  return version_;
}
inline void LicenseIdentification::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional bytes provider_session_token = 6;
inline bool LicenseIdentification::has_provider_session_token() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LicenseIdentification::set_has_provider_session_token() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LicenseIdentification::clear_has_provider_session_token() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LicenseIdentification::clear_provider_session_token() {
  if (provider_session_token_ != &::google::protobuf::internal::kEmptyString) {
    provider_session_token_->clear();
  }
  clear_has_provider_session_token();
}
inline const ::std::string& LicenseIdentification::provider_session_token() const {
  return *provider_session_token_;
}
inline void LicenseIdentification::set_provider_session_token(const ::std::string& value) {
  set_has_provider_session_token();
  if (provider_session_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_session_token_ = new ::std::string;
  }
  provider_session_token_->assign(value);
}
inline void LicenseIdentification::set_provider_session_token(const char* value) {
  set_has_provider_session_token();
  if (provider_session_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_session_token_ = new ::std::string;
  }
  provider_session_token_->assign(value);
}
inline void LicenseIdentification::set_provider_session_token(const void* value, size_t size) {
  set_has_provider_session_token();
  if (provider_session_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_session_token_ = new ::std::string;
  }
  provider_session_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LicenseIdentification::mutable_provider_session_token() {
  set_has_provider_session_token();
  if (provider_session_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_session_token_ = new ::std::string;
  }
  return provider_session_token_;
}
inline ::std::string* LicenseIdentification::release_provider_session_token() {
  clear_has_provider_session_token();
  if (provider_session_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_session_token_;
    provider_session_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LicenseIdentification::set_allocated_provider_session_token(::std::string* provider_session_token) {
  if (provider_session_token_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_session_token_;
  }
  if (provider_session_token) {
    set_has_provider_session_token();
    provider_session_token_ = provider_session_token;
  } else {
    clear_has_provider_session_token();
    provider_session_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// License_Policy

// optional bool can_play = 1 [default = false];
inline bool License_Policy::has_can_play() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void License_Policy::set_has_can_play() {
  _has_bits_[0] |= 0x00000001u;
}
inline void License_Policy::clear_has_can_play() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void License_Policy::clear_can_play() {
  can_play_ = false;
  clear_has_can_play();
}
inline bool License_Policy::can_play() const {
  return can_play_;
}
inline void License_Policy::set_can_play(bool value) {
  set_has_can_play();
  can_play_ = value;
}

// optional bool can_persist = 2 [default = false];
inline bool License_Policy::has_can_persist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void License_Policy::set_has_can_persist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void License_Policy::clear_has_can_persist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void License_Policy::clear_can_persist() {
  can_persist_ = false;
  clear_has_can_persist();
}
inline bool License_Policy::can_persist() const {
  return can_persist_;
}
inline void License_Policy::set_can_persist(bool value) {
  set_has_can_persist();
  can_persist_ = value;
}

// optional bool can_renew = 3 [default = false];
inline bool License_Policy::has_can_renew() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void License_Policy::set_has_can_renew() {
  _has_bits_[0] |= 0x00000004u;
}
inline void License_Policy::clear_has_can_renew() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void License_Policy::clear_can_renew() {
  can_renew_ = false;
  clear_has_can_renew();
}
inline bool License_Policy::can_renew() const {
  return can_renew_;
}
inline void License_Policy::set_can_renew(bool value) {
  set_has_can_renew();
  can_renew_ = value;
}

// optional int64 rental_duration_seconds = 4 [default = 0];
inline bool License_Policy::has_rental_duration_seconds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void License_Policy::set_has_rental_duration_seconds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void License_Policy::clear_has_rental_duration_seconds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void License_Policy::clear_rental_duration_seconds() {
  rental_duration_seconds_ = GOOGLE_LONGLONG(0);
  clear_has_rental_duration_seconds();
}
inline ::google::protobuf::int64 License_Policy::rental_duration_seconds() const {
  return rental_duration_seconds_;
}
inline void License_Policy::set_rental_duration_seconds(::google::protobuf::int64 value) {
  set_has_rental_duration_seconds();
  rental_duration_seconds_ = value;
}

// optional int64 playback_duration_seconds = 5 [default = 0];
inline bool License_Policy::has_playback_duration_seconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void License_Policy::set_has_playback_duration_seconds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void License_Policy::clear_has_playback_duration_seconds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void License_Policy::clear_playback_duration_seconds() {
  playback_duration_seconds_ = GOOGLE_LONGLONG(0);
  clear_has_playback_duration_seconds();
}
inline ::google::protobuf::int64 License_Policy::playback_duration_seconds() const {
  return playback_duration_seconds_;
}
inline void License_Policy::set_playback_duration_seconds(::google::protobuf::int64 value) {
  set_has_playback_duration_seconds();
  playback_duration_seconds_ = value;
}

// optional int64 license_duration_seconds = 6 [default = 0];
inline bool License_Policy::has_license_duration_seconds() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void License_Policy::set_has_license_duration_seconds() {
  _has_bits_[0] |= 0x00000020u;
}
inline void License_Policy::clear_has_license_duration_seconds() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void License_Policy::clear_license_duration_seconds() {
  license_duration_seconds_ = GOOGLE_LONGLONG(0);
  clear_has_license_duration_seconds();
}
inline ::google::protobuf::int64 License_Policy::license_duration_seconds() const {
  return license_duration_seconds_;
}
inline void License_Policy::set_license_duration_seconds(::google::protobuf::int64 value) {
  set_has_license_duration_seconds();
  license_duration_seconds_ = value;
}

// optional int64 renewal_recovery_duration_seconds = 7 [default = 0];
inline bool License_Policy::has_renewal_recovery_duration_seconds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void License_Policy::set_has_renewal_recovery_duration_seconds() {
  _has_bits_[0] |= 0x00000040u;
}
inline void License_Policy::clear_has_renewal_recovery_duration_seconds() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void License_Policy::clear_renewal_recovery_duration_seconds() {
  renewal_recovery_duration_seconds_ = GOOGLE_LONGLONG(0);
  clear_has_renewal_recovery_duration_seconds();
}
inline ::google::protobuf::int64 License_Policy::renewal_recovery_duration_seconds() const {
  return renewal_recovery_duration_seconds_;
}
inline void License_Policy::set_renewal_recovery_duration_seconds(::google::protobuf::int64 value) {
  set_has_renewal_recovery_duration_seconds();
  renewal_recovery_duration_seconds_ = value;
}

// optional string renewal_server_url = 8;
inline bool License_Policy::has_renewal_server_url() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void License_Policy::set_has_renewal_server_url() {
  _has_bits_[0] |= 0x00000080u;
}
inline void License_Policy::clear_has_renewal_server_url() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void License_Policy::clear_renewal_server_url() {
  if (renewal_server_url_ != &::google::protobuf::internal::kEmptyString) {
    renewal_server_url_->clear();
  }
  clear_has_renewal_server_url();
}
inline const ::std::string& License_Policy::renewal_server_url() const {
  return *renewal_server_url_;
}
inline void License_Policy::set_renewal_server_url(const ::std::string& value) {
  set_has_renewal_server_url();
  if (renewal_server_url_ == &::google::protobuf::internal::kEmptyString) {
    renewal_server_url_ = new ::std::string;
  }
  renewal_server_url_->assign(value);
}
inline void License_Policy::set_renewal_server_url(const char* value) {
  set_has_renewal_server_url();
  if (renewal_server_url_ == &::google::protobuf::internal::kEmptyString) {
    renewal_server_url_ = new ::std::string;
  }
  renewal_server_url_->assign(value);
}
inline void License_Policy::set_renewal_server_url(const char* value, size_t size) {
  set_has_renewal_server_url();
  if (renewal_server_url_ == &::google::protobuf::internal::kEmptyString) {
    renewal_server_url_ = new ::std::string;
  }
  renewal_server_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License_Policy::mutable_renewal_server_url() {
  set_has_renewal_server_url();
  if (renewal_server_url_ == &::google::protobuf::internal::kEmptyString) {
    renewal_server_url_ = new ::std::string;
  }
  return renewal_server_url_;
}
inline ::std::string* License_Policy::release_renewal_server_url() {
  clear_has_renewal_server_url();
  if (renewal_server_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = renewal_server_url_;
    renewal_server_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License_Policy::set_allocated_renewal_server_url(::std::string* renewal_server_url) {
  if (renewal_server_url_ != &::google::protobuf::internal::kEmptyString) {
    delete renewal_server_url_;
  }
  if (renewal_server_url) {
    set_has_renewal_server_url();
    renewal_server_url_ = renewal_server_url;
  } else {
    clear_has_renewal_server_url();
    renewal_server_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 renewal_delay_seconds = 9 [default = 0];
inline bool License_Policy::has_renewal_delay_seconds() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void License_Policy::set_has_renewal_delay_seconds() {
  _has_bits_[0] |= 0x00000100u;
}
inline void License_Policy::clear_has_renewal_delay_seconds() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void License_Policy::clear_renewal_delay_seconds() {
  renewal_delay_seconds_ = GOOGLE_LONGLONG(0);
  clear_has_renewal_delay_seconds();
}
inline ::google::protobuf::int64 License_Policy::renewal_delay_seconds() const {
  return renewal_delay_seconds_;
}
inline void License_Policy::set_renewal_delay_seconds(::google::protobuf::int64 value) {
  set_has_renewal_delay_seconds();
  renewal_delay_seconds_ = value;
}

// optional int64 renewal_retry_interval_seconds = 10 [default = 0];
inline bool License_Policy::has_renewal_retry_interval_seconds() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void License_Policy::set_has_renewal_retry_interval_seconds() {
  _has_bits_[0] |= 0x00000200u;
}
inline void License_Policy::clear_has_renewal_retry_interval_seconds() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void License_Policy::clear_renewal_retry_interval_seconds() {
  renewal_retry_interval_seconds_ = GOOGLE_LONGLONG(0);
  clear_has_renewal_retry_interval_seconds();
}
inline ::google::protobuf::int64 License_Policy::renewal_retry_interval_seconds() const {
  return renewal_retry_interval_seconds_;
}
inline void License_Policy::set_renewal_retry_interval_seconds(::google::protobuf::int64 value) {
  set_has_renewal_retry_interval_seconds();
  renewal_retry_interval_seconds_ = value;
}

// optional bool renew_with_usage = 11 [default = false];
inline bool License_Policy::has_renew_with_usage() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void License_Policy::set_has_renew_with_usage() {
  _has_bits_[0] |= 0x00000400u;
}
inline void License_Policy::clear_has_renew_with_usage() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void License_Policy::clear_renew_with_usage() {
  renew_with_usage_ = false;
  clear_has_renew_with_usage();
}
inline bool License_Policy::renew_with_usage() const {
  return renew_with_usage_;
}
inline void License_Policy::set_renew_with_usage(bool value) {
  set_has_renew_with_usage();
  renew_with_usage_ = value;
}

// optional bool renew_with_client_id = 12 [default = false];
inline bool License_Policy::has_renew_with_client_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void License_Policy::set_has_renew_with_client_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void License_Policy::clear_has_renew_with_client_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void License_Policy::clear_renew_with_client_id() {
  renew_with_client_id_ = false;
  clear_has_renew_with_client_id();
}
inline bool License_Policy::renew_with_client_id() const {
  return renew_with_client_id_;
}
inline void License_Policy::set_renew_with_client_id(bool value) {
  set_has_renew_with_client_id();
  renew_with_client_id_ = value;
}

// -------------------------------------------------------------------

// License_KeyContainer_KeyControl

// optional bytes key_control_block = 1;
inline bool License_KeyContainer_KeyControl::has_key_control_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void License_KeyContainer_KeyControl::set_has_key_control_block() {
  _has_bits_[0] |= 0x00000001u;
}
inline void License_KeyContainer_KeyControl::clear_has_key_control_block() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void License_KeyContainer_KeyControl::clear_key_control_block() {
  if (key_control_block_ != &::google::protobuf::internal::kEmptyString) {
    key_control_block_->clear();
  }
  clear_has_key_control_block();
}
inline const ::std::string& License_KeyContainer_KeyControl::key_control_block() const {
  return *key_control_block_;
}
inline void License_KeyContainer_KeyControl::set_key_control_block(const ::std::string& value) {
  set_has_key_control_block();
  if (key_control_block_ == &::google::protobuf::internal::kEmptyString) {
    key_control_block_ = new ::std::string;
  }
  key_control_block_->assign(value);
}
inline void License_KeyContainer_KeyControl::set_key_control_block(const char* value) {
  set_has_key_control_block();
  if (key_control_block_ == &::google::protobuf::internal::kEmptyString) {
    key_control_block_ = new ::std::string;
  }
  key_control_block_->assign(value);
}
inline void License_KeyContainer_KeyControl::set_key_control_block(const void* value, size_t size) {
  set_has_key_control_block();
  if (key_control_block_ == &::google::protobuf::internal::kEmptyString) {
    key_control_block_ = new ::std::string;
  }
  key_control_block_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License_KeyContainer_KeyControl::mutable_key_control_block() {
  set_has_key_control_block();
  if (key_control_block_ == &::google::protobuf::internal::kEmptyString) {
    key_control_block_ = new ::std::string;
  }
  return key_control_block_;
}
inline ::std::string* License_KeyContainer_KeyControl::release_key_control_block() {
  clear_has_key_control_block();
  if (key_control_block_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_control_block_;
    key_control_block_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License_KeyContainer_KeyControl::set_allocated_key_control_block(::std::string* key_control_block) {
  if (key_control_block_ != &::google::protobuf::internal::kEmptyString) {
    delete key_control_block_;
  }
  if (key_control_block) {
    set_has_key_control_block();
    key_control_block_ = key_control_block;
  } else {
    clear_has_key_control_block();
    key_control_block_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes iv = 2;
inline bool License_KeyContainer_KeyControl::has_iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void License_KeyContainer_KeyControl::set_has_iv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void License_KeyContainer_KeyControl::clear_has_iv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void License_KeyContainer_KeyControl::clear_iv() {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    iv_->clear();
  }
  clear_has_iv();
}
inline const ::std::string& License_KeyContainer_KeyControl::iv() const {
  return *iv_;
}
inline void License_KeyContainer_KeyControl::set_iv(const ::std::string& value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void License_KeyContainer_KeyControl::set_iv(const char* value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void License_KeyContainer_KeyControl::set_iv(const void* value, size_t size) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License_KeyContainer_KeyControl::mutable_iv() {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  return iv_;
}
inline ::std::string* License_KeyContainer_KeyControl::release_iv() {
  clear_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iv_;
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License_KeyContainer_KeyControl::set_allocated_iv(::std::string* iv) {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (iv) {
    set_has_iv();
    iv_ = iv;
  } else {
    clear_has_iv();
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// License_KeyContainer_OutputProtection

// optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];
inline bool License_KeyContainer_OutputProtection::has_hdcp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void License_KeyContainer_OutputProtection::set_has_hdcp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void License_KeyContainer_OutputProtection::clear_has_hdcp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void License_KeyContainer_OutputProtection::clear_hdcp() {
  hdcp_ = 0;
  clear_has_hdcp();
}
inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection_HDCP License_KeyContainer_OutputProtection::hdcp() const {
  return static_cast< ::video_widevine_server::sdk::License_KeyContainer_OutputProtection_HDCP >(hdcp_);
}
inline void License_KeyContainer_OutputProtection::set_hdcp(::video_widevine_server::sdk::License_KeyContainer_OutputProtection_HDCP value) {
  assert(::video_widevine_server::sdk::License_KeyContainer_OutputProtection_HDCP_IsValid(value));
  set_has_hdcp();
  hdcp_ = value;
}

// optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];
inline bool License_KeyContainer_OutputProtection::has_cgms_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void License_KeyContainer_OutputProtection::set_has_cgms_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void License_KeyContainer_OutputProtection::clear_has_cgms_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void License_KeyContainer_OutputProtection::clear_cgms_flags() {
  cgms_flags_ = 42;
  clear_has_cgms_flags();
}
inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection_CGMS License_KeyContainer_OutputProtection::cgms_flags() const {
  return static_cast< ::video_widevine_server::sdk::License_KeyContainer_OutputProtection_CGMS >(cgms_flags_);
}
inline void License_KeyContainer_OutputProtection::set_cgms_flags(::video_widevine_server::sdk::License_KeyContainer_OutputProtection_CGMS value) {
  assert(::video_widevine_server::sdk::License_KeyContainer_OutputProtection_CGMS_IsValid(value));
  set_has_cgms_flags();
  cgms_flags_ = value;
}

// -------------------------------------------------------------------

// License_KeyContainer_VideoResolutionConstraint

// optional uint32 min_resolution_pixels = 1;
inline bool License_KeyContainer_VideoResolutionConstraint::has_min_resolution_pixels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void License_KeyContainer_VideoResolutionConstraint::set_has_min_resolution_pixels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void License_KeyContainer_VideoResolutionConstraint::clear_has_min_resolution_pixels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void License_KeyContainer_VideoResolutionConstraint::clear_min_resolution_pixels() {
  min_resolution_pixels_ = 0u;
  clear_has_min_resolution_pixels();
}
inline ::google::protobuf::uint32 License_KeyContainer_VideoResolutionConstraint::min_resolution_pixels() const {
  return min_resolution_pixels_;
}
inline void License_KeyContainer_VideoResolutionConstraint::set_min_resolution_pixels(::google::protobuf::uint32 value) {
  set_has_min_resolution_pixels();
  min_resolution_pixels_ = value;
}

// optional uint32 max_resolution_pixels = 2;
inline bool License_KeyContainer_VideoResolutionConstraint::has_max_resolution_pixels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void License_KeyContainer_VideoResolutionConstraint::set_has_max_resolution_pixels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void License_KeyContainer_VideoResolutionConstraint::clear_has_max_resolution_pixels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void License_KeyContainer_VideoResolutionConstraint::clear_max_resolution_pixels() {
  max_resolution_pixels_ = 0u;
  clear_has_max_resolution_pixels();
}
inline ::google::protobuf::uint32 License_KeyContainer_VideoResolutionConstraint::max_resolution_pixels() const {
  return max_resolution_pixels_;
}
inline void License_KeyContainer_VideoResolutionConstraint::set_max_resolution_pixels(::google::protobuf::uint32 value) {
  set_has_max_resolution_pixels();
  max_resolution_pixels_ = value;
}

// optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection required_protection = 3;
inline bool License_KeyContainer_VideoResolutionConstraint::has_required_protection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void License_KeyContainer_VideoResolutionConstraint::set_has_required_protection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void License_KeyContainer_VideoResolutionConstraint::clear_has_required_protection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void License_KeyContainer_VideoResolutionConstraint::clear_required_protection() {
  if (required_protection_ != NULL) required_protection_->::video_widevine_server::sdk::License_KeyContainer_OutputProtection::Clear();
  clear_has_required_protection();
}
inline const ::video_widevine_server::sdk::License_KeyContainer_OutputProtection& License_KeyContainer_VideoResolutionConstraint::required_protection() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return required_protection_ != NULL ? *required_protection_ : *default_instance().required_protection_;
#else
  return required_protection_ != NULL ? *required_protection_ : *default_instance_->required_protection_;
#endif
}
inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* License_KeyContainer_VideoResolutionConstraint::mutable_required_protection() {
  set_has_required_protection();
  if (required_protection_ == NULL) required_protection_ = new ::video_widevine_server::sdk::License_KeyContainer_OutputProtection;
  return required_protection_;
}
inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* License_KeyContainer_VideoResolutionConstraint::release_required_protection() {
  clear_has_required_protection();
  ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* temp = required_protection_;
  required_protection_ = NULL;
  return temp;
}
inline void License_KeyContainer_VideoResolutionConstraint::set_allocated_required_protection(::video_widevine_server::sdk::License_KeyContainer_OutputProtection* required_protection) {
  delete required_protection_;
  required_protection_ = required_protection;
  if (required_protection) {
    set_has_required_protection();
  } else {
    clear_has_required_protection();
  }
}

// -------------------------------------------------------------------

// License_KeyContainer_OperatorSessionKeyPermissions

// optional bool allow_encrypt = 1 [default = false];
inline bool License_KeyContainer_OperatorSessionKeyPermissions::has_allow_encrypt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::set_has_allow_encrypt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::clear_has_allow_encrypt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::clear_allow_encrypt() {
  allow_encrypt_ = false;
  clear_has_allow_encrypt();
}
inline bool License_KeyContainer_OperatorSessionKeyPermissions::allow_encrypt() const {
  return allow_encrypt_;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::set_allow_encrypt(bool value) {
  set_has_allow_encrypt();
  allow_encrypt_ = value;
}

// optional bool allow_decrypt = 2 [default = false];
inline bool License_KeyContainer_OperatorSessionKeyPermissions::has_allow_decrypt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::set_has_allow_decrypt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::clear_has_allow_decrypt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::clear_allow_decrypt() {
  allow_decrypt_ = false;
  clear_has_allow_decrypt();
}
inline bool License_KeyContainer_OperatorSessionKeyPermissions::allow_decrypt() const {
  return allow_decrypt_;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::set_allow_decrypt(bool value) {
  set_has_allow_decrypt();
  allow_decrypt_ = value;
}

// optional bool allow_sign = 3 [default = false];
inline bool License_KeyContainer_OperatorSessionKeyPermissions::has_allow_sign() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::set_has_allow_sign() {
  _has_bits_[0] |= 0x00000004u;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::clear_has_allow_sign() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::clear_allow_sign() {
  allow_sign_ = false;
  clear_has_allow_sign();
}
inline bool License_KeyContainer_OperatorSessionKeyPermissions::allow_sign() const {
  return allow_sign_;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::set_allow_sign(bool value) {
  set_has_allow_sign();
  allow_sign_ = value;
}

// optional bool allow_signature_verify = 4 [default = false];
inline bool License_KeyContainer_OperatorSessionKeyPermissions::has_allow_signature_verify() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::set_has_allow_signature_verify() {
  _has_bits_[0] |= 0x00000008u;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::clear_has_allow_signature_verify() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::clear_allow_signature_verify() {
  allow_signature_verify_ = false;
  clear_has_allow_signature_verify();
}
inline bool License_KeyContainer_OperatorSessionKeyPermissions::allow_signature_verify() const {
  return allow_signature_verify_;
}
inline void License_KeyContainer_OperatorSessionKeyPermissions::set_allow_signature_verify(bool value) {
  set_has_allow_signature_verify();
  allow_signature_verify_ = value;
}

// -------------------------------------------------------------------

// License_KeyContainer

// optional bytes id = 1;
inline bool License_KeyContainer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void License_KeyContainer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void License_KeyContainer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void License_KeyContainer::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& License_KeyContainer::id() const {
  return *id_;
}
inline void License_KeyContainer::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void License_KeyContainer::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void License_KeyContainer::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License_KeyContainer::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* License_KeyContainer::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License_KeyContainer::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes iv = 2;
inline bool License_KeyContainer::has_iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void License_KeyContainer::set_has_iv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void License_KeyContainer::clear_has_iv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void License_KeyContainer::clear_iv() {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    iv_->clear();
  }
  clear_has_iv();
}
inline const ::std::string& License_KeyContainer::iv() const {
  return *iv_;
}
inline void License_KeyContainer::set_iv(const ::std::string& value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void License_KeyContainer::set_iv(const char* value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void License_KeyContainer::set_iv(const void* value, size_t size) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License_KeyContainer::mutable_iv() {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  return iv_;
}
inline ::std::string* License_KeyContainer::release_iv() {
  clear_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iv_;
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License_KeyContainer::set_allocated_iv(::std::string* iv) {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (iv) {
    set_has_iv();
    iv_ = iv;
  } else {
    clear_has_iv();
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes key = 3;
inline bool License_KeyContainer::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void License_KeyContainer::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void License_KeyContainer::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void License_KeyContainer::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& License_KeyContainer::key() const {
  return *key_;
}
inline void License_KeyContainer::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void License_KeyContainer::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void License_KeyContainer::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License_KeyContainer::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* License_KeyContainer::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License_KeyContainer::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .video_widevine_server.sdk.License.KeyContainer.KeyType type = 4;
inline bool License_KeyContainer::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void License_KeyContainer::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void License_KeyContainer::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void License_KeyContainer::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::video_widevine_server::sdk::License_KeyContainer_KeyType License_KeyContainer::type() const {
  return static_cast< ::video_widevine_server::sdk::License_KeyContainer_KeyType >(type_);
}
inline void License_KeyContainer::set_type(::video_widevine_server::sdk::License_KeyContainer_KeyType value) {
  assert(::video_widevine_server::sdk::License_KeyContainer_KeyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .video_widevine_server.sdk.License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];
inline bool License_KeyContainer::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void License_KeyContainer::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void License_KeyContainer::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void License_KeyContainer::clear_level() {
  level_ = 1;
  clear_has_level();
}
inline ::video_widevine_server::sdk::License_KeyContainer_SecurityLevel License_KeyContainer::level() const {
  return static_cast< ::video_widevine_server::sdk::License_KeyContainer_SecurityLevel >(level_);
}
inline void License_KeyContainer::set_level(::video_widevine_server::sdk::License_KeyContainer_SecurityLevel value) {
  assert(::video_widevine_server::sdk::License_KeyContainer_SecurityLevel_IsValid(value));
  set_has_level();
  level_ = value;
}

// optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection required_protection = 6;
inline bool License_KeyContainer::has_required_protection() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void License_KeyContainer::set_has_required_protection() {
  _has_bits_[0] |= 0x00000020u;
}
inline void License_KeyContainer::clear_has_required_protection() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void License_KeyContainer::clear_required_protection() {
  if (required_protection_ != NULL) required_protection_->::video_widevine_server::sdk::License_KeyContainer_OutputProtection::Clear();
  clear_has_required_protection();
}
inline const ::video_widevine_server::sdk::License_KeyContainer_OutputProtection& License_KeyContainer::required_protection() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return required_protection_ != NULL ? *required_protection_ : *default_instance().required_protection_;
#else
  return required_protection_ != NULL ? *required_protection_ : *default_instance_->required_protection_;
#endif
}
inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* License_KeyContainer::mutable_required_protection() {
  set_has_required_protection();
  if (required_protection_ == NULL) required_protection_ = new ::video_widevine_server::sdk::License_KeyContainer_OutputProtection;
  return required_protection_;
}
inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* License_KeyContainer::release_required_protection() {
  clear_has_required_protection();
  ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* temp = required_protection_;
  required_protection_ = NULL;
  return temp;
}
inline void License_KeyContainer::set_allocated_required_protection(::video_widevine_server::sdk::License_KeyContainer_OutputProtection* required_protection) {
  delete required_protection_;
  required_protection_ = required_protection;
  if (required_protection) {
    set_has_required_protection();
  } else {
    clear_has_required_protection();
  }
}

// optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection requested_protection = 7;
inline bool License_KeyContainer::has_requested_protection() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void License_KeyContainer::set_has_requested_protection() {
  _has_bits_[0] |= 0x00000040u;
}
inline void License_KeyContainer::clear_has_requested_protection() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void License_KeyContainer::clear_requested_protection() {
  if (requested_protection_ != NULL) requested_protection_->::video_widevine_server::sdk::License_KeyContainer_OutputProtection::Clear();
  clear_has_requested_protection();
}
inline const ::video_widevine_server::sdk::License_KeyContainer_OutputProtection& License_KeyContainer::requested_protection() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return requested_protection_ != NULL ? *requested_protection_ : *default_instance().requested_protection_;
#else
  return requested_protection_ != NULL ? *requested_protection_ : *default_instance_->requested_protection_;
#endif
}
inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* License_KeyContainer::mutable_requested_protection() {
  set_has_requested_protection();
  if (requested_protection_ == NULL) requested_protection_ = new ::video_widevine_server::sdk::License_KeyContainer_OutputProtection;
  return requested_protection_;
}
inline ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* License_KeyContainer::release_requested_protection() {
  clear_has_requested_protection();
  ::video_widevine_server::sdk::License_KeyContainer_OutputProtection* temp = requested_protection_;
  requested_protection_ = NULL;
  return temp;
}
inline void License_KeyContainer::set_allocated_requested_protection(::video_widevine_server::sdk::License_KeyContainer_OutputProtection* requested_protection) {
  delete requested_protection_;
  requested_protection_ = requested_protection;
  if (requested_protection) {
    set_has_requested_protection();
  } else {
    clear_has_requested_protection();
  }
}

// optional .video_widevine_server.sdk.License.KeyContainer.KeyControl key_control = 8;
inline bool License_KeyContainer::has_key_control() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void License_KeyContainer::set_has_key_control() {
  _has_bits_[0] |= 0x00000080u;
}
inline void License_KeyContainer::clear_has_key_control() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void License_KeyContainer::clear_key_control() {
  if (key_control_ != NULL) key_control_->::video_widevine_server::sdk::License_KeyContainer_KeyControl::Clear();
  clear_has_key_control();
}
inline const ::video_widevine_server::sdk::License_KeyContainer_KeyControl& License_KeyContainer::key_control() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return key_control_ != NULL ? *key_control_ : *default_instance().key_control_;
#else
  return key_control_ != NULL ? *key_control_ : *default_instance_->key_control_;
#endif
}
inline ::video_widevine_server::sdk::License_KeyContainer_KeyControl* License_KeyContainer::mutable_key_control() {
  set_has_key_control();
  if (key_control_ == NULL) key_control_ = new ::video_widevine_server::sdk::License_KeyContainer_KeyControl;
  return key_control_;
}
inline ::video_widevine_server::sdk::License_KeyContainer_KeyControl* License_KeyContainer::release_key_control() {
  clear_has_key_control();
  ::video_widevine_server::sdk::License_KeyContainer_KeyControl* temp = key_control_;
  key_control_ = NULL;
  return temp;
}
inline void License_KeyContainer::set_allocated_key_control(::video_widevine_server::sdk::License_KeyContainer_KeyControl* key_control) {
  delete key_control_;
  key_control_ = key_control;
  if (key_control) {
    set_has_key_control();
  } else {
    clear_has_key_control();
  }
}

// optional .video_widevine_server.sdk.License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;
inline bool License_KeyContainer::has_operator_session_key_permissions() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void License_KeyContainer::set_has_operator_session_key_permissions() {
  _has_bits_[0] |= 0x00000100u;
}
inline void License_KeyContainer::clear_has_operator_session_key_permissions() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void License_KeyContainer::clear_operator_session_key_permissions() {
  if (operator_session_key_permissions_ != NULL) operator_session_key_permissions_->::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions::Clear();
  clear_has_operator_session_key_permissions();
}
inline const ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions& License_KeyContainer::operator_session_key_permissions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return operator_session_key_permissions_ != NULL ? *operator_session_key_permissions_ : *default_instance().operator_session_key_permissions_;
#else
  return operator_session_key_permissions_ != NULL ? *operator_session_key_permissions_ : *default_instance_->operator_session_key_permissions_;
#endif
}
inline ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions* License_KeyContainer::mutable_operator_session_key_permissions() {
  set_has_operator_session_key_permissions();
  if (operator_session_key_permissions_ == NULL) operator_session_key_permissions_ = new ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions;
  return operator_session_key_permissions_;
}
inline ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions* License_KeyContainer::release_operator_session_key_permissions() {
  clear_has_operator_session_key_permissions();
  ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions* temp = operator_session_key_permissions_;
  operator_session_key_permissions_ = NULL;
  return temp;
}
inline void License_KeyContainer::set_allocated_operator_session_key_permissions(::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions* operator_session_key_permissions) {
  delete operator_session_key_permissions_;
  operator_session_key_permissions_ = operator_session_key_permissions;
  if (operator_session_key_permissions) {
    set_has_operator_session_key_permissions();
  } else {
    clear_has_operator_session_key_permissions();
  }
}

// repeated .video_widevine_server.sdk.License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;
inline int License_KeyContainer::video_resolution_constraints_size() const {
  return video_resolution_constraints_.size();
}
inline void License_KeyContainer::clear_video_resolution_constraints() {
  video_resolution_constraints_.Clear();
}
inline const ::video_widevine_server::sdk::License_KeyContainer_VideoResolutionConstraint& License_KeyContainer::video_resolution_constraints(int index) const {
  return video_resolution_constraints_.Get(index);
}
inline ::video_widevine_server::sdk::License_KeyContainer_VideoResolutionConstraint* License_KeyContainer::mutable_video_resolution_constraints(int index) {
  return video_resolution_constraints_.Mutable(index);
}
inline ::video_widevine_server::sdk::License_KeyContainer_VideoResolutionConstraint* License_KeyContainer::add_video_resolution_constraints() {
  return video_resolution_constraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer_VideoResolutionConstraint >&
License_KeyContainer::video_resolution_constraints() const {
  return video_resolution_constraints_;
}
inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer_VideoResolutionConstraint >*
License_KeyContainer::mutable_video_resolution_constraints() {
  return &video_resolution_constraints_;
}

// optional bool anti_rollback_usage_table = 11 [default = false];
inline bool License_KeyContainer::has_anti_rollback_usage_table() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void License_KeyContainer::set_has_anti_rollback_usage_table() {
  _has_bits_[0] |= 0x00000400u;
}
inline void License_KeyContainer::clear_has_anti_rollback_usage_table() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void License_KeyContainer::clear_anti_rollback_usage_table() {
  anti_rollback_usage_table_ = false;
  clear_has_anti_rollback_usage_table();
}
inline bool License_KeyContainer::anti_rollback_usage_table() const {
  return anti_rollback_usage_table_;
}
inline void License_KeyContainer::set_anti_rollback_usage_table(bool value) {
  set_has_anti_rollback_usage_table();
  anti_rollback_usage_table_ = value;
}

// -------------------------------------------------------------------

// License

// optional .video_widevine_server.sdk.LicenseIdentification id = 1;
inline bool License::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void License::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void License::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void License::clear_id() {
  if (id_ != NULL) id_->::video_widevine_server::sdk::LicenseIdentification::Clear();
  clear_has_id();
}
inline const ::video_widevine_server::sdk::LicenseIdentification& License::id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::video_widevine_server::sdk::LicenseIdentification* License::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::video_widevine_server::sdk::LicenseIdentification;
  return id_;
}
inline ::video_widevine_server::sdk::LicenseIdentification* License::release_id() {
  clear_has_id();
  ::video_widevine_server::sdk::LicenseIdentification* temp = id_;
  id_ = NULL;
  return temp;
}
inline void License::set_allocated_id(::video_widevine_server::sdk::LicenseIdentification* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional .video_widevine_server.sdk.License.Policy policy = 2;
inline bool License::has_policy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void License::set_has_policy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void License::clear_has_policy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void License::clear_policy() {
  if (policy_ != NULL) policy_->::video_widevine_server::sdk::License_Policy::Clear();
  clear_has_policy();
}
inline const ::video_widevine_server::sdk::License_Policy& License::policy() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return policy_ != NULL ? *policy_ : *default_instance().policy_;
#else
  return policy_ != NULL ? *policy_ : *default_instance_->policy_;
#endif
}
inline ::video_widevine_server::sdk::License_Policy* License::mutable_policy() {
  set_has_policy();
  if (policy_ == NULL) policy_ = new ::video_widevine_server::sdk::License_Policy;
  return policy_;
}
inline ::video_widevine_server::sdk::License_Policy* License::release_policy() {
  clear_has_policy();
  ::video_widevine_server::sdk::License_Policy* temp = policy_;
  policy_ = NULL;
  return temp;
}
inline void License::set_allocated_policy(::video_widevine_server::sdk::License_Policy* policy) {
  delete policy_;
  policy_ = policy;
  if (policy) {
    set_has_policy();
  } else {
    clear_has_policy();
  }
}

// repeated .video_widevine_server.sdk.License.KeyContainer key = 3;
inline int License::key_size() const {
  return key_.size();
}
inline void License::clear_key() {
  key_.Clear();
}
inline const ::video_widevine_server::sdk::License_KeyContainer& License::key(int index) const {
  return key_.Get(index);
}
inline ::video_widevine_server::sdk::License_KeyContainer* License::mutable_key(int index) {
  return key_.Mutable(index);
}
inline ::video_widevine_server::sdk::License_KeyContainer* License::add_key() {
  return key_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer >&
License::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer >*
License::mutable_key() {
  return &key_;
}

// optional int64 license_start_time = 4;
inline bool License::has_license_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void License::set_has_license_start_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void License::clear_has_license_start_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void License::clear_license_start_time() {
  license_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_license_start_time();
}
inline ::google::protobuf::int64 License::license_start_time() const {
  return license_start_time_;
}
inline void License::set_license_start_time(::google::protobuf::int64 value) {
  set_has_license_start_time();
  license_start_time_ = value;
}

// optional bool remote_attestation_verified = 5 [default = false];
inline bool License::has_remote_attestation_verified() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void License::set_has_remote_attestation_verified() {
  _has_bits_[0] |= 0x00000010u;
}
inline void License::clear_has_remote_attestation_verified() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void License::clear_remote_attestation_verified() {
  remote_attestation_verified_ = false;
  clear_has_remote_attestation_verified();
}
inline bool License::remote_attestation_verified() const {
  return remote_attestation_verified_;
}
inline void License::set_remote_attestation_verified(bool value) {
  set_has_remote_attestation_verified();
  remote_attestation_verified_ = value;
}

// optional bytes provider_client_token = 6;
inline bool License::has_provider_client_token() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void License::set_has_provider_client_token() {
  _has_bits_[0] |= 0x00000020u;
}
inline void License::clear_has_provider_client_token() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void License::clear_provider_client_token() {
  if (provider_client_token_ != &::google::protobuf::internal::kEmptyString) {
    provider_client_token_->clear();
  }
  clear_has_provider_client_token();
}
inline const ::std::string& License::provider_client_token() const {
  return *provider_client_token_;
}
inline void License::set_provider_client_token(const ::std::string& value) {
  set_has_provider_client_token();
  if (provider_client_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_client_token_ = new ::std::string;
  }
  provider_client_token_->assign(value);
}
inline void License::set_provider_client_token(const char* value) {
  set_has_provider_client_token();
  if (provider_client_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_client_token_ = new ::std::string;
  }
  provider_client_token_->assign(value);
}
inline void License::set_provider_client_token(const void* value, size_t size) {
  set_has_provider_client_token();
  if (provider_client_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_client_token_ = new ::std::string;
  }
  provider_client_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License::mutable_provider_client_token() {
  set_has_provider_client_token();
  if (provider_client_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_client_token_ = new ::std::string;
  }
  return provider_client_token_;
}
inline ::std::string* License::release_provider_client_token() {
  clear_has_provider_client_token();
  if (provider_client_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_client_token_;
    provider_client_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License::set_allocated_provider_client_token(::std::string* provider_client_token) {
  if (provider_client_token_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_client_token_;
  }
  if (provider_client_token) {
    set_has_provider_client_token();
    provider_client_token_ = provider_client_token;
  } else {
    clear_has_provider_client_token();
    provider_client_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 protection_scheme = 7;
inline bool License::has_protection_scheme() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void License::set_has_protection_scheme() {
  _has_bits_[0] |= 0x00000040u;
}
inline void License::clear_has_protection_scheme() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void License::clear_protection_scheme() {
  protection_scheme_ = 0u;
  clear_has_protection_scheme();
}
inline ::google::protobuf::uint32 License::protection_scheme() const {
  return protection_scheme_;
}
inline void License::set_protection_scheme(::google::protobuf::uint32 value) {
  set_has_protection_scheme();
  protection_scheme_ = value;
}

// -------------------------------------------------------------------

// LicenseRequest_ContentIdentification_CENC

// repeated bytes pssh = 1;
inline int LicenseRequest_ContentIdentification_CENC::pssh_size() const {
  return pssh_.size();
}
inline void LicenseRequest_ContentIdentification_CENC::clear_pssh() {
  pssh_.Clear();
}
inline const ::std::string& LicenseRequest_ContentIdentification_CENC::pssh(int index) const {
  return pssh_.Get(index);
}
inline ::std::string* LicenseRequest_ContentIdentification_CENC::mutable_pssh(int index) {
  return pssh_.Mutable(index);
}
inline void LicenseRequest_ContentIdentification_CENC::set_pssh(int index, const ::std::string& value) {
  pssh_.Mutable(index)->assign(value);
}
inline void LicenseRequest_ContentIdentification_CENC::set_pssh(int index, const char* value) {
  pssh_.Mutable(index)->assign(value);
}
inline void LicenseRequest_ContentIdentification_CENC::set_pssh(int index, const void* value, size_t size) {
  pssh_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LicenseRequest_ContentIdentification_CENC::add_pssh() {
  return pssh_.Add();
}
inline void LicenseRequest_ContentIdentification_CENC::add_pssh(const ::std::string& value) {
  pssh_.Add()->assign(value);
}
inline void LicenseRequest_ContentIdentification_CENC::add_pssh(const char* value) {
  pssh_.Add()->assign(value);
}
inline void LicenseRequest_ContentIdentification_CENC::add_pssh(const void* value, size_t size) {
  pssh_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LicenseRequest_ContentIdentification_CENC::pssh() const {
  return pssh_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LicenseRequest_ContentIdentification_CENC::mutable_pssh() {
  return &pssh_;
}

// optional .video_widevine_server.sdk.LicenseType license_type = 2;
inline bool LicenseRequest_ContentIdentification_CENC::has_license_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LicenseRequest_ContentIdentification_CENC::set_has_license_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LicenseRequest_ContentIdentification_CENC::clear_has_license_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LicenseRequest_ContentIdentification_CENC::clear_license_type() {
  license_type_ = 1;
  clear_has_license_type();
}
inline ::video_widevine_server::sdk::LicenseType LicenseRequest_ContentIdentification_CENC::license_type() const {
  return static_cast< ::video_widevine_server::sdk::LicenseType >(license_type_);
}
inline void LicenseRequest_ContentIdentification_CENC::set_license_type(::video_widevine_server::sdk::LicenseType value) {
  assert(::video_widevine_server::sdk::LicenseType_IsValid(value));
  set_has_license_type();
  license_type_ = value;
}

// optional bytes request_id = 3;
inline bool LicenseRequest_ContentIdentification_CENC::has_request_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LicenseRequest_ContentIdentification_CENC::set_has_request_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LicenseRequest_ContentIdentification_CENC::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LicenseRequest_ContentIdentification_CENC::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& LicenseRequest_ContentIdentification_CENC::request_id() const {
  return *request_id_;
}
inline void LicenseRequest_ContentIdentification_CENC::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void LicenseRequest_ContentIdentification_CENC::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void LicenseRequest_ContentIdentification_CENC::set_request_id(const void* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LicenseRequest_ContentIdentification_CENC::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* LicenseRequest_ContentIdentification_CENC::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LicenseRequest_ContentIdentification_CENC::set_allocated_request_id(::std::string* request_id) {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    delete request_id_;
  }
  if (request_id) {
    set_has_request_id();
    request_id_ = request_id;
  } else {
    clear_has_request_id();
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LicenseRequest_ContentIdentification_WebM

// optional bytes header = 1;
inline bool LicenseRequest_ContentIdentification_WebM::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LicenseRequest_ContentIdentification_WebM::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LicenseRequest_ContentIdentification_WebM::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LicenseRequest_ContentIdentification_WebM::clear_header() {
  if (header_ != &::google::protobuf::internal::kEmptyString) {
    header_->clear();
  }
  clear_has_header();
}
inline const ::std::string& LicenseRequest_ContentIdentification_WebM::header() const {
  return *header_;
}
inline void LicenseRequest_ContentIdentification_WebM::set_header(const ::std::string& value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(value);
}
inline void LicenseRequest_ContentIdentification_WebM::set_header(const char* value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(value);
}
inline void LicenseRequest_ContentIdentification_WebM::set_header(const void* value, size_t size) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LicenseRequest_ContentIdentification_WebM::mutable_header() {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  return header_;
}
inline ::std::string* LicenseRequest_ContentIdentification_WebM::release_header() {
  clear_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = header_;
    header_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LicenseRequest_ContentIdentification_WebM::set_allocated_header(::std::string* header) {
  if (header_ != &::google::protobuf::internal::kEmptyString) {
    delete header_;
  }
  if (header) {
    set_has_header();
    header_ = header;
  } else {
    clear_has_header();
    header_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .video_widevine_server.sdk.LicenseType license_type = 2;
inline bool LicenseRequest_ContentIdentification_WebM::has_license_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LicenseRequest_ContentIdentification_WebM::set_has_license_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LicenseRequest_ContentIdentification_WebM::clear_has_license_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LicenseRequest_ContentIdentification_WebM::clear_license_type() {
  license_type_ = 1;
  clear_has_license_type();
}
inline ::video_widevine_server::sdk::LicenseType LicenseRequest_ContentIdentification_WebM::license_type() const {
  return static_cast< ::video_widevine_server::sdk::LicenseType >(license_type_);
}
inline void LicenseRequest_ContentIdentification_WebM::set_license_type(::video_widevine_server::sdk::LicenseType value) {
  assert(::video_widevine_server::sdk::LicenseType_IsValid(value));
  set_has_license_type();
  license_type_ = value;
}

// optional bytes request_id = 3;
inline bool LicenseRequest_ContentIdentification_WebM::has_request_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LicenseRequest_ContentIdentification_WebM::set_has_request_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LicenseRequest_ContentIdentification_WebM::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LicenseRequest_ContentIdentification_WebM::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& LicenseRequest_ContentIdentification_WebM::request_id() const {
  return *request_id_;
}
inline void LicenseRequest_ContentIdentification_WebM::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void LicenseRequest_ContentIdentification_WebM::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void LicenseRequest_ContentIdentification_WebM::set_request_id(const void* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LicenseRequest_ContentIdentification_WebM::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* LicenseRequest_ContentIdentification_WebM::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LicenseRequest_ContentIdentification_WebM::set_allocated_request_id(::std::string* request_id) {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    delete request_id_;
  }
  if (request_id) {
    set_has_request_id();
    request_id_ = request_id;
  } else {
    clear_has_request_id();
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LicenseRequest_ContentIdentification_ExistingLicense

// optional .video_widevine_server.sdk.LicenseIdentification license_id = 1;
inline bool LicenseRequest_ContentIdentification_ExistingLicense::has_license_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::set_has_license_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::clear_has_license_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::clear_license_id() {
  if (license_id_ != NULL) license_id_->::video_widevine_server::sdk::LicenseIdentification::Clear();
  clear_has_license_id();
}
inline const ::video_widevine_server::sdk::LicenseIdentification& LicenseRequest_ContentIdentification_ExistingLicense::license_id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return license_id_ != NULL ? *license_id_ : *default_instance().license_id_;
#else
  return license_id_ != NULL ? *license_id_ : *default_instance_->license_id_;
#endif
}
inline ::video_widevine_server::sdk::LicenseIdentification* LicenseRequest_ContentIdentification_ExistingLicense::mutable_license_id() {
  set_has_license_id();
  if (license_id_ == NULL) license_id_ = new ::video_widevine_server::sdk::LicenseIdentification;
  return license_id_;
}
inline ::video_widevine_server::sdk::LicenseIdentification* LicenseRequest_ContentIdentification_ExistingLicense::release_license_id() {
  clear_has_license_id();
  ::video_widevine_server::sdk::LicenseIdentification* temp = license_id_;
  license_id_ = NULL;
  return temp;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::set_allocated_license_id(::video_widevine_server::sdk::LicenseIdentification* license_id) {
  delete license_id_;
  license_id_ = license_id;
  if (license_id) {
    set_has_license_id();
  } else {
    clear_has_license_id();
  }
}

// optional int64 seconds_since_started = 2;
inline bool LicenseRequest_ContentIdentification_ExistingLicense::has_seconds_since_started() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::set_has_seconds_since_started() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::clear_has_seconds_since_started() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::clear_seconds_since_started() {
  seconds_since_started_ = GOOGLE_LONGLONG(0);
  clear_has_seconds_since_started();
}
inline ::google::protobuf::int64 LicenseRequest_ContentIdentification_ExistingLicense::seconds_since_started() const {
  return seconds_since_started_;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::set_seconds_since_started(::google::protobuf::int64 value) {
  set_has_seconds_since_started();
  seconds_since_started_ = value;
}

// optional int64 seconds_since_last_played = 3;
inline bool LicenseRequest_ContentIdentification_ExistingLicense::has_seconds_since_last_played() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::set_has_seconds_since_last_played() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::clear_has_seconds_since_last_played() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::clear_seconds_since_last_played() {
  seconds_since_last_played_ = GOOGLE_LONGLONG(0);
  clear_has_seconds_since_last_played();
}
inline ::google::protobuf::int64 LicenseRequest_ContentIdentification_ExistingLicense::seconds_since_last_played() const {
  return seconds_since_last_played_;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::set_seconds_since_last_played(::google::protobuf::int64 value) {
  set_has_seconds_since_last_played();
  seconds_since_last_played_ = value;
}

// optional bytes session_usage_table_entry = 4;
inline bool LicenseRequest_ContentIdentification_ExistingLicense::has_session_usage_table_entry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::set_has_session_usage_table_entry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::clear_has_session_usage_table_entry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::clear_session_usage_table_entry() {
  if (session_usage_table_entry_ != &::google::protobuf::internal::kEmptyString) {
    session_usage_table_entry_->clear();
  }
  clear_has_session_usage_table_entry();
}
inline const ::std::string& LicenseRequest_ContentIdentification_ExistingLicense::session_usage_table_entry() const {
  return *session_usage_table_entry_;
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::set_session_usage_table_entry(const ::std::string& value) {
  set_has_session_usage_table_entry();
  if (session_usage_table_entry_ == &::google::protobuf::internal::kEmptyString) {
    session_usage_table_entry_ = new ::std::string;
  }
  session_usage_table_entry_->assign(value);
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::set_session_usage_table_entry(const char* value) {
  set_has_session_usage_table_entry();
  if (session_usage_table_entry_ == &::google::protobuf::internal::kEmptyString) {
    session_usage_table_entry_ = new ::std::string;
  }
  session_usage_table_entry_->assign(value);
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::set_session_usage_table_entry(const void* value, size_t size) {
  set_has_session_usage_table_entry();
  if (session_usage_table_entry_ == &::google::protobuf::internal::kEmptyString) {
    session_usage_table_entry_ = new ::std::string;
  }
  session_usage_table_entry_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LicenseRequest_ContentIdentification_ExistingLicense::mutable_session_usage_table_entry() {
  set_has_session_usage_table_entry();
  if (session_usage_table_entry_ == &::google::protobuf::internal::kEmptyString) {
    session_usage_table_entry_ = new ::std::string;
  }
  return session_usage_table_entry_;
}
inline ::std::string* LicenseRequest_ContentIdentification_ExistingLicense::release_session_usage_table_entry() {
  clear_has_session_usage_table_entry();
  if (session_usage_table_entry_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_usage_table_entry_;
    session_usage_table_entry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LicenseRequest_ContentIdentification_ExistingLicense::set_allocated_session_usage_table_entry(::std::string* session_usage_table_entry) {
  if (session_usage_table_entry_ != &::google::protobuf::internal::kEmptyString) {
    delete session_usage_table_entry_;
  }
  if (session_usage_table_entry) {
    set_has_session_usage_table_entry();
    session_usage_table_entry_ = session_usage_table_entry;
  } else {
    clear_has_session_usage_table_entry();
    session_usage_table_entry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LicenseRequest_ContentIdentification

// optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.CENC cenc_id = 1;
inline bool LicenseRequest_ContentIdentification::has_cenc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LicenseRequest_ContentIdentification::set_has_cenc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LicenseRequest_ContentIdentification::clear_has_cenc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LicenseRequest_ContentIdentification::clear_cenc_id() {
  if (cenc_id_ != NULL) cenc_id_->::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC::Clear();
  clear_has_cenc_id();
}
inline const ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC& LicenseRequest_ContentIdentification::cenc_id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cenc_id_ != NULL ? *cenc_id_ : *default_instance().cenc_id_;
#else
  return cenc_id_ != NULL ? *cenc_id_ : *default_instance_->cenc_id_;
#endif
}
inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC* LicenseRequest_ContentIdentification::mutable_cenc_id() {
  set_has_cenc_id();
  if (cenc_id_ == NULL) cenc_id_ = new ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC;
  return cenc_id_;
}
inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC* LicenseRequest_ContentIdentification::release_cenc_id() {
  clear_has_cenc_id();
  ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC* temp = cenc_id_;
  cenc_id_ = NULL;
  return temp;
}
inline void LicenseRequest_ContentIdentification::set_allocated_cenc_id(::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC* cenc_id) {
  delete cenc_id_;
  cenc_id_ = cenc_id;
  if (cenc_id) {
    set_has_cenc_id();
  } else {
    clear_has_cenc_id();
  }
}

// optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.WebM webm_id = 2;
inline bool LicenseRequest_ContentIdentification::has_webm_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LicenseRequest_ContentIdentification::set_has_webm_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LicenseRequest_ContentIdentification::clear_has_webm_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LicenseRequest_ContentIdentification::clear_webm_id() {
  if (webm_id_ != NULL) webm_id_->::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM::Clear();
  clear_has_webm_id();
}
inline const ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM& LicenseRequest_ContentIdentification::webm_id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return webm_id_ != NULL ? *webm_id_ : *default_instance().webm_id_;
#else
  return webm_id_ != NULL ? *webm_id_ : *default_instance_->webm_id_;
#endif
}
inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM* LicenseRequest_ContentIdentification::mutable_webm_id() {
  set_has_webm_id();
  if (webm_id_ == NULL) webm_id_ = new ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM;
  return webm_id_;
}
inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM* LicenseRequest_ContentIdentification::release_webm_id() {
  clear_has_webm_id();
  ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM* temp = webm_id_;
  webm_id_ = NULL;
  return temp;
}
inline void LicenseRequest_ContentIdentification::set_allocated_webm_id(::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM* webm_id) {
  delete webm_id_;
  webm_id_ = webm_id;
  if (webm_id) {
    set_has_webm_id();
  } else {
    clear_has_webm_id();
  }
}

// optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.ExistingLicense license = 3;
inline bool LicenseRequest_ContentIdentification::has_license() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LicenseRequest_ContentIdentification::set_has_license() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LicenseRequest_ContentIdentification::clear_has_license() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LicenseRequest_ContentIdentification::clear_license() {
  if (license_ != NULL) license_->::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense::Clear();
  clear_has_license();
}
inline const ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense& LicenseRequest_ContentIdentification::license() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return license_ != NULL ? *license_ : *default_instance().license_;
#else
  return license_ != NULL ? *license_ : *default_instance_->license_;
#endif
}
inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense* LicenseRequest_ContentIdentification::mutable_license() {
  set_has_license();
  if (license_ == NULL) license_ = new ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense;
  return license_;
}
inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense* LicenseRequest_ContentIdentification::release_license() {
  clear_has_license();
  ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense* temp = license_;
  license_ = NULL;
  return temp;
}
inline void LicenseRequest_ContentIdentification::set_allocated_license(::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense* license) {
  delete license_;
  license_ = license;
  if (license) {
    set_has_license();
  } else {
    clear_has_license();
  }
}

// -------------------------------------------------------------------

// LicenseRequest

// optional .video_widevine_server.sdk.ClientIdentification client_id = 1;
inline bool LicenseRequest::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LicenseRequest::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LicenseRequest::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LicenseRequest::clear_client_id() {
  if (client_id_ != NULL) client_id_->::video_widevine_server::sdk::ClientIdentification::Clear();
  clear_has_client_id();
}
inline const ::video_widevine_server::sdk::ClientIdentification& LicenseRequest::client_id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return client_id_ != NULL ? *client_id_ : *default_instance().client_id_;
#else
  return client_id_ != NULL ? *client_id_ : *default_instance_->client_id_;
#endif
}
inline ::video_widevine_server::sdk::ClientIdentification* LicenseRequest::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == NULL) client_id_ = new ::video_widevine_server::sdk::ClientIdentification;
  return client_id_;
}
inline ::video_widevine_server::sdk::ClientIdentification* LicenseRequest::release_client_id() {
  clear_has_client_id();
  ::video_widevine_server::sdk::ClientIdentification* temp = client_id_;
  client_id_ = NULL;
  return temp;
}
inline void LicenseRequest::set_allocated_client_id(::video_widevine_server::sdk::ClientIdentification* client_id) {
  delete client_id_;
  client_id_ = client_id;
  if (client_id) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
}

// optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification content_id = 2;
inline bool LicenseRequest::has_content_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LicenseRequest::set_has_content_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LicenseRequest::clear_has_content_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LicenseRequest::clear_content_id() {
  if (content_id_ != NULL) content_id_->::video_widevine_server::sdk::LicenseRequest_ContentIdentification::Clear();
  clear_has_content_id();
}
inline const ::video_widevine_server::sdk::LicenseRequest_ContentIdentification& LicenseRequest::content_id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return content_id_ != NULL ? *content_id_ : *default_instance().content_id_;
#else
  return content_id_ != NULL ? *content_id_ : *default_instance_->content_id_;
#endif
}
inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification* LicenseRequest::mutable_content_id() {
  set_has_content_id();
  if (content_id_ == NULL) content_id_ = new ::video_widevine_server::sdk::LicenseRequest_ContentIdentification;
  return content_id_;
}
inline ::video_widevine_server::sdk::LicenseRequest_ContentIdentification* LicenseRequest::release_content_id() {
  clear_has_content_id();
  ::video_widevine_server::sdk::LicenseRequest_ContentIdentification* temp = content_id_;
  content_id_ = NULL;
  return temp;
}
inline void LicenseRequest::set_allocated_content_id(::video_widevine_server::sdk::LicenseRequest_ContentIdentification* content_id) {
  delete content_id_;
  content_id_ = content_id;
  if (content_id) {
    set_has_content_id();
  } else {
    clear_has_content_id();
  }
}

// optional .video_widevine_server.sdk.LicenseRequest.RequestType type = 3;
inline bool LicenseRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LicenseRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LicenseRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LicenseRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::video_widevine_server::sdk::LicenseRequest_RequestType LicenseRequest::type() const {
  return static_cast< ::video_widevine_server::sdk::LicenseRequest_RequestType >(type_);
}
inline void LicenseRequest::set_type(::video_widevine_server::sdk::LicenseRequest_RequestType value) {
  assert(::video_widevine_server::sdk::LicenseRequest_RequestType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int64 request_time = 4;
inline bool LicenseRequest::has_request_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LicenseRequest::set_has_request_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LicenseRequest::clear_has_request_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LicenseRequest::clear_request_time() {
  request_time_ = GOOGLE_LONGLONG(0);
  clear_has_request_time();
}
inline ::google::protobuf::int64 LicenseRequest::request_time() const {
  return request_time_;
}
inline void LicenseRequest::set_request_time(::google::protobuf::int64 value) {
  set_has_request_time();
  request_time_ = value;
}

// optional bytes key_control_nonce_deprecated = 5;
inline bool LicenseRequest::has_key_control_nonce_deprecated() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LicenseRequest::set_has_key_control_nonce_deprecated() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LicenseRequest::clear_has_key_control_nonce_deprecated() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LicenseRequest::clear_key_control_nonce_deprecated() {
  if (key_control_nonce_deprecated_ != &::google::protobuf::internal::kEmptyString) {
    key_control_nonce_deprecated_->clear();
  }
  clear_has_key_control_nonce_deprecated();
}
inline const ::std::string& LicenseRequest::key_control_nonce_deprecated() const {
  return *key_control_nonce_deprecated_;
}
inline void LicenseRequest::set_key_control_nonce_deprecated(const ::std::string& value) {
  set_has_key_control_nonce_deprecated();
  if (key_control_nonce_deprecated_ == &::google::protobuf::internal::kEmptyString) {
    key_control_nonce_deprecated_ = new ::std::string;
  }
  key_control_nonce_deprecated_->assign(value);
}
inline void LicenseRequest::set_key_control_nonce_deprecated(const char* value) {
  set_has_key_control_nonce_deprecated();
  if (key_control_nonce_deprecated_ == &::google::protobuf::internal::kEmptyString) {
    key_control_nonce_deprecated_ = new ::std::string;
  }
  key_control_nonce_deprecated_->assign(value);
}
inline void LicenseRequest::set_key_control_nonce_deprecated(const void* value, size_t size) {
  set_has_key_control_nonce_deprecated();
  if (key_control_nonce_deprecated_ == &::google::protobuf::internal::kEmptyString) {
    key_control_nonce_deprecated_ = new ::std::string;
  }
  key_control_nonce_deprecated_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LicenseRequest::mutable_key_control_nonce_deprecated() {
  set_has_key_control_nonce_deprecated();
  if (key_control_nonce_deprecated_ == &::google::protobuf::internal::kEmptyString) {
    key_control_nonce_deprecated_ = new ::std::string;
  }
  return key_control_nonce_deprecated_;
}
inline ::std::string* LicenseRequest::release_key_control_nonce_deprecated() {
  clear_has_key_control_nonce_deprecated();
  if (key_control_nonce_deprecated_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_control_nonce_deprecated_;
    key_control_nonce_deprecated_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LicenseRequest::set_allocated_key_control_nonce_deprecated(::std::string* key_control_nonce_deprecated) {
  if (key_control_nonce_deprecated_ != &::google::protobuf::internal::kEmptyString) {
    delete key_control_nonce_deprecated_;
  }
  if (key_control_nonce_deprecated) {
    set_has_key_control_nonce_deprecated();
    key_control_nonce_deprecated_ = key_control_nonce_deprecated;
  } else {
    clear_has_key_control_nonce_deprecated();
    key_control_nonce_deprecated_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .video_widevine_server.sdk.ProtocolVersion protocol_version = 6 [default = VERSION_2_0];
inline bool LicenseRequest::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LicenseRequest::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LicenseRequest::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LicenseRequest::clear_protocol_version() {
  protocol_version_ = 20;
  clear_has_protocol_version();
}
inline ::video_widevine_server::sdk::ProtocolVersion LicenseRequest::protocol_version() const {
  return static_cast< ::video_widevine_server::sdk::ProtocolVersion >(protocol_version_);
}
inline void LicenseRequest::set_protocol_version(::video_widevine_server::sdk::ProtocolVersion value) {
  assert(::video_widevine_server::sdk::ProtocolVersion_IsValid(value));
  set_has_protocol_version();
  protocol_version_ = value;
}

// optional uint32 key_control_nonce = 7;
inline bool LicenseRequest::has_key_control_nonce() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LicenseRequest::set_has_key_control_nonce() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LicenseRequest::clear_has_key_control_nonce() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LicenseRequest::clear_key_control_nonce() {
  key_control_nonce_ = 0u;
  clear_has_key_control_nonce();
}
inline ::google::protobuf::uint32 LicenseRequest::key_control_nonce() const {
  return key_control_nonce_;
}
inline void LicenseRequest::set_key_control_nonce(::google::protobuf::uint32 value) {
  set_has_key_control_nonce();
  key_control_nonce_ = value;
}

// optional .video_widevine_server.sdk.EncryptedClientIdentification encrypted_client_id = 8;
inline bool LicenseRequest::has_encrypted_client_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LicenseRequest::set_has_encrypted_client_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LicenseRequest::clear_has_encrypted_client_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LicenseRequest::clear_encrypted_client_id() {
  if (encrypted_client_id_ != NULL) encrypted_client_id_->::video_widevine_server::sdk::EncryptedClientIdentification::Clear();
  clear_has_encrypted_client_id();
}
inline const ::video_widevine_server::sdk::EncryptedClientIdentification& LicenseRequest::encrypted_client_id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return encrypted_client_id_ != NULL ? *encrypted_client_id_ : *default_instance().encrypted_client_id_;
#else
  return encrypted_client_id_ != NULL ? *encrypted_client_id_ : *default_instance_->encrypted_client_id_;
#endif
}
inline ::video_widevine_server::sdk::EncryptedClientIdentification* LicenseRequest::mutable_encrypted_client_id() {
  set_has_encrypted_client_id();
  if (encrypted_client_id_ == NULL) encrypted_client_id_ = new ::video_widevine_server::sdk::EncryptedClientIdentification;
  return encrypted_client_id_;
}
inline ::video_widevine_server::sdk::EncryptedClientIdentification* LicenseRequest::release_encrypted_client_id() {
  clear_has_encrypted_client_id();
  ::video_widevine_server::sdk::EncryptedClientIdentification* temp = encrypted_client_id_;
  encrypted_client_id_ = NULL;
  return temp;
}
inline void LicenseRequest::set_allocated_encrypted_client_id(::video_widevine_server::sdk::EncryptedClientIdentification* encrypted_client_id) {
  delete encrypted_client_id_;
  encrypted_client_id_ = encrypted_client_id;
  if (encrypted_client_id) {
    set_has_encrypted_client_id();
  } else {
    clear_has_encrypted_client_id();
  }
}

// -------------------------------------------------------------------

// LicenseError

// optional .video_widevine_server.sdk.LicenseError.Error error_code = 1;
inline bool LicenseError::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LicenseError::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LicenseError::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LicenseError::clear_error_code() {
  error_code_ = 1;
  clear_has_error_code();
}
inline ::video_widevine_server::sdk::LicenseError_Error LicenseError::error_code() const {
  return static_cast< ::video_widevine_server::sdk::LicenseError_Error >(error_code_);
}
inline void LicenseError::set_error_code(::video_widevine_server::sdk::LicenseError_Error value) {
  assert(::video_widevine_server::sdk::LicenseError_Error_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// MetricData_TypeValue

// optional .video_widevine_server.sdk.MetricData.MetricType type = 1;
inline bool MetricData_TypeValue::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetricData_TypeValue::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetricData_TypeValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetricData_TypeValue::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::video_widevine_server::sdk::MetricData_MetricType MetricData_TypeValue::type() const {
  return static_cast< ::video_widevine_server::sdk::MetricData_MetricType >(type_);
}
inline void MetricData_TypeValue::set_type(::video_widevine_server::sdk::MetricData_MetricType value) {
  assert(::video_widevine_server::sdk::MetricData_MetricType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int64 value = 2 [default = 0];
inline bool MetricData_TypeValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetricData_TypeValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetricData_TypeValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetricData_TypeValue::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 MetricData_TypeValue::value() const {
  return value_;
}
inline void MetricData_TypeValue::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// MetricData

// optional string stage_name = 1;
inline bool MetricData::has_stage_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetricData::set_has_stage_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetricData::clear_has_stage_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetricData::clear_stage_name() {
  if (stage_name_ != &::google::protobuf::internal::kEmptyString) {
    stage_name_->clear();
  }
  clear_has_stage_name();
}
inline const ::std::string& MetricData::stage_name() const {
  return *stage_name_;
}
inline void MetricData::set_stage_name(const ::std::string& value) {
  set_has_stage_name();
  if (stage_name_ == &::google::protobuf::internal::kEmptyString) {
    stage_name_ = new ::std::string;
  }
  stage_name_->assign(value);
}
inline void MetricData::set_stage_name(const char* value) {
  set_has_stage_name();
  if (stage_name_ == &::google::protobuf::internal::kEmptyString) {
    stage_name_ = new ::std::string;
  }
  stage_name_->assign(value);
}
inline void MetricData::set_stage_name(const char* value, size_t size) {
  set_has_stage_name();
  if (stage_name_ == &::google::protobuf::internal::kEmptyString) {
    stage_name_ = new ::std::string;
  }
  stage_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetricData::mutable_stage_name() {
  set_has_stage_name();
  if (stage_name_ == &::google::protobuf::internal::kEmptyString) {
    stage_name_ = new ::std::string;
  }
  return stage_name_;
}
inline ::std::string* MetricData::release_stage_name() {
  clear_has_stage_name();
  if (stage_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stage_name_;
    stage_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MetricData::set_allocated_stage_name(::std::string* stage_name) {
  if (stage_name_ != &::google::protobuf::internal::kEmptyString) {
    delete stage_name_;
  }
  if (stage_name) {
    set_has_stage_name();
    stage_name_ = stage_name;
  } else {
    clear_has_stage_name();
    stage_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .video_widevine_server.sdk.MetricData.TypeValue metric_data = 2;
inline int MetricData::metric_data_size() const {
  return metric_data_.size();
}
inline void MetricData::clear_metric_data() {
  metric_data_.Clear();
}
inline const ::video_widevine_server::sdk::MetricData_TypeValue& MetricData::metric_data(int index) const {
  return metric_data_.Get(index);
}
inline ::video_widevine_server::sdk::MetricData_TypeValue* MetricData::mutable_metric_data(int index) {
  return metric_data_.Mutable(index);
}
inline ::video_widevine_server::sdk::MetricData_TypeValue* MetricData::add_metric_data() {
  return metric_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::MetricData_TypeValue >&
MetricData::metric_data() const {
  return metric_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::MetricData_TypeValue >*
MetricData::mutable_metric_data() {
  return &metric_data_;
}

// -------------------------------------------------------------------

// RemoteAttestation

// optional .video_widevine_server.sdk.EncryptedClientIdentification certificate = 1;
inline bool RemoteAttestation::has_certificate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteAttestation::set_has_certificate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteAttestation::clear_has_certificate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteAttestation::clear_certificate() {
  if (certificate_ != NULL) certificate_->::video_widevine_server::sdk::EncryptedClientIdentification::Clear();
  clear_has_certificate();
}
inline const ::video_widevine_server::sdk::EncryptedClientIdentification& RemoteAttestation::certificate() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return certificate_ != NULL ? *certificate_ : *default_instance().certificate_;
#else
  return certificate_ != NULL ? *certificate_ : *default_instance_->certificate_;
#endif
}
inline ::video_widevine_server::sdk::EncryptedClientIdentification* RemoteAttestation::mutable_certificate() {
  set_has_certificate();
  if (certificate_ == NULL) certificate_ = new ::video_widevine_server::sdk::EncryptedClientIdentification;
  return certificate_;
}
inline ::video_widevine_server::sdk::EncryptedClientIdentification* RemoteAttestation::release_certificate() {
  clear_has_certificate();
  ::video_widevine_server::sdk::EncryptedClientIdentification* temp = certificate_;
  certificate_ = NULL;
  return temp;
}
inline void RemoteAttestation::set_allocated_certificate(::video_widevine_server::sdk::EncryptedClientIdentification* certificate) {
  delete certificate_;
  certificate_ = certificate;
  if (certificate) {
    set_has_certificate();
  } else {
    clear_has_certificate();
  }
}

// optional bytes salt = 2;
inline bool RemoteAttestation::has_salt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteAttestation::set_has_salt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteAttestation::clear_has_salt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteAttestation::clear_salt() {
  if (salt_ != &::google::protobuf::internal::kEmptyString) {
    salt_->clear();
  }
  clear_has_salt();
}
inline const ::std::string& RemoteAttestation::salt() const {
  return *salt_;
}
inline void RemoteAttestation::set_salt(const ::std::string& value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void RemoteAttestation::set_salt(const char* value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void RemoteAttestation::set_salt(const void* value, size_t size) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteAttestation::mutable_salt() {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  return salt_;
}
inline ::std::string* RemoteAttestation::release_salt() {
  clear_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = salt_;
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteAttestation::set_allocated_salt(::std::string* salt) {
  if (salt_ != &::google::protobuf::internal::kEmptyString) {
    delete salt_;
  }
  if (salt) {
    set_has_salt();
    salt_ = salt;
  } else {
    clear_has_salt();
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signature = 3;
inline bool RemoteAttestation::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteAttestation::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteAttestation::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteAttestation::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& RemoteAttestation::signature() const {
  return *signature_;
}
inline void RemoteAttestation::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void RemoteAttestation::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void RemoteAttestation::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteAttestation::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* RemoteAttestation::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteAttestation::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignedMessage

// optional .video_widevine_server.sdk.SignedMessage.MessageType type = 1;
inline bool SignedMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::video_widevine_server::sdk::SignedMessage_MessageType SignedMessage::type() const {
  return static_cast< ::video_widevine_server::sdk::SignedMessage_MessageType >(type_);
}
inline void SignedMessage::set_type(::video_widevine_server::sdk::SignedMessage_MessageType value) {
  assert(::video_widevine_server::sdk::SignedMessage_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes msg = 2;
inline bool SignedMessage::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedMessage::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedMessage::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedMessage::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& SignedMessage::msg() const {
  return *msg_;
}
inline void SignedMessage::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void SignedMessage::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void SignedMessage::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedMessage::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* SignedMessage::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedMessage::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signature = 3;
inline bool SignedMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedMessage::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedMessage::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedMessage::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& SignedMessage::signature() const {
  return *signature_;
}
inline void SignedMessage::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedMessage::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedMessage::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedMessage::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SignedMessage::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedMessage::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes session_key = 4;
inline bool SignedMessage::has_session_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignedMessage::set_has_session_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignedMessage::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignedMessage::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& SignedMessage::session_key() const {
  return *session_key_;
}
inline void SignedMessage::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void SignedMessage::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void SignedMessage::set_session_key(const void* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedMessage::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  return session_key_;
}
inline ::std::string* SignedMessage::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedMessage::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .video_widevine_server.sdk.RemoteAttestation remote_attestation = 5;
inline bool SignedMessage::has_remote_attestation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignedMessage::set_has_remote_attestation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignedMessage::clear_has_remote_attestation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignedMessage::clear_remote_attestation() {
  if (remote_attestation_ != NULL) remote_attestation_->::video_widevine_server::sdk::RemoteAttestation::Clear();
  clear_has_remote_attestation();
}
inline const ::video_widevine_server::sdk::RemoteAttestation& SignedMessage::remote_attestation() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return remote_attestation_ != NULL ? *remote_attestation_ : *default_instance().remote_attestation_;
#else
  return remote_attestation_ != NULL ? *remote_attestation_ : *default_instance_->remote_attestation_;
#endif
}
inline ::video_widevine_server::sdk::RemoteAttestation* SignedMessage::mutable_remote_attestation() {
  set_has_remote_attestation();
  if (remote_attestation_ == NULL) remote_attestation_ = new ::video_widevine_server::sdk::RemoteAttestation;
  return remote_attestation_;
}
inline ::video_widevine_server::sdk::RemoteAttestation* SignedMessage::release_remote_attestation() {
  clear_has_remote_attestation();
  ::video_widevine_server::sdk::RemoteAttestation* temp = remote_attestation_;
  remote_attestation_ = NULL;
  return temp;
}
inline void SignedMessage::set_allocated_remote_attestation(::video_widevine_server::sdk::RemoteAttestation* remote_attestation) {
  delete remote_attestation_;
  remote_attestation_ = remote_attestation;
  if (remote_attestation) {
    set_has_remote_attestation();
  } else {
    clear_has_remote_attestation();
  }
}

// repeated .video_widevine_server.sdk.MetricData metric_data = 6;
inline int SignedMessage::metric_data_size() const {
  return metric_data_.size();
}
inline void SignedMessage::clear_metric_data() {
  metric_data_.Clear();
}
inline const ::video_widevine_server::sdk::MetricData& SignedMessage::metric_data(int index) const {
  return metric_data_.Get(index);
}
inline ::video_widevine_server::sdk::MetricData* SignedMessage::mutable_metric_data(int index) {
  return metric_data_.Mutable(index);
}
inline ::video_widevine_server::sdk::MetricData* SignedMessage::add_metric_data() {
  return metric_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::MetricData >&
SignedMessage::metric_data() const {
  return metric_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::MetricData >*
SignedMessage::mutable_metric_data() {
  return &metric_data_;
}

// -------------------------------------------------------------------

// GroupKeys

// repeated .video_widevine_server.sdk.License.KeyContainer key = 1;
inline int GroupKeys::key_size() const {
  return key_.size();
}
inline void GroupKeys::clear_key() {
  key_.Clear();
}
inline const ::video_widevine_server::sdk::License_KeyContainer& GroupKeys::key(int index) const {
  return key_.Get(index);
}
inline ::video_widevine_server::sdk::License_KeyContainer* GroupKeys::mutable_key(int index) {
  return key_.Mutable(index);
}
inline ::video_widevine_server::sdk::License_KeyContainer* GroupKeys::add_key() {
  return key_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer >&
GroupKeys::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::License_KeyContainer >*
GroupKeys::mutable_key() {
  return &key_;
}

// optional bytes group_id = 2;
inline bool GroupKeys::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupKeys::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupKeys::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupKeys::clear_group_id() {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    group_id_->clear();
  }
  clear_has_group_id();
}
inline const ::std::string& GroupKeys::group_id() const {
  return *group_id_;
}
inline void GroupKeys::set_group_id(const ::std::string& value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void GroupKeys::set_group_id(const char* value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void GroupKeys::set_group_id(const void* value, size_t size) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupKeys::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  return group_id_;
}
inline ::std::string* GroupKeys::release_group_id() {
  clear_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_id_;
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupKeys::set_allocated_group_id(::std::string* group_id) {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete group_id_;
  }
  if (group_id) {
    set_has_group_id();
    group_id_ = group_id;
  } else {
    clear_has_group_id();
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProvisioningOptions

// optional .video_widevine_server.sdk.ProvisioningOptions.CertificateType certificate_type = 1;
inline bool ProvisioningOptions::has_certificate_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProvisioningOptions::set_has_certificate_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProvisioningOptions::clear_has_certificate_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProvisioningOptions::clear_certificate_type() {
  certificate_type_ = 0;
  clear_has_certificate_type();
}
inline ::video_widevine_server::sdk::ProvisioningOptions_CertificateType ProvisioningOptions::certificate_type() const {
  return static_cast< ::video_widevine_server::sdk::ProvisioningOptions_CertificateType >(certificate_type_);
}
inline void ProvisioningOptions::set_certificate_type(::video_widevine_server::sdk::ProvisioningOptions_CertificateType value) {
  assert(::video_widevine_server::sdk::ProvisioningOptions_CertificateType_IsValid(value));
  set_has_certificate_type();
  certificate_type_ = value;
}

// optional string certificate_authority = 2;
inline bool ProvisioningOptions::has_certificate_authority() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProvisioningOptions::set_has_certificate_authority() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProvisioningOptions::clear_has_certificate_authority() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProvisioningOptions::clear_certificate_authority() {
  if (certificate_authority_ != &::google::protobuf::internal::kEmptyString) {
    certificate_authority_->clear();
  }
  clear_has_certificate_authority();
}
inline const ::std::string& ProvisioningOptions::certificate_authority() const {
  return *certificate_authority_;
}
inline void ProvisioningOptions::set_certificate_authority(const ::std::string& value) {
  set_has_certificate_authority();
  if (certificate_authority_ == &::google::protobuf::internal::kEmptyString) {
    certificate_authority_ = new ::std::string;
  }
  certificate_authority_->assign(value);
}
inline void ProvisioningOptions::set_certificate_authority(const char* value) {
  set_has_certificate_authority();
  if (certificate_authority_ == &::google::protobuf::internal::kEmptyString) {
    certificate_authority_ = new ::std::string;
  }
  certificate_authority_->assign(value);
}
inline void ProvisioningOptions::set_certificate_authority(const char* value, size_t size) {
  set_has_certificate_authority();
  if (certificate_authority_ == &::google::protobuf::internal::kEmptyString) {
    certificate_authority_ = new ::std::string;
  }
  certificate_authority_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProvisioningOptions::mutable_certificate_authority() {
  set_has_certificate_authority();
  if (certificate_authority_ == &::google::protobuf::internal::kEmptyString) {
    certificate_authority_ = new ::std::string;
  }
  return certificate_authority_;
}
inline ::std::string* ProvisioningOptions::release_certificate_authority() {
  clear_has_certificate_authority();
  if (certificate_authority_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certificate_authority_;
    certificate_authority_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProvisioningOptions::set_allocated_certificate_authority(::std::string* certificate_authority) {
  if (certificate_authority_ != &::google::protobuf::internal::kEmptyString) {
    delete certificate_authority_;
  }
  if (certificate_authority) {
    set_has_certificate_authority();
    certificate_authority_ = certificate_authority;
  } else {
    clear_has_certificate_authority();
    certificate_authority_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProvisioningRequest

// optional .video_widevine_server.sdk.ClientIdentification client_id = 1;
inline bool ProvisioningRequest::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProvisioningRequest::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProvisioningRequest::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProvisioningRequest::clear_client_id() {
  if (client_id_ != NULL) client_id_->::video_widevine_server::sdk::ClientIdentification::Clear();
  clear_has_client_id();
}
inline const ::video_widevine_server::sdk::ClientIdentification& ProvisioningRequest::client_id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return client_id_ != NULL ? *client_id_ : *default_instance().client_id_;
#else
  return client_id_ != NULL ? *client_id_ : *default_instance_->client_id_;
#endif
}
inline ::video_widevine_server::sdk::ClientIdentification* ProvisioningRequest::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == NULL) client_id_ = new ::video_widevine_server::sdk::ClientIdentification;
  return client_id_;
}
inline ::video_widevine_server::sdk::ClientIdentification* ProvisioningRequest::release_client_id() {
  clear_has_client_id();
  ::video_widevine_server::sdk::ClientIdentification* temp = client_id_;
  client_id_ = NULL;
  return temp;
}
inline void ProvisioningRequest::set_allocated_client_id(::video_widevine_server::sdk::ClientIdentification* client_id) {
  delete client_id_;
  client_id_ = client_id;
  if (client_id) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
}

// optional bytes nonce = 2;
inline bool ProvisioningRequest::has_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProvisioningRequest::set_has_nonce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProvisioningRequest::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProvisioningRequest::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& ProvisioningRequest::nonce() const {
  return *nonce_;
}
inline void ProvisioningRequest::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void ProvisioningRequest::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void ProvisioningRequest::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProvisioningRequest::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  return nonce_;
}
inline ::std::string* ProvisioningRequest::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProvisioningRequest::set_allocated_nonce(::std::string* nonce) {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete nonce_;
  }
  if (nonce) {
    set_has_nonce();
    nonce_ = nonce;
  } else {
    clear_has_nonce();
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .video_widevine_server.sdk.ProvisioningOptions options = 3;
inline bool ProvisioningRequest::has_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProvisioningRequest::set_has_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProvisioningRequest::clear_has_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProvisioningRequest::clear_options() {
  if (options_ != NULL) options_->::video_widevine_server::sdk::ProvisioningOptions::Clear();
  clear_has_options();
}
inline const ::video_widevine_server::sdk::ProvisioningOptions& ProvisioningRequest::options() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return options_ != NULL ? *options_ : *default_instance().options_;
#else
  return options_ != NULL ? *options_ : *default_instance_->options_;
#endif
}
inline ::video_widevine_server::sdk::ProvisioningOptions* ProvisioningRequest::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::video_widevine_server::sdk::ProvisioningOptions;
  return options_;
}
inline ::video_widevine_server::sdk::ProvisioningOptions* ProvisioningRequest::release_options() {
  clear_has_options();
  ::video_widevine_server::sdk::ProvisioningOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void ProvisioningRequest::set_allocated_options(::video_widevine_server::sdk::ProvisioningOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// optional bytes stable_id = 4;
inline bool ProvisioningRequest::has_stable_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProvisioningRequest::set_has_stable_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProvisioningRequest::clear_has_stable_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProvisioningRequest::clear_stable_id() {
  if (stable_id_ != &::google::protobuf::internal::kEmptyString) {
    stable_id_->clear();
  }
  clear_has_stable_id();
}
inline const ::std::string& ProvisioningRequest::stable_id() const {
  return *stable_id_;
}
inline void ProvisioningRequest::set_stable_id(const ::std::string& value) {
  set_has_stable_id();
  if (stable_id_ == &::google::protobuf::internal::kEmptyString) {
    stable_id_ = new ::std::string;
  }
  stable_id_->assign(value);
}
inline void ProvisioningRequest::set_stable_id(const char* value) {
  set_has_stable_id();
  if (stable_id_ == &::google::protobuf::internal::kEmptyString) {
    stable_id_ = new ::std::string;
  }
  stable_id_->assign(value);
}
inline void ProvisioningRequest::set_stable_id(const void* value, size_t size) {
  set_has_stable_id();
  if (stable_id_ == &::google::protobuf::internal::kEmptyString) {
    stable_id_ = new ::std::string;
  }
  stable_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProvisioningRequest::mutable_stable_id() {
  set_has_stable_id();
  if (stable_id_ == &::google::protobuf::internal::kEmptyString) {
    stable_id_ = new ::std::string;
  }
  return stable_id_;
}
inline ::std::string* ProvisioningRequest::release_stable_id() {
  clear_has_stable_id();
  if (stable_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stable_id_;
    stable_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProvisioningRequest::set_allocated_stable_id(::std::string* stable_id) {
  if (stable_id_ != &::google::protobuf::internal::kEmptyString) {
    delete stable_id_;
  }
  if (stable_id) {
    set_has_stable_id();
    stable_id_ = stable_id;
  } else {
    clear_has_stable_id();
    stable_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProvisioningResponse

// optional bytes device_rsa_key = 1;
inline bool ProvisioningResponse::has_device_rsa_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProvisioningResponse::set_has_device_rsa_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProvisioningResponse::clear_has_device_rsa_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProvisioningResponse::clear_device_rsa_key() {
  if (device_rsa_key_ != &::google::protobuf::internal::kEmptyString) {
    device_rsa_key_->clear();
  }
  clear_has_device_rsa_key();
}
inline const ::std::string& ProvisioningResponse::device_rsa_key() const {
  return *device_rsa_key_;
}
inline void ProvisioningResponse::set_device_rsa_key(const ::std::string& value) {
  set_has_device_rsa_key();
  if (device_rsa_key_ == &::google::protobuf::internal::kEmptyString) {
    device_rsa_key_ = new ::std::string;
  }
  device_rsa_key_->assign(value);
}
inline void ProvisioningResponse::set_device_rsa_key(const char* value) {
  set_has_device_rsa_key();
  if (device_rsa_key_ == &::google::protobuf::internal::kEmptyString) {
    device_rsa_key_ = new ::std::string;
  }
  device_rsa_key_->assign(value);
}
inline void ProvisioningResponse::set_device_rsa_key(const void* value, size_t size) {
  set_has_device_rsa_key();
  if (device_rsa_key_ == &::google::protobuf::internal::kEmptyString) {
    device_rsa_key_ = new ::std::string;
  }
  device_rsa_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProvisioningResponse::mutable_device_rsa_key() {
  set_has_device_rsa_key();
  if (device_rsa_key_ == &::google::protobuf::internal::kEmptyString) {
    device_rsa_key_ = new ::std::string;
  }
  return device_rsa_key_;
}
inline ::std::string* ProvisioningResponse::release_device_rsa_key() {
  clear_has_device_rsa_key();
  if (device_rsa_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_rsa_key_;
    device_rsa_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProvisioningResponse::set_allocated_device_rsa_key(::std::string* device_rsa_key) {
  if (device_rsa_key_ != &::google::protobuf::internal::kEmptyString) {
    delete device_rsa_key_;
  }
  if (device_rsa_key) {
    set_has_device_rsa_key();
    device_rsa_key_ = device_rsa_key;
  } else {
    clear_has_device_rsa_key();
    device_rsa_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes device_rsa_key_iv = 2;
inline bool ProvisioningResponse::has_device_rsa_key_iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProvisioningResponse::set_has_device_rsa_key_iv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProvisioningResponse::clear_has_device_rsa_key_iv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProvisioningResponse::clear_device_rsa_key_iv() {
  if (device_rsa_key_iv_ != &::google::protobuf::internal::kEmptyString) {
    device_rsa_key_iv_->clear();
  }
  clear_has_device_rsa_key_iv();
}
inline const ::std::string& ProvisioningResponse::device_rsa_key_iv() const {
  return *device_rsa_key_iv_;
}
inline void ProvisioningResponse::set_device_rsa_key_iv(const ::std::string& value) {
  set_has_device_rsa_key_iv();
  if (device_rsa_key_iv_ == &::google::protobuf::internal::kEmptyString) {
    device_rsa_key_iv_ = new ::std::string;
  }
  device_rsa_key_iv_->assign(value);
}
inline void ProvisioningResponse::set_device_rsa_key_iv(const char* value) {
  set_has_device_rsa_key_iv();
  if (device_rsa_key_iv_ == &::google::protobuf::internal::kEmptyString) {
    device_rsa_key_iv_ = new ::std::string;
  }
  device_rsa_key_iv_->assign(value);
}
inline void ProvisioningResponse::set_device_rsa_key_iv(const void* value, size_t size) {
  set_has_device_rsa_key_iv();
  if (device_rsa_key_iv_ == &::google::protobuf::internal::kEmptyString) {
    device_rsa_key_iv_ = new ::std::string;
  }
  device_rsa_key_iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProvisioningResponse::mutable_device_rsa_key_iv() {
  set_has_device_rsa_key_iv();
  if (device_rsa_key_iv_ == &::google::protobuf::internal::kEmptyString) {
    device_rsa_key_iv_ = new ::std::string;
  }
  return device_rsa_key_iv_;
}
inline ::std::string* ProvisioningResponse::release_device_rsa_key_iv() {
  clear_has_device_rsa_key_iv();
  if (device_rsa_key_iv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_rsa_key_iv_;
    device_rsa_key_iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProvisioningResponse::set_allocated_device_rsa_key_iv(::std::string* device_rsa_key_iv) {
  if (device_rsa_key_iv_ != &::google::protobuf::internal::kEmptyString) {
    delete device_rsa_key_iv_;
  }
  if (device_rsa_key_iv) {
    set_has_device_rsa_key_iv();
    device_rsa_key_iv_ = device_rsa_key_iv;
  } else {
    clear_has_device_rsa_key_iv();
    device_rsa_key_iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes device_certificate = 3;
inline bool ProvisioningResponse::has_device_certificate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProvisioningResponse::set_has_device_certificate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProvisioningResponse::clear_has_device_certificate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProvisioningResponse::clear_device_certificate() {
  if (device_certificate_ != &::google::protobuf::internal::kEmptyString) {
    device_certificate_->clear();
  }
  clear_has_device_certificate();
}
inline const ::std::string& ProvisioningResponse::device_certificate() const {
  return *device_certificate_;
}
inline void ProvisioningResponse::set_device_certificate(const ::std::string& value) {
  set_has_device_certificate();
  if (device_certificate_ == &::google::protobuf::internal::kEmptyString) {
    device_certificate_ = new ::std::string;
  }
  device_certificate_->assign(value);
}
inline void ProvisioningResponse::set_device_certificate(const char* value) {
  set_has_device_certificate();
  if (device_certificate_ == &::google::protobuf::internal::kEmptyString) {
    device_certificate_ = new ::std::string;
  }
  device_certificate_->assign(value);
}
inline void ProvisioningResponse::set_device_certificate(const void* value, size_t size) {
  set_has_device_certificate();
  if (device_certificate_ == &::google::protobuf::internal::kEmptyString) {
    device_certificate_ = new ::std::string;
  }
  device_certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProvisioningResponse::mutable_device_certificate() {
  set_has_device_certificate();
  if (device_certificate_ == &::google::protobuf::internal::kEmptyString) {
    device_certificate_ = new ::std::string;
  }
  return device_certificate_;
}
inline ::std::string* ProvisioningResponse::release_device_certificate() {
  clear_has_device_certificate();
  if (device_certificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_certificate_;
    device_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProvisioningResponse::set_allocated_device_certificate(::std::string* device_certificate) {
  if (device_certificate_ != &::google::protobuf::internal::kEmptyString) {
    delete device_certificate_;
  }
  if (device_certificate) {
    set_has_device_certificate();
    device_certificate_ = device_certificate;
  } else {
    clear_has_device_certificate();
    device_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes nonce = 4;
inline bool ProvisioningResponse::has_nonce() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProvisioningResponse::set_has_nonce() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProvisioningResponse::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProvisioningResponse::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& ProvisioningResponse::nonce() const {
  return *nonce_;
}
inline void ProvisioningResponse::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void ProvisioningResponse::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void ProvisioningResponse::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProvisioningResponse::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  return nonce_;
}
inline ::std::string* ProvisioningResponse::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProvisioningResponse::set_allocated_nonce(::std::string* nonce) {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete nonce_;
  }
  if (nonce) {
    set_has_nonce();
    nonce_ = nonce;
  } else {
    clear_has_nonce();
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignedProvisioningMessage

// optional bytes message = 1;
inline bool SignedProvisioningMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedProvisioningMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedProvisioningMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedProvisioningMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& SignedProvisioningMessage::message() const {
  return *message_;
}
inline void SignedProvisioningMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void SignedProvisioningMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void SignedProvisioningMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedProvisioningMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* SignedProvisioningMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedProvisioningMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signature = 2;
inline bool SignedProvisioningMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedProvisioningMessage::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedProvisioningMessage::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedProvisioningMessage::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& SignedProvisioningMessage::signature() const {
  return *signature_;
}
inline void SignedProvisioningMessage::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedProvisioningMessage::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedProvisioningMessage::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedProvisioningMessage::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SignedProvisioningMessage::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedProvisioningMessage::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientIdentification_NameValue

// optional string name = 1;
inline bool ClientIdentification_NameValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientIdentification_NameValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientIdentification_NameValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientIdentification_NameValue::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClientIdentification_NameValue::name() const {
  return *name_;
}
inline void ClientIdentification_NameValue::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientIdentification_NameValue::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientIdentification_NameValue::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientIdentification_NameValue::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClientIdentification_NameValue::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientIdentification_NameValue::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool ClientIdentification_NameValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientIdentification_NameValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientIdentification_NameValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientIdentification_NameValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ClientIdentification_NameValue::value() const {
  return *value_;
}
inline void ClientIdentification_NameValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ClientIdentification_NameValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ClientIdentification_NameValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientIdentification_NameValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ClientIdentification_NameValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientIdentification_NameValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientIdentification_ClientCapabilities

// optional bool client_token = 1 [default = false];
inline bool ClientIdentification_ClientCapabilities::has_client_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientIdentification_ClientCapabilities::set_has_client_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientIdentification_ClientCapabilities::clear_has_client_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientIdentification_ClientCapabilities::clear_client_token() {
  client_token_ = false;
  clear_has_client_token();
}
inline bool ClientIdentification_ClientCapabilities::client_token() const {
  return client_token_;
}
inline void ClientIdentification_ClientCapabilities::set_client_token(bool value) {
  set_has_client_token();
  client_token_ = value;
}

// optional bool session_token = 2 [default = false];
inline bool ClientIdentification_ClientCapabilities::has_session_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientIdentification_ClientCapabilities::set_has_session_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientIdentification_ClientCapabilities::clear_has_session_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientIdentification_ClientCapabilities::clear_session_token() {
  session_token_ = false;
  clear_has_session_token();
}
inline bool ClientIdentification_ClientCapabilities::session_token() const {
  return session_token_;
}
inline void ClientIdentification_ClientCapabilities::set_session_token(bool value) {
  set_has_session_token();
  session_token_ = value;
}

// optional bool video_resolution_constraints = 3 [default = false];
inline bool ClientIdentification_ClientCapabilities::has_video_resolution_constraints() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientIdentification_ClientCapabilities::set_has_video_resolution_constraints() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientIdentification_ClientCapabilities::clear_has_video_resolution_constraints() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientIdentification_ClientCapabilities::clear_video_resolution_constraints() {
  video_resolution_constraints_ = false;
  clear_has_video_resolution_constraints();
}
inline bool ClientIdentification_ClientCapabilities::video_resolution_constraints() const {
  return video_resolution_constraints_;
}
inline void ClientIdentification_ClientCapabilities::set_video_resolution_constraints(bool value) {
  set_has_video_resolution_constraints();
  video_resolution_constraints_ = value;
}

// optional .video_widevine_server.sdk.ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];
inline bool ClientIdentification_ClientCapabilities::has_max_hdcp_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientIdentification_ClientCapabilities::set_has_max_hdcp_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientIdentification_ClientCapabilities::clear_has_max_hdcp_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientIdentification_ClientCapabilities::clear_max_hdcp_version() {
  max_hdcp_version_ = 0;
  clear_has_max_hdcp_version();
}
inline ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities_HdcpVersion ClientIdentification_ClientCapabilities::max_hdcp_version() const {
  return static_cast< ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities_HdcpVersion >(max_hdcp_version_);
}
inline void ClientIdentification_ClientCapabilities::set_max_hdcp_version(::video_widevine_server::sdk::ClientIdentification_ClientCapabilities_HdcpVersion value) {
  assert(::video_widevine_server::sdk::ClientIdentification_ClientCapabilities_HdcpVersion_IsValid(value));
  set_has_max_hdcp_version();
  max_hdcp_version_ = value;
}

// optional uint32 oem_crypto_api_version = 5;
inline bool ClientIdentification_ClientCapabilities::has_oem_crypto_api_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientIdentification_ClientCapabilities::set_has_oem_crypto_api_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientIdentification_ClientCapabilities::clear_has_oem_crypto_api_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientIdentification_ClientCapabilities::clear_oem_crypto_api_version() {
  oem_crypto_api_version_ = 0u;
  clear_has_oem_crypto_api_version();
}
inline ::google::protobuf::uint32 ClientIdentification_ClientCapabilities::oem_crypto_api_version() const {
  return oem_crypto_api_version_;
}
inline void ClientIdentification_ClientCapabilities::set_oem_crypto_api_version(::google::protobuf::uint32 value) {
  set_has_oem_crypto_api_version();
  oem_crypto_api_version_ = value;
}

// optional bool anti_rollback_usage_table = 6 [default = false];
inline bool ClientIdentification_ClientCapabilities::has_anti_rollback_usage_table() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientIdentification_ClientCapabilities::set_has_anti_rollback_usage_table() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientIdentification_ClientCapabilities::clear_has_anti_rollback_usage_table() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientIdentification_ClientCapabilities::clear_anti_rollback_usage_table() {
  anti_rollback_usage_table_ = false;
  clear_has_anti_rollback_usage_table();
}
inline bool ClientIdentification_ClientCapabilities::anti_rollback_usage_table() const {
  return anti_rollback_usage_table_;
}
inline void ClientIdentification_ClientCapabilities::set_anti_rollback_usage_table(bool value) {
  set_has_anti_rollback_usage_table();
  anti_rollback_usage_table_ = value;
}

// -------------------------------------------------------------------

// ClientIdentification

// optional .video_widevine_server.sdk.ClientIdentification.TokenType type = 1 [default = KEYBOX];
inline bool ClientIdentification::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientIdentification::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientIdentification::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientIdentification::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::video_widevine_server::sdk::ClientIdentification_TokenType ClientIdentification::type() const {
  return static_cast< ::video_widevine_server::sdk::ClientIdentification_TokenType >(type_);
}
inline void ClientIdentification::set_type(::video_widevine_server::sdk::ClientIdentification_TokenType value) {
  assert(::video_widevine_server::sdk::ClientIdentification_TokenType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes token = 2;
inline bool ClientIdentification::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientIdentification::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientIdentification::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientIdentification::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ClientIdentification::token() const {
  return *token_;
}
inline void ClientIdentification::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ClientIdentification::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ClientIdentification::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientIdentification::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ClientIdentification::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientIdentification::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .video_widevine_server.sdk.ClientIdentification.NameValue client_info = 3;
inline int ClientIdentification::client_info_size() const {
  return client_info_.size();
}
inline void ClientIdentification::clear_client_info() {
  client_info_.Clear();
}
inline const ::video_widevine_server::sdk::ClientIdentification_NameValue& ClientIdentification::client_info(int index) const {
  return client_info_.Get(index);
}
inline ::video_widevine_server::sdk::ClientIdentification_NameValue* ClientIdentification::mutable_client_info(int index) {
  return client_info_.Mutable(index);
}
inline ::video_widevine_server::sdk::ClientIdentification_NameValue* ClientIdentification::add_client_info() {
  return client_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::ClientIdentification_NameValue >&
ClientIdentification::client_info() const {
  return client_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::ClientIdentification_NameValue >*
ClientIdentification::mutable_client_info() {
  return &client_info_;
}

// optional bytes provider_client_token = 4;
inline bool ClientIdentification::has_provider_client_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientIdentification::set_has_provider_client_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientIdentification::clear_has_provider_client_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientIdentification::clear_provider_client_token() {
  if (provider_client_token_ != &::google::protobuf::internal::kEmptyString) {
    provider_client_token_->clear();
  }
  clear_has_provider_client_token();
}
inline const ::std::string& ClientIdentification::provider_client_token() const {
  return *provider_client_token_;
}
inline void ClientIdentification::set_provider_client_token(const ::std::string& value) {
  set_has_provider_client_token();
  if (provider_client_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_client_token_ = new ::std::string;
  }
  provider_client_token_->assign(value);
}
inline void ClientIdentification::set_provider_client_token(const char* value) {
  set_has_provider_client_token();
  if (provider_client_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_client_token_ = new ::std::string;
  }
  provider_client_token_->assign(value);
}
inline void ClientIdentification::set_provider_client_token(const void* value, size_t size) {
  set_has_provider_client_token();
  if (provider_client_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_client_token_ = new ::std::string;
  }
  provider_client_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientIdentification::mutable_provider_client_token() {
  set_has_provider_client_token();
  if (provider_client_token_ == &::google::protobuf::internal::kEmptyString) {
    provider_client_token_ = new ::std::string;
  }
  return provider_client_token_;
}
inline ::std::string* ClientIdentification::release_provider_client_token() {
  clear_has_provider_client_token();
  if (provider_client_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_client_token_;
    provider_client_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientIdentification::set_allocated_provider_client_token(::std::string* provider_client_token) {
  if (provider_client_token_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_client_token_;
  }
  if (provider_client_token) {
    set_has_provider_client_token();
    provider_client_token_ = provider_client_token;
  } else {
    clear_has_provider_client_token();
    provider_client_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 license_counter = 5;
inline bool ClientIdentification::has_license_counter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientIdentification::set_has_license_counter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientIdentification::clear_has_license_counter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientIdentification::clear_license_counter() {
  license_counter_ = 0u;
  clear_has_license_counter();
}
inline ::google::protobuf::uint32 ClientIdentification::license_counter() const {
  return license_counter_;
}
inline void ClientIdentification::set_license_counter(::google::protobuf::uint32 value) {
  set_has_license_counter();
  license_counter_ = value;
}

// optional .video_widevine_server.sdk.ClientIdentification.ClientCapabilities client_capabilities = 6;
inline bool ClientIdentification::has_client_capabilities() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientIdentification::set_has_client_capabilities() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientIdentification::clear_has_client_capabilities() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientIdentification::clear_client_capabilities() {
  if (client_capabilities_ != NULL) client_capabilities_->::video_widevine_server::sdk::ClientIdentification_ClientCapabilities::Clear();
  clear_has_client_capabilities();
}
inline const ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities& ClientIdentification::client_capabilities() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return client_capabilities_ != NULL ? *client_capabilities_ : *default_instance().client_capabilities_;
#else
  return client_capabilities_ != NULL ? *client_capabilities_ : *default_instance_->client_capabilities_;
#endif
}
inline ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities* ClientIdentification::mutable_client_capabilities() {
  set_has_client_capabilities();
  if (client_capabilities_ == NULL) client_capabilities_ = new ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities;
  return client_capabilities_;
}
inline ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities* ClientIdentification::release_client_capabilities() {
  clear_has_client_capabilities();
  ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities* temp = client_capabilities_;
  client_capabilities_ = NULL;
  return temp;
}
inline void ClientIdentification::set_allocated_client_capabilities(::video_widevine_server::sdk::ClientIdentification_ClientCapabilities* client_capabilities) {
  delete client_capabilities_;
  client_capabilities_ = client_capabilities;
  if (client_capabilities) {
    set_has_client_capabilities();
  } else {
    clear_has_client_capabilities();
  }
}

// -------------------------------------------------------------------

// EncryptedClientIdentification

// optional string service_id = 1;
inline bool EncryptedClientIdentification::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptedClientIdentification::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncryptedClientIdentification::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncryptedClientIdentification::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& EncryptedClientIdentification::service_id() const {
  return *service_id_;
}
inline void EncryptedClientIdentification::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void EncryptedClientIdentification::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void EncryptedClientIdentification::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedClientIdentification::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* EncryptedClientIdentification::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptedClientIdentification::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes service_certificate_serial_number = 2;
inline bool EncryptedClientIdentification::has_service_certificate_serial_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncryptedClientIdentification::set_has_service_certificate_serial_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncryptedClientIdentification::clear_has_service_certificate_serial_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncryptedClientIdentification::clear_service_certificate_serial_number() {
  if (service_certificate_serial_number_ != &::google::protobuf::internal::kEmptyString) {
    service_certificate_serial_number_->clear();
  }
  clear_has_service_certificate_serial_number();
}
inline const ::std::string& EncryptedClientIdentification::service_certificate_serial_number() const {
  return *service_certificate_serial_number_;
}
inline void EncryptedClientIdentification::set_service_certificate_serial_number(const ::std::string& value) {
  set_has_service_certificate_serial_number();
  if (service_certificate_serial_number_ == &::google::protobuf::internal::kEmptyString) {
    service_certificate_serial_number_ = new ::std::string;
  }
  service_certificate_serial_number_->assign(value);
}
inline void EncryptedClientIdentification::set_service_certificate_serial_number(const char* value) {
  set_has_service_certificate_serial_number();
  if (service_certificate_serial_number_ == &::google::protobuf::internal::kEmptyString) {
    service_certificate_serial_number_ = new ::std::string;
  }
  service_certificate_serial_number_->assign(value);
}
inline void EncryptedClientIdentification::set_service_certificate_serial_number(const void* value, size_t size) {
  set_has_service_certificate_serial_number();
  if (service_certificate_serial_number_ == &::google::protobuf::internal::kEmptyString) {
    service_certificate_serial_number_ = new ::std::string;
  }
  service_certificate_serial_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedClientIdentification::mutable_service_certificate_serial_number() {
  set_has_service_certificate_serial_number();
  if (service_certificate_serial_number_ == &::google::protobuf::internal::kEmptyString) {
    service_certificate_serial_number_ = new ::std::string;
  }
  return service_certificate_serial_number_;
}
inline ::std::string* EncryptedClientIdentification::release_service_certificate_serial_number() {
  clear_has_service_certificate_serial_number();
  if (service_certificate_serial_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_certificate_serial_number_;
    service_certificate_serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptedClientIdentification::set_allocated_service_certificate_serial_number(::std::string* service_certificate_serial_number) {
  if (service_certificate_serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete service_certificate_serial_number_;
  }
  if (service_certificate_serial_number) {
    set_has_service_certificate_serial_number();
    service_certificate_serial_number_ = service_certificate_serial_number;
  } else {
    clear_has_service_certificate_serial_number();
    service_certificate_serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encrypted_client_id = 3;
inline bool EncryptedClientIdentification::has_encrypted_client_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncryptedClientIdentification::set_has_encrypted_client_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncryptedClientIdentification::clear_has_encrypted_client_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncryptedClientIdentification::clear_encrypted_client_id() {
  if (encrypted_client_id_ != &::google::protobuf::internal::kEmptyString) {
    encrypted_client_id_->clear();
  }
  clear_has_encrypted_client_id();
}
inline const ::std::string& EncryptedClientIdentification::encrypted_client_id() const {
  return *encrypted_client_id_;
}
inline void EncryptedClientIdentification::set_encrypted_client_id(const ::std::string& value) {
  set_has_encrypted_client_id();
  if (encrypted_client_id_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_client_id_ = new ::std::string;
  }
  encrypted_client_id_->assign(value);
}
inline void EncryptedClientIdentification::set_encrypted_client_id(const char* value) {
  set_has_encrypted_client_id();
  if (encrypted_client_id_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_client_id_ = new ::std::string;
  }
  encrypted_client_id_->assign(value);
}
inline void EncryptedClientIdentification::set_encrypted_client_id(const void* value, size_t size) {
  set_has_encrypted_client_id();
  if (encrypted_client_id_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_client_id_ = new ::std::string;
  }
  encrypted_client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedClientIdentification::mutable_encrypted_client_id() {
  set_has_encrypted_client_id();
  if (encrypted_client_id_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_client_id_ = new ::std::string;
  }
  return encrypted_client_id_;
}
inline ::std::string* EncryptedClientIdentification::release_encrypted_client_id() {
  clear_has_encrypted_client_id();
  if (encrypted_client_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_client_id_;
    encrypted_client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptedClientIdentification::set_allocated_encrypted_client_id(::std::string* encrypted_client_id) {
  if (encrypted_client_id_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_client_id_;
  }
  if (encrypted_client_id) {
    set_has_encrypted_client_id();
    encrypted_client_id_ = encrypted_client_id;
  } else {
    clear_has_encrypted_client_id();
    encrypted_client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encrypted_client_id_iv = 4;
inline bool EncryptedClientIdentification::has_encrypted_client_id_iv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EncryptedClientIdentification::set_has_encrypted_client_id_iv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EncryptedClientIdentification::clear_has_encrypted_client_id_iv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EncryptedClientIdentification::clear_encrypted_client_id_iv() {
  if (encrypted_client_id_iv_ != &::google::protobuf::internal::kEmptyString) {
    encrypted_client_id_iv_->clear();
  }
  clear_has_encrypted_client_id_iv();
}
inline const ::std::string& EncryptedClientIdentification::encrypted_client_id_iv() const {
  return *encrypted_client_id_iv_;
}
inline void EncryptedClientIdentification::set_encrypted_client_id_iv(const ::std::string& value) {
  set_has_encrypted_client_id_iv();
  if (encrypted_client_id_iv_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_client_id_iv_ = new ::std::string;
  }
  encrypted_client_id_iv_->assign(value);
}
inline void EncryptedClientIdentification::set_encrypted_client_id_iv(const char* value) {
  set_has_encrypted_client_id_iv();
  if (encrypted_client_id_iv_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_client_id_iv_ = new ::std::string;
  }
  encrypted_client_id_iv_->assign(value);
}
inline void EncryptedClientIdentification::set_encrypted_client_id_iv(const void* value, size_t size) {
  set_has_encrypted_client_id_iv();
  if (encrypted_client_id_iv_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_client_id_iv_ = new ::std::string;
  }
  encrypted_client_id_iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedClientIdentification::mutable_encrypted_client_id_iv() {
  set_has_encrypted_client_id_iv();
  if (encrypted_client_id_iv_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_client_id_iv_ = new ::std::string;
  }
  return encrypted_client_id_iv_;
}
inline ::std::string* EncryptedClientIdentification::release_encrypted_client_id_iv() {
  clear_has_encrypted_client_id_iv();
  if (encrypted_client_id_iv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_client_id_iv_;
    encrypted_client_id_iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptedClientIdentification::set_allocated_encrypted_client_id_iv(::std::string* encrypted_client_id_iv) {
  if (encrypted_client_id_iv_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_client_id_iv_;
  }
  if (encrypted_client_id_iv) {
    set_has_encrypted_client_id_iv();
    encrypted_client_id_iv_ = encrypted_client_id_iv;
  } else {
    clear_has_encrypted_client_id_iv();
    encrypted_client_id_iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encrypted_privacy_key = 5;
inline bool EncryptedClientIdentification::has_encrypted_privacy_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EncryptedClientIdentification::set_has_encrypted_privacy_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EncryptedClientIdentification::clear_has_encrypted_privacy_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EncryptedClientIdentification::clear_encrypted_privacy_key() {
  if (encrypted_privacy_key_ != &::google::protobuf::internal::kEmptyString) {
    encrypted_privacy_key_->clear();
  }
  clear_has_encrypted_privacy_key();
}
inline const ::std::string& EncryptedClientIdentification::encrypted_privacy_key() const {
  return *encrypted_privacy_key_;
}
inline void EncryptedClientIdentification::set_encrypted_privacy_key(const ::std::string& value) {
  set_has_encrypted_privacy_key();
  if (encrypted_privacy_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_privacy_key_ = new ::std::string;
  }
  encrypted_privacy_key_->assign(value);
}
inline void EncryptedClientIdentification::set_encrypted_privacy_key(const char* value) {
  set_has_encrypted_privacy_key();
  if (encrypted_privacy_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_privacy_key_ = new ::std::string;
  }
  encrypted_privacy_key_->assign(value);
}
inline void EncryptedClientIdentification::set_encrypted_privacy_key(const void* value, size_t size) {
  set_has_encrypted_privacy_key();
  if (encrypted_privacy_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_privacy_key_ = new ::std::string;
  }
  encrypted_privacy_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedClientIdentification::mutable_encrypted_privacy_key() {
  set_has_encrypted_privacy_key();
  if (encrypted_privacy_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_privacy_key_ = new ::std::string;
  }
  return encrypted_privacy_key_;
}
inline ::std::string* EncryptedClientIdentification::release_encrypted_privacy_key() {
  clear_has_encrypted_privacy_key();
  if (encrypted_privacy_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_privacy_key_;
    encrypted_privacy_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptedClientIdentification::set_allocated_encrypted_privacy_key(::std::string* encrypted_privacy_key) {
  if (encrypted_privacy_key_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_privacy_key_;
  }
  if (encrypted_privacy_key) {
    set_has_encrypted_privacy_key();
    encrypted_privacy_key_ = encrypted_privacy_key;
  } else {
    clear_has_encrypted_privacy_key();
    encrypted_privacy_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DeviceCertificate

// optional .video_widevine_server.sdk.DeviceCertificate.CertificateType type = 1;
inline bool DeviceCertificate::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceCertificate::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceCertificate::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceCertificate::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::video_widevine_server::sdk::DeviceCertificate_CertificateType DeviceCertificate::type() const {
  return static_cast< ::video_widevine_server::sdk::DeviceCertificate_CertificateType >(type_);
}
inline void DeviceCertificate::set_type(::video_widevine_server::sdk::DeviceCertificate_CertificateType value) {
  assert(::video_widevine_server::sdk::DeviceCertificate_CertificateType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes serial_number = 2;
inline bool DeviceCertificate::has_serial_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceCertificate::set_has_serial_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceCertificate::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceCertificate::clear_serial_number() {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    serial_number_->clear();
  }
  clear_has_serial_number();
}
inline const ::std::string& DeviceCertificate::serial_number() const {
  return *serial_number_;
}
inline void DeviceCertificate::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void DeviceCertificate::set_serial_number(const char* value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void DeviceCertificate::set_serial_number(const void* value, size_t size) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceCertificate::mutable_serial_number() {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  return serial_number_;
}
inline ::std::string* DeviceCertificate::release_serial_number() {
  clear_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_number_;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceCertificate::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  if (serial_number) {
    set_has_serial_number();
    serial_number_ = serial_number;
  } else {
    clear_has_serial_number();
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 creation_time_seconds = 3;
inline bool DeviceCertificate::has_creation_time_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceCertificate::set_has_creation_time_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceCertificate::clear_has_creation_time_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceCertificate::clear_creation_time_seconds() {
  creation_time_seconds_ = 0u;
  clear_has_creation_time_seconds();
}
inline ::google::protobuf::uint32 DeviceCertificate::creation_time_seconds() const {
  return creation_time_seconds_;
}
inline void DeviceCertificate::set_creation_time_seconds(::google::protobuf::uint32 value) {
  set_has_creation_time_seconds();
  creation_time_seconds_ = value;
}

// optional bytes public_key = 4;
inline bool DeviceCertificate::has_public_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceCertificate::set_has_public_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceCertificate::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceCertificate::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& DeviceCertificate::public_key() const {
  return *public_key_;
}
inline void DeviceCertificate::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void DeviceCertificate::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void DeviceCertificate::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceCertificate::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* DeviceCertificate::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceCertificate::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 system_id = 5;
inline bool DeviceCertificate::has_system_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceCertificate::set_has_system_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceCertificate::clear_has_system_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceCertificate::clear_system_id() {
  system_id_ = 0u;
  clear_has_system_id();
}
inline ::google::protobuf::uint32 DeviceCertificate::system_id() const {
  return system_id_;
}
inline void DeviceCertificate::set_system_id(::google::protobuf::uint32 value) {
  set_has_system_id();
  system_id_ = value;
}

// optional bool test_device_deprecated = 6 [deprecated = true];
inline bool DeviceCertificate::has_test_device_deprecated() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceCertificate::set_has_test_device_deprecated() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceCertificate::clear_has_test_device_deprecated() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceCertificate::clear_test_device_deprecated() {
  test_device_deprecated_ = false;
  clear_has_test_device_deprecated();
}
inline bool DeviceCertificate::test_device_deprecated() const {
  return test_device_deprecated_;
}
inline void DeviceCertificate::set_test_device_deprecated(bool value) {
  set_has_test_device_deprecated();
  test_device_deprecated_ = value;
}

// optional string service_id = 7;
inline bool DeviceCertificate::has_service_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceCertificate::set_has_service_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeviceCertificate::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceCertificate::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& DeviceCertificate::service_id() const {
  return *service_id_;
}
inline void DeviceCertificate::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void DeviceCertificate::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void DeviceCertificate::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceCertificate::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* DeviceCertificate::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceCertificate::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignedDeviceCertificate

// optional bytes device_certificate = 1;
inline bool SignedDeviceCertificate::has_device_certificate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedDeviceCertificate::set_has_device_certificate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedDeviceCertificate::clear_has_device_certificate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedDeviceCertificate::clear_device_certificate() {
  if (device_certificate_ != &::google::protobuf::internal::kEmptyString) {
    device_certificate_->clear();
  }
  clear_has_device_certificate();
}
inline const ::std::string& SignedDeviceCertificate::device_certificate() const {
  return *device_certificate_;
}
inline void SignedDeviceCertificate::set_device_certificate(const ::std::string& value) {
  set_has_device_certificate();
  if (device_certificate_ == &::google::protobuf::internal::kEmptyString) {
    device_certificate_ = new ::std::string;
  }
  device_certificate_->assign(value);
}
inline void SignedDeviceCertificate::set_device_certificate(const char* value) {
  set_has_device_certificate();
  if (device_certificate_ == &::google::protobuf::internal::kEmptyString) {
    device_certificate_ = new ::std::string;
  }
  device_certificate_->assign(value);
}
inline void SignedDeviceCertificate::set_device_certificate(const void* value, size_t size) {
  set_has_device_certificate();
  if (device_certificate_ == &::google::protobuf::internal::kEmptyString) {
    device_certificate_ = new ::std::string;
  }
  device_certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedDeviceCertificate::mutable_device_certificate() {
  set_has_device_certificate();
  if (device_certificate_ == &::google::protobuf::internal::kEmptyString) {
    device_certificate_ = new ::std::string;
  }
  return device_certificate_;
}
inline ::std::string* SignedDeviceCertificate::release_device_certificate() {
  clear_has_device_certificate();
  if (device_certificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_certificate_;
    device_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedDeviceCertificate::set_allocated_device_certificate(::std::string* device_certificate) {
  if (device_certificate_ != &::google::protobuf::internal::kEmptyString) {
    delete device_certificate_;
  }
  if (device_certificate) {
    set_has_device_certificate();
    device_certificate_ = device_certificate;
  } else {
    clear_has_device_certificate();
    device_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signature = 2;
inline bool SignedDeviceCertificate::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedDeviceCertificate::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedDeviceCertificate::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedDeviceCertificate::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& SignedDeviceCertificate::signature() const {
  return *signature_;
}
inline void SignedDeviceCertificate::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedDeviceCertificate::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedDeviceCertificate::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedDeviceCertificate::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SignedDeviceCertificate::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedDeviceCertificate::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .video_widevine_server.sdk.SignedDeviceCertificate signer = 3;
inline bool SignedDeviceCertificate::has_signer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedDeviceCertificate::set_has_signer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedDeviceCertificate::clear_has_signer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedDeviceCertificate::clear_signer() {
  if (signer_ != NULL) signer_->::video_widevine_server::sdk::SignedDeviceCertificate::Clear();
  clear_has_signer();
}
inline const ::video_widevine_server::sdk::SignedDeviceCertificate& SignedDeviceCertificate::signer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return signer_ != NULL ? *signer_ : *default_instance().signer_;
#else
  return signer_ != NULL ? *signer_ : *default_instance_->signer_;
#endif
}
inline ::video_widevine_server::sdk::SignedDeviceCertificate* SignedDeviceCertificate::mutable_signer() {
  set_has_signer();
  if (signer_ == NULL) signer_ = new ::video_widevine_server::sdk::SignedDeviceCertificate;
  return signer_;
}
inline ::video_widevine_server::sdk::SignedDeviceCertificate* SignedDeviceCertificate::release_signer() {
  clear_has_signer();
  ::video_widevine_server::sdk::SignedDeviceCertificate* temp = signer_;
  signer_ = NULL;
  return temp;
}
inline void SignedDeviceCertificate::set_allocated_signer(::video_widevine_server::sdk::SignedDeviceCertificate* signer) {
  delete signer_;
  signer_ = signer;
  if (signer) {
    set_has_signer();
  } else {
    clear_has_signer();
  }
}

// -------------------------------------------------------------------

// ProvisionedDeviceInfo

// optional uint32 system_id = 1;
inline bool ProvisionedDeviceInfo::has_system_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProvisionedDeviceInfo::set_has_system_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProvisionedDeviceInfo::clear_has_system_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProvisionedDeviceInfo::clear_system_id() {
  system_id_ = 0u;
  clear_has_system_id();
}
inline ::google::protobuf::uint32 ProvisionedDeviceInfo::system_id() const {
  return system_id_;
}
inline void ProvisionedDeviceInfo::set_system_id(::google::protobuf::uint32 value) {
  set_has_system_id();
  system_id_ = value;
}

// optional string soc = 2;
inline bool ProvisionedDeviceInfo::has_soc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProvisionedDeviceInfo::set_has_soc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProvisionedDeviceInfo::clear_has_soc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProvisionedDeviceInfo::clear_soc() {
  if (soc_ != &::google::protobuf::internal::kEmptyString) {
    soc_->clear();
  }
  clear_has_soc();
}
inline const ::std::string& ProvisionedDeviceInfo::soc() const {
  return *soc_;
}
inline void ProvisionedDeviceInfo::set_soc(const ::std::string& value) {
  set_has_soc();
  if (soc_ == &::google::protobuf::internal::kEmptyString) {
    soc_ = new ::std::string;
  }
  soc_->assign(value);
}
inline void ProvisionedDeviceInfo::set_soc(const char* value) {
  set_has_soc();
  if (soc_ == &::google::protobuf::internal::kEmptyString) {
    soc_ = new ::std::string;
  }
  soc_->assign(value);
}
inline void ProvisionedDeviceInfo::set_soc(const char* value, size_t size) {
  set_has_soc();
  if (soc_ == &::google::protobuf::internal::kEmptyString) {
    soc_ = new ::std::string;
  }
  soc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProvisionedDeviceInfo::mutable_soc() {
  set_has_soc();
  if (soc_ == &::google::protobuf::internal::kEmptyString) {
    soc_ = new ::std::string;
  }
  return soc_;
}
inline ::std::string* ProvisionedDeviceInfo::release_soc() {
  clear_has_soc();
  if (soc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soc_;
    soc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProvisionedDeviceInfo::set_allocated_soc(::std::string* soc) {
  if (soc_ != &::google::protobuf::internal::kEmptyString) {
    delete soc_;
  }
  if (soc) {
    set_has_soc();
    soc_ = soc;
  } else {
    clear_has_soc();
    soc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string manufacturer = 3;
inline bool ProvisionedDeviceInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProvisionedDeviceInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProvisionedDeviceInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProvisionedDeviceInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& ProvisionedDeviceInfo::manufacturer() const {
  return *manufacturer_;
}
inline void ProvisionedDeviceInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void ProvisionedDeviceInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void ProvisionedDeviceInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProvisionedDeviceInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* ProvisionedDeviceInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProvisionedDeviceInfo::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (manufacturer) {
    set_has_manufacturer();
    manufacturer_ = manufacturer;
  } else {
    clear_has_manufacturer();
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string model = 4;
inline bool ProvisionedDeviceInfo::has_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProvisionedDeviceInfo::set_has_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProvisionedDeviceInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProvisionedDeviceInfo::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& ProvisionedDeviceInfo::model() const {
  return *model_;
}
inline void ProvisionedDeviceInfo::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void ProvisionedDeviceInfo::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void ProvisionedDeviceInfo::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProvisionedDeviceInfo::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* ProvisionedDeviceInfo::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProvisionedDeviceInfo::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_type = 5;
inline bool ProvisionedDeviceInfo::has_device_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProvisionedDeviceInfo::set_has_device_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProvisionedDeviceInfo::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProvisionedDeviceInfo::clear_device_type() {
  if (device_type_ != &::google::protobuf::internal::kEmptyString) {
    device_type_->clear();
  }
  clear_has_device_type();
}
inline const ::std::string& ProvisionedDeviceInfo::device_type() const {
  return *device_type_;
}
inline void ProvisionedDeviceInfo::set_device_type(const ::std::string& value) {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(value);
}
inline void ProvisionedDeviceInfo::set_device_type(const char* value) {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(value);
}
inline void ProvisionedDeviceInfo::set_device_type(const char* value, size_t size) {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProvisionedDeviceInfo::mutable_device_type() {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  return device_type_;
}
inline ::std::string* ProvisionedDeviceInfo::release_device_type() {
  clear_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_type_;
    device_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProvisionedDeviceInfo::set_allocated_device_type(::std::string* device_type) {
  if (device_type_ != &::google::protobuf::internal::kEmptyString) {
    delete device_type_;
  }
  if (device_type) {
    set_has_device_type();
    device_type_ = device_type;
  } else {
    clear_has_device_type();
    device_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 model_year = 6;
inline bool ProvisionedDeviceInfo::has_model_year() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProvisionedDeviceInfo::set_has_model_year() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProvisionedDeviceInfo::clear_has_model_year() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProvisionedDeviceInfo::clear_model_year() {
  model_year_ = 0u;
  clear_has_model_year();
}
inline ::google::protobuf::uint32 ProvisionedDeviceInfo::model_year() const {
  return model_year_;
}
inline void ProvisionedDeviceInfo::set_model_year(::google::protobuf::uint32 value) {
  set_has_model_year();
  model_year_ = value;
}

// optional .video_widevine_server.sdk.ProvisionedDeviceInfo.WvSecurityLevel security_level = 7 [default = LEVEL_UNSPECIFIED];
inline bool ProvisionedDeviceInfo::has_security_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProvisionedDeviceInfo::set_has_security_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProvisionedDeviceInfo::clear_has_security_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProvisionedDeviceInfo::clear_security_level() {
  security_level_ = 0;
  clear_has_security_level();
}
inline ::video_widevine_server::sdk::ProvisionedDeviceInfo_WvSecurityLevel ProvisionedDeviceInfo::security_level() const {
  return static_cast< ::video_widevine_server::sdk::ProvisionedDeviceInfo_WvSecurityLevel >(security_level_);
}
inline void ProvisionedDeviceInfo::set_security_level(::video_widevine_server::sdk::ProvisionedDeviceInfo_WvSecurityLevel value) {
  assert(::video_widevine_server::sdk::ProvisionedDeviceInfo_WvSecurityLevel_IsValid(value));
  set_has_security_level();
  security_level_ = value;
}

// optional bool test_device = 8 [default = false];
inline bool ProvisionedDeviceInfo::has_test_device() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProvisionedDeviceInfo::set_has_test_device() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProvisionedDeviceInfo::clear_has_test_device() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProvisionedDeviceInfo::clear_test_device() {
  test_device_ = false;
  clear_has_test_device();
}
inline bool ProvisionedDeviceInfo::test_device() const {
  return test_device_;
}
inline void ProvisionedDeviceInfo::set_test_device(bool value) {
  set_has_test_device();
  test_device_ = value;
}

// -------------------------------------------------------------------

// DeviceCertificateStatus

// optional bytes serial_number = 1;
inline bool DeviceCertificateStatus::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceCertificateStatus::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceCertificateStatus::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceCertificateStatus::clear_serial_number() {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    serial_number_->clear();
  }
  clear_has_serial_number();
}
inline const ::std::string& DeviceCertificateStatus::serial_number() const {
  return *serial_number_;
}
inline void DeviceCertificateStatus::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void DeviceCertificateStatus::set_serial_number(const char* value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void DeviceCertificateStatus::set_serial_number(const void* value, size_t size) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceCertificateStatus::mutable_serial_number() {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  return serial_number_;
}
inline ::std::string* DeviceCertificateStatus::release_serial_number() {
  clear_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_number_;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceCertificateStatus::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  if (serial_number) {
    set_has_serial_number();
    serial_number_ = serial_number;
  } else {
    clear_has_serial_number();
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .video_widevine_server.sdk.DeviceCertificateStatus.CertificateStatus status = 2 [default = VALID];
inline bool DeviceCertificateStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceCertificateStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceCertificateStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceCertificateStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::video_widevine_server::sdk::DeviceCertificateStatus_CertificateStatus DeviceCertificateStatus::status() const {
  return static_cast< ::video_widevine_server::sdk::DeviceCertificateStatus_CertificateStatus >(status_);
}
inline void DeviceCertificateStatus::set_status(::video_widevine_server::sdk::DeviceCertificateStatus_CertificateStatus value) {
  assert(::video_widevine_server::sdk::DeviceCertificateStatus_CertificateStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .video_widevine_server.sdk.ProvisionedDeviceInfo device_info = 4;
inline bool DeviceCertificateStatus::has_device_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceCertificateStatus::set_has_device_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceCertificateStatus::clear_has_device_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceCertificateStatus::clear_device_info() {
  if (device_info_ != NULL) device_info_->::video_widevine_server::sdk::ProvisionedDeviceInfo::Clear();
  clear_has_device_info();
}
inline const ::video_widevine_server::sdk::ProvisionedDeviceInfo& DeviceCertificateStatus::device_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_info_ != NULL ? *device_info_ : *default_instance().device_info_;
#else
  return device_info_ != NULL ? *device_info_ : *default_instance_->device_info_;
#endif
}
inline ::video_widevine_server::sdk::ProvisionedDeviceInfo* DeviceCertificateStatus::mutable_device_info() {
  set_has_device_info();
  if (device_info_ == NULL) device_info_ = new ::video_widevine_server::sdk::ProvisionedDeviceInfo;
  return device_info_;
}
inline ::video_widevine_server::sdk::ProvisionedDeviceInfo* DeviceCertificateStatus::release_device_info() {
  clear_has_device_info();
  ::video_widevine_server::sdk::ProvisionedDeviceInfo* temp = device_info_;
  device_info_ = NULL;
  return temp;
}
inline void DeviceCertificateStatus::set_allocated_device_info(::video_widevine_server::sdk::ProvisionedDeviceInfo* device_info) {
  delete device_info_;
  device_info_ = device_info;
  if (device_info) {
    set_has_device_info();
  } else {
    clear_has_device_info();
  }
}

// -------------------------------------------------------------------

// DeviceCertificateStatusList

// optional uint32 creation_time_seconds = 1;
inline bool DeviceCertificateStatusList::has_creation_time_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceCertificateStatusList::set_has_creation_time_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceCertificateStatusList::clear_has_creation_time_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceCertificateStatusList::clear_creation_time_seconds() {
  creation_time_seconds_ = 0u;
  clear_has_creation_time_seconds();
}
inline ::google::protobuf::uint32 DeviceCertificateStatusList::creation_time_seconds() const {
  return creation_time_seconds_;
}
inline void DeviceCertificateStatusList::set_creation_time_seconds(::google::protobuf::uint32 value) {
  set_has_creation_time_seconds();
  creation_time_seconds_ = value;
}

// repeated .video_widevine_server.sdk.DeviceCertificateStatus certificate_status = 2;
inline int DeviceCertificateStatusList::certificate_status_size() const {
  return certificate_status_.size();
}
inline void DeviceCertificateStatusList::clear_certificate_status() {
  certificate_status_.Clear();
}
inline const ::video_widevine_server::sdk::DeviceCertificateStatus& DeviceCertificateStatusList::certificate_status(int index) const {
  return certificate_status_.Get(index);
}
inline ::video_widevine_server::sdk::DeviceCertificateStatus* DeviceCertificateStatusList::mutable_certificate_status(int index) {
  return certificate_status_.Mutable(index);
}
inline ::video_widevine_server::sdk::DeviceCertificateStatus* DeviceCertificateStatusList::add_certificate_status() {
  return certificate_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::DeviceCertificateStatus >&
DeviceCertificateStatusList::certificate_status() const {
  return certificate_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::video_widevine_server::sdk::DeviceCertificateStatus >*
DeviceCertificateStatusList::mutable_certificate_status() {
  return &certificate_status_;
}

// -------------------------------------------------------------------

// SignedCertificateStatusList

// optional bytes certificate_status_list = 1;
inline bool SignedCertificateStatusList::has_certificate_status_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedCertificateStatusList::set_has_certificate_status_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedCertificateStatusList::clear_has_certificate_status_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedCertificateStatusList::clear_certificate_status_list() {
  if (certificate_status_list_ != &::google::protobuf::internal::kEmptyString) {
    certificate_status_list_->clear();
  }
  clear_has_certificate_status_list();
}
inline const ::std::string& SignedCertificateStatusList::certificate_status_list() const {
  return *certificate_status_list_;
}
inline void SignedCertificateStatusList::set_certificate_status_list(const ::std::string& value) {
  set_has_certificate_status_list();
  if (certificate_status_list_ == &::google::protobuf::internal::kEmptyString) {
    certificate_status_list_ = new ::std::string;
  }
  certificate_status_list_->assign(value);
}
inline void SignedCertificateStatusList::set_certificate_status_list(const char* value) {
  set_has_certificate_status_list();
  if (certificate_status_list_ == &::google::protobuf::internal::kEmptyString) {
    certificate_status_list_ = new ::std::string;
  }
  certificate_status_list_->assign(value);
}
inline void SignedCertificateStatusList::set_certificate_status_list(const void* value, size_t size) {
  set_has_certificate_status_list();
  if (certificate_status_list_ == &::google::protobuf::internal::kEmptyString) {
    certificate_status_list_ = new ::std::string;
  }
  certificate_status_list_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedCertificateStatusList::mutable_certificate_status_list() {
  set_has_certificate_status_list();
  if (certificate_status_list_ == &::google::protobuf::internal::kEmptyString) {
    certificate_status_list_ = new ::std::string;
  }
  return certificate_status_list_;
}
inline ::std::string* SignedCertificateStatusList::release_certificate_status_list() {
  clear_has_certificate_status_list();
  if (certificate_status_list_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certificate_status_list_;
    certificate_status_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedCertificateStatusList::set_allocated_certificate_status_list(::std::string* certificate_status_list) {
  if (certificate_status_list_ != &::google::protobuf::internal::kEmptyString) {
    delete certificate_status_list_;
  }
  if (certificate_status_list) {
    set_has_certificate_status_list();
    certificate_status_list_ = certificate_status_list;
  } else {
    clear_has_certificate_status_list();
    certificate_status_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signature = 2;
inline bool SignedCertificateStatusList::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedCertificateStatusList::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedCertificateStatusList::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedCertificateStatusList::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& SignedCertificateStatusList::signature() const {
  return *signature_;
}
inline void SignedCertificateStatusList::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedCertificateStatusList::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedCertificateStatusList::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedCertificateStatusList::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SignedCertificateStatusList::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedCertificateStatusList::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WidevineCencHeader

// optional .video_widevine_server.sdk.WidevineCencHeader.Algorithm algorithm = 1 [deprecated = true];
inline bool WidevineCencHeader::has_algorithm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WidevineCencHeader::set_has_algorithm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WidevineCencHeader::clear_has_algorithm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WidevineCencHeader::clear_algorithm() {
  algorithm_ = 0;
  clear_has_algorithm();
}
inline ::video_widevine_server::sdk::WidevineCencHeader_Algorithm WidevineCencHeader::algorithm() const {
  return static_cast< ::video_widevine_server::sdk::WidevineCencHeader_Algorithm >(algorithm_);
}
inline void WidevineCencHeader::set_algorithm(::video_widevine_server::sdk::WidevineCencHeader_Algorithm value) {
  assert(::video_widevine_server::sdk::WidevineCencHeader_Algorithm_IsValid(value));
  set_has_algorithm();
  algorithm_ = value;
}

// repeated bytes key_id = 2;
inline int WidevineCencHeader::key_id_size() const {
  return key_id_.size();
}
inline void WidevineCencHeader::clear_key_id() {
  key_id_.Clear();
}
inline const ::std::string& WidevineCencHeader::key_id(int index) const {
  return key_id_.Get(index);
}
inline ::std::string* WidevineCencHeader::mutable_key_id(int index) {
  return key_id_.Mutable(index);
}
inline void WidevineCencHeader::set_key_id(int index, const ::std::string& value) {
  key_id_.Mutable(index)->assign(value);
}
inline void WidevineCencHeader::set_key_id(int index, const char* value) {
  key_id_.Mutable(index)->assign(value);
}
inline void WidevineCencHeader::set_key_id(int index, const void* value, size_t size) {
  key_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidevineCencHeader::add_key_id() {
  return key_id_.Add();
}
inline void WidevineCencHeader::add_key_id(const ::std::string& value) {
  key_id_.Add()->assign(value);
}
inline void WidevineCencHeader::add_key_id(const char* value) {
  key_id_.Add()->assign(value);
}
inline void WidevineCencHeader::add_key_id(const void* value, size_t size) {
  key_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WidevineCencHeader::key_id() const {
  return key_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WidevineCencHeader::mutable_key_id() {
  return &key_id_;
}

// optional string provider = 3;
inline bool WidevineCencHeader::has_provider() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WidevineCencHeader::set_has_provider() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WidevineCencHeader::clear_has_provider() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WidevineCencHeader::clear_provider() {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    provider_->clear();
  }
  clear_has_provider();
}
inline const ::std::string& WidevineCencHeader::provider() const {
  return *provider_;
}
inline void WidevineCencHeader::set_provider(const ::std::string& value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void WidevineCencHeader::set_provider(const char* value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void WidevineCencHeader::set_provider(const char* value, size_t size) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidevineCencHeader::mutable_provider() {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  return provider_;
}
inline ::std::string* WidevineCencHeader::release_provider() {
  clear_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_;
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WidevineCencHeader::set_allocated_provider(::std::string* provider) {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_;
  }
  if (provider) {
    set_has_provider();
    provider_ = provider;
  } else {
    clear_has_provider();
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes content_id = 4;
inline bool WidevineCencHeader::has_content_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WidevineCencHeader::set_has_content_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WidevineCencHeader::clear_has_content_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WidevineCencHeader::clear_content_id() {
  if (content_id_ != &::google::protobuf::internal::kEmptyString) {
    content_id_->clear();
  }
  clear_has_content_id();
}
inline const ::std::string& WidevineCencHeader::content_id() const {
  return *content_id_;
}
inline void WidevineCencHeader::set_content_id(const ::std::string& value) {
  set_has_content_id();
  if (content_id_ == &::google::protobuf::internal::kEmptyString) {
    content_id_ = new ::std::string;
  }
  content_id_->assign(value);
}
inline void WidevineCencHeader::set_content_id(const char* value) {
  set_has_content_id();
  if (content_id_ == &::google::protobuf::internal::kEmptyString) {
    content_id_ = new ::std::string;
  }
  content_id_->assign(value);
}
inline void WidevineCencHeader::set_content_id(const void* value, size_t size) {
  set_has_content_id();
  if (content_id_ == &::google::protobuf::internal::kEmptyString) {
    content_id_ = new ::std::string;
  }
  content_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidevineCencHeader::mutable_content_id() {
  set_has_content_id();
  if (content_id_ == &::google::protobuf::internal::kEmptyString) {
    content_id_ = new ::std::string;
  }
  return content_id_;
}
inline ::std::string* WidevineCencHeader::release_content_id() {
  clear_has_content_id();
  if (content_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_id_;
    content_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WidevineCencHeader::set_allocated_content_id(::std::string* content_id) {
  if (content_id_ != &::google::protobuf::internal::kEmptyString) {
    delete content_id_;
  }
  if (content_id) {
    set_has_content_id();
    content_id_ = content_id;
  } else {
    clear_has_content_id();
    content_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string track_type_deprecated = 5;
inline bool WidevineCencHeader::has_track_type_deprecated() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WidevineCencHeader::set_has_track_type_deprecated() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WidevineCencHeader::clear_has_track_type_deprecated() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WidevineCencHeader::clear_track_type_deprecated() {
  if (track_type_deprecated_ != &::google::protobuf::internal::kEmptyString) {
    track_type_deprecated_->clear();
  }
  clear_has_track_type_deprecated();
}
inline const ::std::string& WidevineCencHeader::track_type_deprecated() const {
  return *track_type_deprecated_;
}
inline void WidevineCencHeader::set_track_type_deprecated(const ::std::string& value) {
  set_has_track_type_deprecated();
  if (track_type_deprecated_ == &::google::protobuf::internal::kEmptyString) {
    track_type_deprecated_ = new ::std::string;
  }
  track_type_deprecated_->assign(value);
}
inline void WidevineCencHeader::set_track_type_deprecated(const char* value) {
  set_has_track_type_deprecated();
  if (track_type_deprecated_ == &::google::protobuf::internal::kEmptyString) {
    track_type_deprecated_ = new ::std::string;
  }
  track_type_deprecated_->assign(value);
}
inline void WidevineCencHeader::set_track_type_deprecated(const char* value, size_t size) {
  set_has_track_type_deprecated();
  if (track_type_deprecated_ == &::google::protobuf::internal::kEmptyString) {
    track_type_deprecated_ = new ::std::string;
  }
  track_type_deprecated_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidevineCencHeader::mutable_track_type_deprecated() {
  set_has_track_type_deprecated();
  if (track_type_deprecated_ == &::google::protobuf::internal::kEmptyString) {
    track_type_deprecated_ = new ::std::string;
  }
  return track_type_deprecated_;
}
inline ::std::string* WidevineCencHeader::release_track_type_deprecated() {
  clear_has_track_type_deprecated();
  if (track_type_deprecated_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = track_type_deprecated_;
    track_type_deprecated_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WidevineCencHeader::set_allocated_track_type_deprecated(::std::string* track_type_deprecated) {
  if (track_type_deprecated_ != &::google::protobuf::internal::kEmptyString) {
    delete track_type_deprecated_;
  }
  if (track_type_deprecated) {
    set_has_track_type_deprecated();
    track_type_deprecated_ = track_type_deprecated;
  } else {
    clear_has_track_type_deprecated();
    track_type_deprecated_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string policy = 6 [deprecated = true];
inline bool WidevineCencHeader::has_policy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WidevineCencHeader::set_has_policy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WidevineCencHeader::clear_has_policy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WidevineCencHeader::clear_policy() {
  if (policy_ != &::google::protobuf::internal::kEmptyString) {
    policy_->clear();
  }
  clear_has_policy();
}
inline const ::std::string& WidevineCencHeader::policy() const {
  return *policy_;
}
inline void WidevineCencHeader::set_policy(const ::std::string& value) {
  set_has_policy();
  if (policy_ == &::google::protobuf::internal::kEmptyString) {
    policy_ = new ::std::string;
  }
  policy_->assign(value);
}
inline void WidevineCencHeader::set_policy(const char* value) {
  set_has_policy();
  if (policy_ == &::google::protobuf::internal::kEmptyString) {
    policy_ = new ::std::string;
  }
  policy_->assign(value);
}
inline void WidevineCencHeader::set_policy(const char* value, size_t size) {
  set_has_policy();
  if (policy_ == &::google::protobuf::internal::kEmptyString) {
    policy_ = new ::std::string;
  }
  policy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidevineCencHeader::mutable_policy() {
  set_has_policy();
  if (policy_ == &::google::protobuf::internal::kEmptyString) {
    policy_ = new ::std::string;
  }
  return policy_;
}
inline ::std::string* WidevineCencHeader::release_policy() {
  clear_has_policy();
  if (policy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = policy_;
    policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WidevineCencHeader::set_allocated_policy(::std::string* policy) {
  if (policy_ != &::google::protobuf::internal::kEmptyString) {
    delete policy_;
  }
  if (policy) {
    set_has_policy();
    policy_ = policy;
  } else {
    clear_has_policy();
    policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 crypto_period_index = 7;
inline bool WidevineCencHeader::has_crypto_period_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WidevineCencHeader::set_has_crypto_period_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WidevineCencHeader::clear_has_crypto_period_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WidevineCencHeader::clear_crypto_period_index() {
  crypto_period_index_ = 0u;
  clear_has_crypto_period_index();
}
inline ::google::protobuf::uint32 WidevineCencHeader::crypto_period_index() const {
  return crypto_period_index_;
}
inline void WidevineCencHeader::set_crypto_period_index(::google::protobuf::uint32 value) {
  set_has_crypto_period_index();
  crypto_period_index_ = value;
}

// optional bytes grouped_license = 8;
inline bool WidevineCencHeader::has_grouped_license() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WidevineCencHeader::set_has_grouped_license() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WidevineCencHeader::clear_has_grouped_license() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WidevineCencHeader::clear_grouped_license() {
  if (grouped_license_ != &::google::protobuf::internal::kEmptyString) {
    grouped_license_->clear();
  }
  clear_has_grouped_license();
}
inline const ::std::string& WidevineCencHeader::grouped_license() const {
  return *grouped_license_;
}
inline void WidevineCencHeader::set_grouped_license(const ::std::string& value) {
  set_has_grouped_license();
  if (grouped_license_ == &::google::protobuf::internal::kEmptyString) {
    grouped_license_ = new ::std::string;
  }
  grouped_license_->assign(value);
}
inline void WidevineCencHeader::set_grouped_license(const char* value) {
  set_has_grouped_license();
  if (grouped_license_ == &::google::protobuf::internal::kEmptyString) {
    grouped_license_ = new ::std::string;
  }
  grouped_license_->assign(value);
}
inline void WidevineCencHeader::set_grouped_license(const void* value, size_t size) {
  set_has_grouped_license();
  if (grouped_license_ == &::google::protobuf::internal::kEmptyString) {
    grouped_license_ = new ::std::string;
  }
  grouped_license_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidevineCencHeader::mutable_grouped_license() {
  set_has_grouped_license();
  if (grouped_license_ == &::google::protobuf::internal::kEmptyString) {
    grouped_license_ = new ::std::string;
  }
  return grouped_license_;
}
inline ::std::string* WidevineCencHeader::release_grouped_license() {
  clear_has_grouped_license();
  if (grouped_license_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = grouped_license_;
    grouped_license_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WidevineCencHeader::set_allocated_grouped_license(::std::string* grouped_license) {
  if (grouped_license_ != &::google::protobuf::internal::kEmptyString) {
    delete grouped_license_;
  }
  if (grouped_license) {
    set_has_grouped_license();
    grouped_license_ = grouped_license;
  } else {
    clear_has_grouped_license();
    grouped_license_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 protection_scheme = 9;
inline bool WidevineCencHeader::has_protection_scheme() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WidevineCencHeader::set_has_protection_scheme() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WidevineCencHeader::clear_has_protection_scheme() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WidevineCencHeader::clear_protection_scheme() {
  protection_scheme_ = 0u;
  clear_has_protection_scheme();
}
inline ::google::protobuf::uint32 WidevineCencHeader::protection_scheme() const {
  return protection_scheme_;
}
inline void WidevineCencHeader::set_protection_scheme(::google::protobuf::uint32 value) {
  set_has_protection_scheme();
  protection_scheme_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sdk
}  // namespace video_widevine_server

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_license_5fprotocol_2eproto__INCLUDED
