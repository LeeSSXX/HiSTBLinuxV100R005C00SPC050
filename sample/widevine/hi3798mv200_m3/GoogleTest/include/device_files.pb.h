// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: device_files.proto

#ifndef PROTOBUF_device_5ffiles_2eproto__INCLUDED
#define PROTOBUF_device_5ffiles_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace video_widevine_client {
namespace sdk {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_device_5ffiles_2eproto();
void protobuf_AssignDesc_device_5ffiles_2eproto();
void protobuf_ShutdownFile_device_5ffiles_2eproto();

class NameValue;
class DeviceCertificate;
class License;
class UsageInfo;
class UsageInfo_ProviderSession;
class HlsAttributes;
class File;
class HashedFile;

enum License_LicenseState {
  License_LicenseState_ACTIVE = 1,
  License_LicenseState_RELEASING = 2
};
bool License_LicenseState_IsValid(int value);
const License_LicenseState License_LicenseState_LicenseState_MIN = License_LicenseState_ACTIVE;
const License_LicenseState License_LicenseState_LicenseState_MAX = License_LicenseState_RELEASING;
const int License_LicenseState_LicenseState_ARRAYSIZE = License_LicenseState_LicenseState_MAX + 1;

enum HlsAttributes_Method {
  HlsAttributes_Method_AES_128 = 1,
  HlsAttributes_Method_SAMPLE_AES = 2
};
bool HlsAttributes_Method_IsValid(int value);
const HlsAttributes_Method HlsAttributes_Method_Method_MIN = HlsAttributes_Method_AES_128;
const HlsAttributes_Method HlsAttributes_Method_Method_MAX = HlsAttributes_Method_SAMPLE_AES;
const int HlsAttributes_Method_Method_ARRAYSIZE = HlsAttributes_Method_Method_MAX + 1;

enum File_FileType {
  File_FileType_DEVICE_CERTIFICATE = 1,
  File_FileType_LICENSE = 2,
  File_FileType_USAGE_INFO = 3,
  File_FileType_HLS_ATTRIBUTES = 4
};
bool File_FileType_IsValid(int value);
const File_FileType File_FileType_FileType_MIN = File_FileType_DEVICE_CERTIFICATE;
const File_FileType File_FileType_FileType_MAX = File_FileType_HLS_ATTRIBUTES;
const int File_FileType_FileType_ARRAYSIZE = File_FileType_FileType_MAX + 1;

enum File_FileVersion {
  File_FileVersion_VERSION_1 = 1
};
bool File_FileVersion_IsValid(int value);
const File_FileVersion File_FileVersion_FileVersion_MIN = File_FileVersion_VERSION_1;
const File_FileVersion File_FileVersion_FileVersion_MAX = File_FileVersion_VERSION_1;
const int File_FileVersion_FileVersion_ARRAYSIZE = File_FileVersion_FileVersion_MAX + 1;

// ===================================================================

class NameValue : public ::google::protobuf::MessageLite {
 public:
  NameValue();
  virtual ~NameValue();

  NameValue(const NameValue& from);

  inline NameValue& operator=(const NameValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const NameValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NameValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NameValue* other);

  // implements Message ----------------------------------------------

  NameValue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NameValue& from);
  void MergeFrom(const NameValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:video_widevine_client.sdk.NameValue)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_device_5ffiles_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_device_5ffiles_2eproto();
  #endif
  friend void protobuf_AssignDesc_device_5ffiles_2eproto();
  friend void protobuf_ShutdownFile_device_5ffiles_2eproto();

  void InitAsDefaultInstance();
  static NameValue* default_instance_;
};
// -------------------------------------------------------------------

class DeviceCertificate : public ::google::protobuf::MessageLite {
 public:
  DeviceCertificate();
  virtual ~DeviceCertificate();

  DeviceCertificate(const DeviceCertificate& from);

  inline DeviceCertificate& operator=(const DeviceCertificate& from) {
    CopyFrom(from);
    return *this;
  }

  static const DeviceCertificate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceCertificate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceCertificate* other);

  // implements Message ----------------------------------------------

  DeviceCertificate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceCertificate& from);
  void MergeFrom(const DeviceCertificate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes certificate = 1;
  inline bool has_certificate() const;
  inline void clear_certificate();
  static const int kCertificateFieldNumber = 1;
  inline const ::std::string& certificate() const;
  inline void set_certificate(const ::std::string& value);
  inline void set_certificate(const char* value);
  inline void set_certificate(const void* value, size_t size);
  inline ::std::string* mutable_certificate();
  inline ::std::string* release_certificate();
  inline void set_allocated_certificate(::std::string* certificate);

  // optional bytes wrapped_private_key = 2;
  inline bool has_wrapped_private_key() const;
  inline void clear_wrapped_private_key();
  static const int kWrappedPrivateKeyFieldNumber = 2;
  inline const ::std::string& wrapped_private_key() const;
  inline void set_wrapped_private_key(const ::std::string& value);
  inline void set_wrapped_private_key(const char* value);
  inline void set_wrapped_private_key(const void* value, size_t size);
  inline ::std::string* mutable_wrapped_private_key();
  inline ::std::string* release_wrapped_private_key();
  inline void set_allocated_wrapped_private_key(::std::string* wrapped_private_key);

  // @@protoc_insertion_point(class_scope:video_widevine_client.sdk.DeviceCertificate)
 private:
  inline void set_has_certificate();
  inline void clear_has_certificate();
  inline void set_has_wrapped_private_key();
  inline void clear_has_wrapped_private_key();

  ::std::string* certificate_;
  ::std::string* wrapped_private_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_device_5ffiles_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_device_5ffiles_2eproto();
  #endif
  friend void protobuf_AssignDesc_device_5ffiles_2eproto();
  friend void protobuf_ShutdownFile_device_5ffiles_2eproto();

  void InitAsDefaultInstance();
  static DeviceCertificate* default_instance_;
};
// -------------------------------------------------------------------

class License : public ::google::protobuf::MessageLite {
 public:
  License();
  virtual ~License();

  License(const License& from);

  inline License& operator=(const License& from) {
    CopyFrom(from);
    return *this;
  }

  static const License& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const License* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(License* other);

  // implements Message ----------------------------------------------

  License* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const License& from);
  void MergeFrom(const License& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef License_LicenseState LicenseState;
  static const LicenseState ACTIVE = License_LicenseState_ACTIVE;
  static const LicenseState RELEASING = License_LicenseState_RELEASING;
  static inline bool LicenseState_IsValid(int value) {
    return License_LicenseState_IsValid(value);
  }
  static const LicenseState LicenseState_MIN =
    License_LicenseState_LicenseState_MIN;
  static const LicenseState LicenseState_MAX =
    License_LicenseState_LicenseState_MAX;
  static const int LicenseState_ARRAYSIZE =
    License_LicenseState_LicenseState_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .video_widevine_client.sdk.License.LicenseState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::video_widevine_client::sdk::License_LicenseState state() const;
  inline void set_state(::video_widevine_client::sdk::License_LicenseState value);

  // optional bytes pssh_data = 2;
  inline bool has_pssh_data() const;
  inline void clear_pssh_data();
  static const int kPsshDataFieldNumber = 2;
  inline const ::std::string& pssh_data() const;
  inline void set_pssh_data(const ::std::string& value);
  inline void set_pssh_data(const char* value);
  inline void set_pssh_data(const void* value, size_t size);
  inline ::std::string* mutable_pssh_data();
  inline ::std::string* release_pssh_data();
  inline void set_allocated_pssh_data(::std::string* pssh_data);

  // optional bytes license_request = 3;
  inline bool has_license_request() const;
  inline void clear_license_request();
  static const int kLicenseRequestFieldNumber = 3;
  inline const ::std::string& license_request() const;
  inline void set_license_request(const ::std::string& value);
  inline void set_license_request(const char* value);
  inline void set_license_request(const void* value, size_t size);
  inline ::std::string* mutable_license_request();
  inline ::std::string* release_license_request();
  inline void set_allocated_license_request(::std::string* license_request);

  // optional bytes license = 4;
  inline bool has_license() const;
  inline void clear_license();
  static const int kLicenseFieldNumber = 4;
  inline const ::std::string& license() const;
  inline void set_license(const ::std::string& value);
  inline void set_license(const char* value);
  inline void set_license(const void* value, size_t size);
  inline ::std::string* mutable_license();
  inline ::std::string* release_license();
  inline void set_allocated_license(::std::string* license);

  // optional bytes renewal_request = 5;
  inline bool has_renewal_request() const;
  inline void clear_renewal_request();
  static const int kRenewalRequestFieldNumber = 5;
  inline const ::std::string& renewal_request() const;
  inline void set_renewal_request(const ::std::string& value);
  inline void set_renewal_request(const char* value);
  inline void set_renewal_request(const void* value, size_t size);
  inline ::std::string* mutable_renewal_request();
  inline ::std::string* release_renewal_request();
  inline void set_allocated_renewal_request(::std::string* renewal_request);

  // optional bytes renewal = 6;
  inline bool has_renewal() const;
  inline void clear_renewal();
  static const int kRenewalFieldNumber = 6;
  inline const ::std::string& renewal() const;
  inline void set_renewal(const ::std::string& value);
  inline void set_renewal(const char* value);
  inline void set_renewal(const void* value, size_t size);
  inline ::std::string* mutable_renewal();
  inline ::std::string* release_renewal();
  inline void set_allocated_renewal(::std::string* renewal);

  // optional bytes release_server_url = 7;
  inline bool has_release_server_url() const;
  inline void clear_release_server_url();
  static const int kReleaseServerUrlFieldNumber = 7;
  inline const ::std::string& release_server_url() const;
  inline void set_release_server_url(const ::std::string& value);
  inline void set_release_server_url(const char* value);
  inline void set_release_server_url(const void* value, size_t size);
  inline ::std::string* mutable_release_server_url();
  inline ::std::string* release_release_server_url();
  inline void set_allocated_release_server_url(::std::string* release_server_url);

  // optional int64 playback_start_time = 8 [default = 0];
  inline bool has_playback_start_time() const;
  inline void clear_playback_start_time();
  static const int kPlaybackStartTimeFieldNumber = 8;
  inline ::google::protobuf::int64 playback_start_time() const;
  inline void set_playback_start_time(::google::protobuf::int64 value);

  // optional int64 last_playback_time = 9 [default = 0];
  inline bool has_last_playback_time() const;
  inline void clear_last_playback_time();
  static const int kLastPlaybackTimeFieldNumber = 9;
  inline ::google::protobuf::int64 last_playback_time() const;
  inline void set_last_playback_time(::google::protobuf::int64 value);

  // repeated .video_widevine_client.sdk.NameValue app_parameters = 10;
  inline int app_parameters_size() const;
  inline void clear_app_parameters();
  static const int kAppParametersFieldNumber = 10;
  inline const ::video_widevine_client::sdk::NameValue& app_parameters(int index) const;
  inline ::video_widevine_client::sdk::NameValue* mutable_app_parameters(int index);
  inline ::video_widevine_client::sdk::NameValue* add_app_parameters();
  inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_client::sdk::NameValue >&
      app_parameters() const;
  inline ::google::protobuf::RepeatedPtrField< ::video_widevine_client::sdk::NameValue >*
      mutable_app_parameters();

  // @@protoc_insertion_point(class_scope:video_widevine_client.sdk.License)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_pssh_data();
  inline void clear_has_pssh_data();
  inline void set_has_license_request();
  inline void clear_has_license_request();
  inline void set_has_license();
  inline void clear_has_license();
  inline void set_has_renewal_request();
  inline void clear_has_renewal_request();
  inline void set_has_renewal();
  inline void clear_has_renewal();
  inline void set_has_release_server_url();
  inline void clear_has_release_server_url();
  inline void set_has_playback_start_time();
  inline void clear_has_playback_start_time();
  inline void set_has_last_playback_time();
  inline void clear_has_last_playback_time();

  ::std::string* pssh_data_;
  ::std::string* license_request_;
  ::std::string* license_;
  ::std::string* renewal_request_;
  ::std::string* renewal_;
  ::std::string* release_server_url_;
  ::google::protobuf::int64 playback_start_time_;
  ::google::protobuf::int64 last_playback_time_;
  ::google::protobuf::RepeatedPtrField< ::video_widevine_client::sdk::NameValue > app_parameters_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_device_5ffiles_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_device_5ffiles_2eproto();
  #endif
  friend void protobuf_AssignDesc_device_5ffiles_2eproto();
  friend void protobuf_ShutdownFile_device_5ffiles_2eproto();

  void InitAsDefaultInstance();
  static License* default_instance_;
};
// -------------------------------------------------------------------

class UsageInfo_ProviderSession : public ::google::protobuf::MessageLite {
 public:
  UsageInfo_ProviderSession();
  virtual ~UsageInfo_ProviderSession();

  UsageInfo_ProviderSession(const UsageInfo_ProviderSession& from);

  inline UsageInfo_ProviderSession& operator=(const UsageInfo_ProviderSession& from) {
    CopyFrom(from);
    return *this;
  }

  static const UsageInfo_ProviderSession& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UsageInfo_ProviderSession* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UsageInfo_ProviderSession* other);

  // implements Message ----------------------------------------------

  UsageInfo_ProviderSession* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UsageInfo_ProviderSession& from);
  void MergeFrom(const UsageInfo_ProviderSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional bytes license_request = 2;
  inline bool has_license_request() const;
  inline void clear_license_request();
  static const int kLicenseRequestFieldNumber = 2;
  inline const ::std::string& license_request() const;
  inline void set_license_request(const ::std::string& value);
  inline void set_license_request(const char* value);
  inline void set_license_request(const void* value, size_t size);
  inline ::std::string* mutable_license_request();
  inline ::std::string* release_license_request();
  inline void set_allocated_license_request(::std::string* license_request);

  // optional bytes license = 3;
  inline bool has_license() const;
  inline void clear_license();
  static const int kLicenseFieldNumber = 3;
  inline const ::std::string& license() const;
  inline void set_license(const ::std::string& value);
  inline void set_license(const char* value);
  inline void set_license(const void* value, size_t size);
  inline ::std::string* mutable_license();
  inline ::std::string* release_license();
  inline void set_allocated_license(::std::string* license);

  // optional bytes key_set_id = 4;
  inline bool has_key_set_id() const;
  inline void clear_key_set_id();
  static const int kKeySetIdFieldNumber = 4;
  inline const ::std::string& key_set_id() const;
  inline void set_key_set_id(const ::std::string& value);
  inline void set_key_set_id(const char* value);
  inline void set_key_set_id(const void* value, size_t size);
  inline ::std::string* mutable_key_set_id();
  inline ::std::string* release_key_set_id();
  inline void set_allocated_key_set_id(::std::string* key_set_id);

  // @@protoc_insertion_point(class_scope:video_widevine_client.sdk.UsageInfo.ProviderSession)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_license_request();
  inline void clear_has_license_request();
  inline void set_has_license();
  inline void clear_has_license();
  inline void set_has_key_set_id();
  inline void clear_has_key_set_id();

  ::std::string* token_;
  ::std::string* license_request_;
  ::std::string* license_;
  ::std::string* key_set_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_device_5ffiles_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_device_5ffiles_2eproto();
  #endif
  friend void protobuf_AssignDesc_device_5ffiles_2eproto();
  friend void protobuf_ShutdownFile_device_5ffiles_2eproto();

  void InitAsDefaultInstance();
  static UsageInfo_ProviderSession* default_instance_;
};
// -------------------------------------------------------------------

class UsageInfo : public ::google::protobuf::MessageLite {
 public:
  UsageInfo();
  virtual ~UsageInfo();

  UsageInfo(const UsageInfo& from);

  inline UsageInfo& operator=(const UsageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UsageInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UsageInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UsageInfo* other);

  // implements Message ----------------------------------------------

  UsageInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UsageInfo& from);
  void MergeFrom(const UsageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UsageInfo_ProviderSession ProviderSession;

  // accessors -------------------------------------------------------

  // repeated .video_widevine_client.sdk.UsageInfo.ProviderSession sessions = 1;
  inline int sessions_size() const;
  inline void clear_sessions();
  static const int kSessionsFieldNumber = 1;
  inline const ::video_widevine_client::sdk::UsageInfo_ProviderSession& sessions(int index) const;
  inline ::video_widevine_client::sdk::UsageInfo_ProviderSession* mutable_sessions(int index);
  inline ::video_widevine_client::sdk::UsageInfo_ProviderSession* add_sessions();
  inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_client::sdk::UsageInfo_ProviderSession >&
      sessions() const;
  inline ::google::protobuf::RepeatedPtrField< ::video_widevine_client::sdk::UsageInfo_ProviderSession >*
      mutable_sessions();

  // @@protoc_insertion_point(class_scope:video_widevine_client.sdk.UsageInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::video_widevine_client::sdk::UsageInfo_ProviderSession > sessions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_device_5ffiles_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_device_5ffiles_2eproto();
  #endif
  friend void protobuf_AssignDesc_device_5ffiles_2eproto();
  friend void protobuf_ShutdownFile_device_5ffiles_2eproto();

  void InitAsDefaultInstance();
  static UsageInfo* default_instance_;
};
// -------------------------------------------------------------------

class HlsAttributes : public ::google::protobuf::MessageLite {
 public:
  HlsAttributes();
  virtual ~HlsAttributes();

  HlsAttributes(const HlsAttributes& from);

  inline HlsAttributes& operator=(const HlsAttributes& from) {
    CopyFrom(from);
    return *this;
  }

  static const HlsAttributes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HlsAttributes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HlsAttributes* other);

  // implements Message ----------------------------------------------

  HlsAttributes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HlsAttributes& from);
  void MergeFrom(const HlsAttributes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef HlsAttributes_Method Method;
  static const Method AES_128 = HlsAttributes_Method_AES_128;
  static const Method SAMPLE_AES = HlsAttributes_Method_SAMPLE_AES;
  static inline bool Method_IsValid(int value) {
    return HlsAttributes_Method_IsValid(value);
  }
  static const Method Method_MIN =
    HlsAttributes_Method_Method_MIN;
  static const Method Method_MAX =
    HlsAttributes_Method_Method_MAX;
  static const int Method_ARRAYSIZE =
    HlsAttributes_Method_Method_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .video_widevine_client.sdk.HlsAttributes.Method method = 1;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 1;
  inline ::video_widevine_client::sdk::HlsAttributes_Method method() const;
  inline void set_method(::video_widevine_client::sdk::HlsAttributes_Method value);

  // optional bytes media_segment_iv = 2;
  inline bool has_media_segment_iv() const;
  inline void clear_media_segment_iv();
  static const int kMediaSegmentIvFieldNumber = 2;
  inline const ::std::string& media_segment_iv() const;
  inline void set_media_segment_iv(const ::std::string& value);
  inline void set_media_segment_iv(const char* value);
  inline void set_media_segment_iv(const void* value, size_t size);
  inline ::std::string* mutable_media_segment_iv();
  inline ::std::string* release_media_segment_iv();
  inline void set_allocated_media_segment_iv(::std::string* media_segment_iv);

  // @@protoc_insertion_point(class_scope:video_widevine_client.sdk.HlsAttributes)
 private:
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_media_segment_iv();
  inline void clear_has_media_segment_iv();

  ::std::string* media_segment_iv_;
  int method_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_device_5ffiles_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_device_5ffiles_2eproto();
  #endif
  friend void protobuf_AssignDesc_device_5ffiles_2eproto();
  friend void protobuf_ShutdownFile_device_5ffiles_2eproto();

  void InitAsDefaultInstance();
  static HlsAttributes* default_instance_;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::MessageLite {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }

  static const File& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const File* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(File* other);

  // implements Message ----------------------------------------------

  File* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef File_FileType FileType;
  static const FileType DEVICE_CERTIFICATE = File_FileType_DEVICE_CERTIFICATE;
  static const FileType LICENSE = File_FileType_LICENSE;
  static const FileType USAGE_INFO = File_FileType_USAGE_INFO;
  static const FileType HLS_ATTRIBUTES = File_FileType_HLS_ATTRIBUTES;
  static inline bool FileType_IsValid(int value) {
    return File_FileType_IsValid(value);
  }
  static const FileType FileType_MIN =
    File_FileType_FileType_MIN;
  static const FileType FileType_MAX =
    File_FileType_FileType_MAX;
  static const int FileType_ARRAYSIZE =
    File_FileType_FileType_ARRAYSIZE;

  typedef File_FileVersion FileVersion;
  static const FileVersion VERSION_1 = File_FileVersion_VERSION_1;
  static inline bool FileVersion_IsValid(int value) {
    return File_FileVersion_IsValid(value);
  }
  static const FileVersion FileVersion_MIN =
    File_FileVersion_FileVersion_MIN;
  static const FileVersion FileVersion_MAX =
    File_FileVersion_FileVersion_MAX;
  static const int FileVersion_ARRAYSIZE =
    File_FileVersion_FileVersion_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .video_widevine_client.sdk.File.FileType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::video_widevine_client::sdk::File_FileType type() const;
  inline void set_type(::video_widevine_client::sdk::File_FileType value);

  // optional .video_widevine_client.sdk.File.FileVersion version = 2 [default = VERSION_1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::video_widevine_client::sdk::File_FileVersion version() const;
  inline void set_version(::video_widevine_client::sdk::File_FileVersion value);

  // optional .video_widevine_client.sdk.DeviceCertificate device_certificate = 3;
  inline bool has_device_certificate() const;
  inline void clear_device_certificate();
  static const int kDeviceCertificateFieldNumber = 3;
  inline const ::video_widevine_client::sdk::DeviceCertificate& device_certificate() const;
  inline ::video_widevine_client::sdk::DeviceCertificate* mutable_device_certificate();
  inline ::video_widevine_client::sdk::DeviceCertificate* release_device_certificate();
  inline void set_allocated_device_certificate(::video_widevine_client::sdk::DeviceCertificate* device_certificate);

  // optional .video_widevine_client.sdk.License license = 4;
  inline bool has_license() const;
  inline void clear_license();
  static const int kLicenseFieldNumber = 4;
  inline const ::video_widevine_client::sdk::License& license() const;
  inline ::video_widevine_client::sdk::License* mutable_license();
  inline ::video_widevine_client::sdk::License* release_license();
  inline void set_allocated_license(::video_widevine_client::sdk::License* license);

  // optional .video_widevine_client.sdk.UsageInfo usage_info = 5;
  inline bool has_usage_info() const;
  inline void clear_usage_info();
  static const int kUsageInfoFieldNumber = 5;
  inline const ::video_widevine_client::sdk::UsageInfo& usage_info() const;
  inline ::video_widevine_client::sdk::UsageInfo* mutable_usage_info();
  inline ::video_widevine_client::sdk::UsageInfo* release_usage_info();
  inline void set_allocated_usage_info(::video_widevine_client::sdk::UsageInfo* usage_info);

  // optional .video_widevine_client.sdk.HlsAttributes hls_attributes = 6;
  inline bool has_hls_attributes() const;
  inline void clear_hls_attributes();
  static const int kHlsAttributesFieldNumber = 6;
  inline const ::video_widevine_client::sdk::HlsAttributes& hls_attributes() const;
  inline ::video_widevine_client::sdk::HlsAttributes* mutable_hls_attributes();
  inline ::video_widevine_client::sdk::HlsAttributes* release_hls_attributes();
  inline void set_allocated_hls_attributes(::video_widevine_client::sdk::HlsAttributes* hls_attributes);

  // @@protoc_insertion_point(class_scope:video_widevine_client.sdk.File)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_device_certificate();
  inline void clear_has_device_certificate();
  inline void set_has_license();
  inline void clear_has_license();
  inline void set_has_usage_info();
  inline void clear_has_usage_info();
  inline void set_has_hls_attributes();
  inline void clear_has_hls_attributes();

  int type_;
  int version_;
  ::video_widevine_client::sdk::DeviceCertificate* device_certificate_;
  ::video_widevine_client::sdk::License* license_;
  ::video_widevine_client::sdk::UsageInfo* usage_info_;
  ::video_widevine_client::sdk::HlsAttributes* hls_attributes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_device_5ffiles_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_device_5ffiles_2eproto();
  #endif
  friend void protobuf_AssignDesc_device_5ffiles_2eproto();
  friend void protobuf_ShutdownFile_device_5ffiles_2eproto();

  void InitAsDefaultInstance();
  static File* default_instance_;
};
// -------------------------------------------------------------------

class HashedFile : public ::google::protobuf::MessageLite {
 public:
  HashedFile();
  virtual ~HashedFile();

  HashedFile(const HashedFile& from);

  inline HashedFile& operator=(const HashedFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const HashedFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HashedFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HashedFile* other);

  // implements Message ----------------------------------------------

  HashedFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HashedFile& from);
  void MergeFrom(const HashedFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes file = 1;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 1;
  inline const ::std::string& file() const;
  inline void set_file(const ::std::string& value);
  inline void set_file(const char* value);
  inline void set_file(const void* value, size_t size);
  inline ::std::string* mutable_file();
  inline ::std::string* release_file();
  inline void set_allocated_file(::std::string* file);

  // optional bytes hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:video_widevine_client.sdk.HashedFile)
 private:
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_hash();
  inline void clear_has_hash();

  ::std::string* file_;
  ::std::string* hash_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_device_5ffiles_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_device_5ffiles_2eproto();
  #endif
  friend void protobuf_AssignDesc_device_5ffiles_2eproto();
  friend void protobuf_ShutdownFile_device_5ffiles_2eproto();

  void InitAsDefaultInstance();
  static HashedFile* default_instance_;
};
// ===================================================================


// ===================================================================

// NameValue

// optional string name = 1;
inline bool NameValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameValue::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameValue::name() const {
  return *name_;
}
inline void NameValue::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameValue::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameValue::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameValue::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameValue::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameValue::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool NameValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& NameValue::value() const {
  return *value_;
}
inline void NameValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* NameValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DeviceCertificate

// optional bytes certificate = 1;
inline bool DeviceCertificate::has_certificate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceCertificate::set_has_certificate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceCertificate::clear_has_certificate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceCertificate::clear_certificate() {
  if (certificate_ != &::google::protobuf::internal::kEmptyString) {
    certificate_->clear();
  }
  clear_has_certificate();
}
inline const ::std::string& DeviceCertificate::certificate() const {
  return *certificate_;
}
inline void DeviceCertificate::set_certificate(const ::std::string& value) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(value);
}
inline void DeviceCertificate::set_certificate(const char* value) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(value);
}
inline void DeviceCertificate::set_certificate(const void* value, size_t size) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceCertificate::mutable_certificate() {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  return certificate_;
}
inline ::std::string* DeviceCertificate::release_certificate() {
  clear_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certificate_;
    certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceCertificate::set_allocated_certificate(::std::string* certificate) {
  if (certificate_ != &::google::protobuf::internal::kEmptyString) {
    delete certificate_;
  }
  if (certificate) {
    set_has_certificate();
    certificate_ = certificate;
  } else {
    clear_has_certificate();
    certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes wrapped_private_key = 2;
inline bool DeviceCertificate::has_wrapped_private_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceCertificate::set_has_wrapped_private_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceCertificate::clear_has_wrapped_private_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceCertificate::clear_wrapped_private_key() {
  if (wrapped_private_key_ != &::google::protobuf::internal::kEmptyString) {
    wrapped_private_key_->clear();
  }
  clear_has_wrapped_private_key();
}
inline const ::std::string& DeviceCertificate::wrapped_private_key() const {
  return *wrapped_private_key_;
}
inline void DeviceCertificate::set_wrapped_private_key(const ::std::string& value) {
  set_has_wrapped_private_key();
  if (wrapped_private_key_ == &::google::protobuf::internal::kEmptyString) {
    wrapped_private_key_ = new ::std::string;
  }
  wrapped_private_key_->assign(value);
}
inline void DeviceCertificate::set_wrapped_private_key(const char* value) {
  set_has_wrapped_private_key();
  if (wrapped_private_key_ == &::google::protobuf::internal::kEmptyString) {
    wrapped_private_key_ = new ::std::string;
  }
  wrapped_private_key_->assign(value);
}
inline void DeviceCertificate::set_wrapped_private_key(const void* value, size_t size) {
  set_has_wrapped_private_key();
  if (wrapped_private_key_ == &::google::protobuf::internal::kEmptyString) {
    wrapped_private_key_ = new ::std::string;
  }
  wrapped_private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceCertificate::mutable_wrapped_private_key() {
  set_has_wrapped_private_key();
  if (wrapped_private_key_ == &::google::protobuf::internal::kEmptyString) {
    wrapped_private_key_ = new ::std::string;
  }
  return wrapped_private_key_;
}
inline ::std::string* DeviceCertificate::release_wrapped_private_key() {
  clear_has_wrapped_private_key();
  if (wrapped_private_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wrapped_private_key_;
    wrapped_private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceCertificate::set_allocated_wrapped_private_key(::std::string* wrapped_private_key) {
  if (wrapped_private_key_ != &::google::protobuf::internal::kEmptyString) {
    delete wrapped_private_key_;
  }
  if (wrapped_private_key) {
    set_has_wrapped_private_key();
    wrapped_private_key_ = wrapped_private_key;
  } else {
    clear_has_wrapped_private_key();
    wrapped_private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// License

// optional .video_widevine_client.sdk.License.LicenseState state = 1;
inline bool License::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void License::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void License::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void License::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::video_widevine_client::sdk::License_LicenseState License::state() const {
  return static_cast< ::video_widevine_client::sdk::License_LicenseState >(state_);
}
inline void License::set_state(::video_widevine_client::sdk::License_LicenseState value) {
  assert(::video_widevine_client::sdk::License_LicenseState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional bytes pssh_data = 2;
inline bool License::has_pssh_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void License::set_has_pssh_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void License::clear_has_pssh_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void License::clear_pssh_data() {
  if (pssh_data_ != &::google::protobuf::internal::kEmptyString) {
    pssh_data_->clear();
  }
  clear_has_pssh_data();
}
inline const ::std::string& License::pssh_data() const {
  return *pssh_data_;
}
inline void License::set_pssh_data(const ::std::string& value) {
  set_has_pssh_data();
  if (pssh_data_ == &::google::protobuf::internal::kEmptyString) {
    pssh_data_ = new ::std::string;
  }
  pssh_data_->assign(value);
}
inline void License::set_pssh_data(const char* value) {
  set_has_pssh_data();
  if (pssh_data_ == &::google::protobuf::internal::kEmptyString) {
    pssh_data_ = new ::std::string;
  }
  pssh_data_->assign(value);
}
inline void License::set_pssh_data(const void* value, size_t size) {
  set_has_pssh_data();
  if (pssh_data_ == &::google::protobuf::internal::kEmptyString) {
    pssh_data_ = new ::std::string;
  }
  pssh_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License::mutable_pssh_data() {
  set_has_pssh_data();
  if (pssh_data_ == &::google::protobuf::internal::kEmptyString) {
    pssh_data_ = new ::std::string;
  }
  return pssh_data_;
}
inline ::std::string* License::release_pssh_data() {
  clear_has_pssh_data();
  if (pssh_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pssh_data_;
    pssh_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License::set_allocated_pssh_data(::std::string* pssh_data) {
  if (pssh_data_ != &::google::protobuf::internal::kEmptyString) {
    delete pssh_data_;
  }
  if (pssh_data) {
    set_has_pssh_data();
    pssh_data_ = pssh_data;
  } else {
    clear_has_pssh_data();
    pssh_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes license_request = 3;
inline bool License::has_license_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void License::set_has_license_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void License::clear_has_license_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void License::clear_license_request() {
  if (license_request_ != &::google::protobuf::internal::kEmptyString) {
    license_request_->clear();
  }
  clear_has_license_request();
}
inline const ::std::string& License::license_request() const {
  return *license_request_;
}
inline void License::set_license_request(const ::std::string& value) {
  set_has_license_request();
  if (license_request_ == &::google::protobuf::internal::kEmptyString) {
    license_request_ = new ::std::string;
  }
  license_request_->assign(value);
}
inline void License::set_license_request(const char* value) {
  set_has_license_request();
  if (license_request_ == &::google::protobuf::internal::kEmptyString) {
    license_request_ = new ::std::string;
  }
  license_request_->assign(value);
}
inline void License::set_license_request(const void* value, size_t size) {
  set_has_license_request();
  if (license_request_ == &::google::protobuf::internal::kEmptyString) {
    license_request_ = new ::std::string;
  }
  license_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License::mutable_license_request() {
  set_has_license_request();
  if (license_request_ == &::google::protobuf::internal::kEmptyString) {
    license_request_ = new ::std::string;
  }
  return license_request_;
}
inline ::std::string* License::release_license_request() {
  clear_has_license_request();
  if (license_request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = license_request_;
    license_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License::set_allocated_license_request(::std::string* license_request) {
  if (license_request_ != &::google::protobuf::internal::kEmptyString) {
    delete license_request_;
  }
  if (license_request) {
    set_has_license_request();
    license_request_ = license_request;
  } else {
    clear_has_license_request();
    license_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes license = 4;
inline bool License::has_license() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void License::set_has_license() {
  _has_bits_[0] |= 0x00000008u;
}
inline void License::clear_has_license() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void License::clear_license() {
  if (license_ != &::google::protobuf::internal::kEmptyString) {
    license_->clear();
  }
  clear_has_license();
}
inline const ::std::string& License::license() const {
  return *license_;
}
inline void License::set_license(const ::std::string& value) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  license_->assign(value);
}
inline void License::set_license(const char* value) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  license_->assign(value);
}
inline void License::set_license(const void* value, size_t size) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  license_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License::mutable_license() {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  return license_;
}
inline ::std::string* License::release_license() {
  clear_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = license_;
    license_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License::set_allocated_license(::std::string* license) {
  if (license_ != &::google::protobuf::internal::kEmptyString) {
    delete license_;
  }
  if (license) {
    set_has_license();
    license_ = license;
  } else {
    clear_has_license();
    license_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes renewal_request = 5;
inline bool License::has_renewal_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void License::set_has_renewal_request() {
  _has_bits_[0] |= 0x00000010u;
}
inline void License::clear_has_renewal_request() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void License::clear_renewal_request() {
  if (renewal_request_ != &::google::protobuf::internal::kEmptyString) {
    renewal_request_->clear();
  }
  clear_has_renewal_request();
}
inline const ::std::string& License::renewal_request() const {
  return *renewal_request_;
}
inline void License::set_renewal_request(const ::std::string& value) {
  set_has_renewal_request();
  if (renewal_request_ == &::google::protobuf::internal::kEmptyString) {
    renewal_request_ = new ::std::string;
  }
  renewal_request_->assign(value);
}
inline void License::set_renewal_request(const char* value) {
  set_has_renewal_request();
  if (renewal_request_ == &::google::protobuf::internal::kEmptyString) {
    renewal_request_ = new ::std::string;
  }
  renewal_request_->assign(value);
}
inline void License::set_renewal_request(const void* value, size_t size) {
  set_has_renewal_request();
  if (renewal_request_ == &::google::protobuf::internal::kEmptyString) {
    renewal_request_ = new ::std::string;
  }
  renewal_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License::mutable_renewal_request() {
  set_has_renewal_request();
  if (renewal_request_ == &::google::protobuf::internal::kEmptyString) {
    renewal_request_ = new ::std::string;
  }
  return renewal_request_;
}
inline ::std::string* License::release_renewal_request() {
  clear_has_renewal_request();
  if (renewal_request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = renewal_request_;
    renewal_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License::set_allocated_renewal_request(::std::string* renewal_request) {
  if (renewal_request_ != &::google::protobuf::internal::kEmptyString) {
    delete renewal_request_;
  }
  if (renewal_request) {
    set_has_renewal_request();
    renewal_request_ = renewal_request;
  } else {
    clear_has_renewal_request();
    renewal_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes renewal = 6;
inline bool License::has_renewal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void License::set_has_renewal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void License::clear_has_renewal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void License::clear_renewal() {
  if (renewal_ != &::google::protobuf::internal::kEmptyString) {
    renewal_->clear();
  }
  clear_has_renewal();
}
inline const ::std::string& License::renewal() const {
  return *renewal_;
}
inline void License::set_renewal(const ::std::string& value) {
  set_has_renewal();
  if (renewal_ == &::google::protobuf::internal::kEmptyString) {
    renewal_ = new ::std::string;
  }
  renewal_->assign(value);
}
inline void License::set_renewal(const char* value) {
  set_has_renewal();
  if (renewal_ == &::google::protobuf::internal::kEmptyString) {
    renewal_ = new ::std::string;
  }
  renewal_->assign(value);
}
inline void License::set_renewal(const void* value, size_t size) {
  set_has_renewal();
  if (renewal_ == &::google::protobuf::internal::kEmptyString) {
    renewal_ = new ::std::string;
  }
  renewal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License::mutable_renewal() {
  set_has_renewal();
  if (renewal_ == &::google::protobuf::internal::kEmptyString) {
    renewal_ = new ::std::string;
  }
  return renewal_;
}
inline ::std::string* License::release_renewal() {
  clear_has_renewal();
  if (renewal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = renewal_;
    renewal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License::set_allocated_renewal(::std::string* renewal) {
  if (renewal_ != &::google::protobuf::internal::kEmptyString) {
    delete renewal_;
  }
  if (renewal) {
    set_has_renewal();
    renewal_ = renewal;
  } else {
    clear_has_renewal();
    renewal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes release_server_url = 7;
inline bool License::has_release_server_url() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void License::set_has_release_server_url() {
  _has_bits_[0] |= 0x00000040u;
}
inline void License::clear_has_release_server_url() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void License::clear_release_server_url() {
  if (release_server_url_ != &::google::protobuf::internal::kEmptyString) {
    release_server_url_->clear();
  }
  clear_has_release_server_url();
}
inline const ::std::string& License::release_server_url() const {
  return *release_server_url_;
}
inline void License::set_release_server_url(const ::std::string& value) {
  set_has_release_server_url();
  if (release_server_url_ == &::google::protobuf::internal::kEmptyString) {
    release_server_url_ = new ::std::string;
  }
  release_server_url_->assign(value);
}
inline void License::set_release_server_url(const char* value) {
  set_has_release_server_url();
  if (release_server_url_ == &::google::protobuf::internal::kEmptyString) {
    release_server_url_ = new ::std::string;
  }
  release_server_url_->assign(value);
}
inline void License::set_release_server_url(const void* value, size_t size) {
  set_has_release_server_url();
  if (release_server_url_ == &::google::protobuf::internal::kEmptyString) {
    release_server_url_ = new ::std::string;
  }
  release_server_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* License::mutable_release_server_url() {
  set_has_release_server_url();
  if (release_server_url_ == &::google::protobuf::internal::kEmptyString) {
    release_server_url_ = new ::std::string;
  }
  return release_server_url_;
}
inline ::std::string* License::release_release_server_url() {
  clear_has_release_server_url();
  if (release_server_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = release_server_url_;
    release_server_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void License::set_allocated_release_server_url(::std::string* release_server_url) {
  if (release_server_url_ != &::google::protobuf::internal::kEmptyString) {
    delete release_server_url_;
  }
  if (release_server_url) {
    set_has_release_server_url();
    release_server_url_ = release_server_url;
  } else {
    clear_has_release_server_url();
    release_server_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 playback_start_time = 8 [default = 0];
inline bool License::has_playback_start_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void License::set_has_playback_start_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void License::clear_has_playback_start_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void License::clear_playback_start_time() {
  playback_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_playback_start_time();
}
inline ::google::protobuf::int64 License::playback_start_time() const {
  return playback_start_time_;
}
inline void License::set_playback_start_time(::google::protobuf::int64 value) {
  set_has_playback_start_time();
  playback_start_time_ = value;
}

// optional int64 last_playback_time = 9 [default = 0];
inline bool License::has_last_playback_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void License::set_has_last_playback_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void License::clear_has_last_playback_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void License::clear_last_playback_time() {
  last_playback_time_ = GOOGLE_LONGLONG(0);
  clear_has_last_playback_time();
}
inline ::google::protobuf::int64 License::last_playback_time() const {
  return last_playback_time_;
}
inline void License::set_last_playback_time(::google::protobuf::int64 value) {
  set_has_last_playback_time();
  last_playback_time_ = value;
}

// repeated .video_widevine_client.sdk.NameValue app_parameters = 10;
inline int License::app_parameters_size() const {
  return app_parameters_.size();
}
inline void License::clear_app_parameters() {
  app_parameters_.Clear();
}
inline const ::video_widevine_client::sdk::NameValue& License::app_parameters(int index) const {
  return app_parameters_.Get(index);
}
inline ::video_widevine_client::sdk::NameValue* License::mutable_app_parameters(int index) {
  return app_parameters_.Mutable(index);
}
inline ::video_widevine_client::sdk::NameValue* License::add_app_parameters() {
  return app_parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_client::sdk::NameValue >&
License::app_parameters() const {
  return app_parameters_;
}
inline ::google::protobuf::RepeatedPtrField< ::video_widevine_client::sdk::NameValue >*
License::mutable_app_parameters() {
  return &app_parameters_;
}

// -------------------------------------------------------------------

// UsageInfo_ProviderSession

// optional bytes token = 1;
inline bool UsageInfo_ProviderSession::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsageInfo_ProviderSession::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UsageInfo_ProviderSession::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UsageInfo_ProviderSession::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UsageInfo_ProviderSession::token() const {
  return *token_;
}
inline void UsageInfo_ProviderSession::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UsageInfo_ProviderSession::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UsageInfo_ProviderSession::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UsageInfo_ProviderSession::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* UsageInfo_ProviderSession::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UsageInfo_ProviderSession::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes license_request = 2;
inline bool UsageInfo_ProviderSession::has_license_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsageInfo_ProviderSession::set_has_license_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UsageInfo_ProviderSession::clear_has_license_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UsageInfo_ProviderSession::clear_license_request() {
  if (license_request_ != &::google::protobuf::internal::kEmptyString) {
    license_request_->clear();
  }
  clear_has_license_request();
}
inline const ::std::string& UsageInfo_ProviderSession::license_request() const {
  return *license_request_;
}
inline void UsageInfo_ProviderSession::set_license_request(const ::std::string& value) {
  set_has_license_request();
  if (license_request_ == &::google::protobuf::internal::kEmptyString) {
    license_request_ = new ::std::string;
  }
  license_request_->assign(value);
}
inline void UsageInfo_ProviderSession::set_license_request(const char* value) {
  set_has_license_request();
  if (license_request_ == &::google::protobuf::internal::kEmptyString) {
    license_request_ = new ::std::string;
  }
  license_request_->assign(value);
}
inline void UsageInfo_ProviderSession::set_license_request(const void* value, size_t size) {
  set_has_license_request();
  if (license_request_ == &::google::protobuf::internal::kEmptyString) {
    license_request_ = new ::std::string;
  }
  license_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UsageInfo_ProviderSession::mutable_license_request() {
  set_has_license_request();
  if (license_request_ == &::google::protobuf::internal::kEmptyString) {
    license_request_ = new ::std::string;
  }
  return license_request_;
}
inline ::std::string* UsageInfo_ProviderSession::release_license_request() {
  clear_has_license_request();
  if (license_request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = license_request_;
    license_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UsageInfo_ProviderSession::set_allocated_license_request(::std::string* license_request) {
  if (license_request_ != &::google::protobuf::internal::kEmptyString) {
    delete license_request_;
  }
  if (license_request) {
    set_has_license_request();
    license_request_ = license_request;
  } else {
    clear_has_license_request();
    license_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes license = 3;
inline bool UsageInfo_ProviderSession::has_license() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsageInfo_ProviderSession::set_has_license() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UsageInfo_ProviderSession::clear_has_license() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UsageInfo_ProviderSession::clear_license() {
  if (license_ != &::google::protobuf::internal::kEmptyString) {
    license_->clear();
  }
  clear_has_license();
}
inline const ::std::string& UsageInfo_ProviderSession::license() const {
  return *license_;
}
inline void UsageInfo_ProviderSession::set_license(const ::std::string& value) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  license_->assign(value);
}
inline void UsageInfo_ProviderSession::set_license(const char* value) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  license_->assign(value);
}
inline void UsageInfo_ProviderSession::set_license(const void* value, size_t size) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  license_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UsageInfo_ProviderSession::mutable_license() {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  return license_;
}
inline ::std::string* UsageInfo_ProviderSession::release_license() {
  clear_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = license_;
    license_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UsageInfo_ProviderSession::set_allocated_license(::std::string* license) {
  if (license_ != &::google::protobuf::internal::kEmptyString) {
    delete license_;
  }
  if (license) {
    set_has_license();
    license_ = license;
  } else {
    clear_has_license();
    license_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes key_set_id = 4;
inline bool UsageInfo_ProviderSession::has_key_set_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsageInfo_ProviderSession::set_has_key_set_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UsageInfo_ProviderSession::clear_has_key_set_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UsageInfo_ProviderSession::clear_key_set_id() {
  if (key_set_id_ != &::google::protobuf::internal::kEmptyString) {
    key_set_id_->clear();
  }
  clear_has_key_set_id();
}
inline const ::std::string& UsageInfo_ProviderSession::key_set_id() const {
  return *key_set_id_;
}
inline void UsageInfo_ProviderSession::set_key_set_id(const ::std::string& value) {
  set_has_key_set_id();
  if (key_set_id_ == &::google::protobuf::internal::kEmptyString) {
    key_set_id_ = new ::std::string;
  }
  key_set_id_->assign(value);
}
inline void UsageInfo_ProviderSession::set_key_set_id(const char* value) {
  set_has_key_set_id();
  if (key_set_id_ == &::google::protobuf::internal::kEmptyString) {
    key_set_id_ = new ::std::string;
  }
  key_set_id_->assign(value);
}
inline void UsageInfo_ProviderSession::set_key_set_id(const void* value, size_t size) {
  set_has_key_set_id();
  if (key_set_id_ == &::google::protobuf::internal::kEmptyString) {
    key_set_id_ = new ::std::string;
  }
  key_set_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UsageInfo_ProviderSession::mutable_key_set_id() {
  set_has_key_set_id();
  if (key_set_id_ == &::google::protobuf::internal::kEmptyString) {
    key_set_id_ = new ::std::string;
  }
  return key_set_id_;
}
inline ::std::string* UsageInfo_ProviderSession::release_key_set_id() {
  clear_has_key_set_id();
  if (key_set_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_set_id_;
    key_set_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UsageInfo_ProviderSession::set_allocated_key_set_id(::std::string* key_set_id) {
  if (key_set_id_ != &::google::protobuf::internal::kEmptyString) {
    delete key_set_id_;
  }
  if (key_set_id) {
    set_has_key_set_id();
    key_set_id_ = key_set_id;
  } else {
    clear_has_key_set_id();
    key_set_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UsageInfo

// repeated .video_widevine_client.sdk.UsageInfo.ProviderSession sessions = 1;
inline int UsageInfo::sessions_size() const {
  return sessions_.size();
}
inline void UsageInfo::clear_sessions() {
  sessions_.Clear();
}
inline const ::video_widevine_client::sdk::UsageInfo_ProviderSession& UsageInfo::sessions(int index) const {
  return sessions_.Get(index);
}
inline ::video_widevine_client::sdk::UsageInfo_ProviderSession* UsageInfo::mutable_sessions(int index) {
  return sessions_.Mutable(index);
}
inline ::video_widevine_client::sdk::UsageInfo_ProviderSession* UsageInfo::add_sessions() {
  return sessions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::video_widevine_client::sdk::UsageInfo_ProviderSession >&
UsageInfo::sessions() const {
  return sessions_;
}
inline ::google::protobuf::RepeatedPtrField< ::video_widevine_client::sdk::UsageInfo_ProviderSession >*
UsageInfo::mutable_sessions() {
  return &sessions_;
}

// -------------------------------------------------------------------

// HlsAttributes

// optional .video_widevine_client.sdk.HlsAttributes.Method method = 1;
inline bool HlsAttributes::has_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HlsAttributes::set_has_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HlsAttributes::clear_has_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HlsAttributes::clear_method() {
  method_ = 1;
  clear_has_method();
}
inline ::video_widevine_client::sdk::HlsAttributes_Method HlsAttributes::method() const {
  return static_cast< ::video_widevine_client::sdk::HlsAttributes_Method >(method_);
}
inline void HlsAttributes::set_method(::video_widevine_client::sdk::HlsAttributes_Method value) {
  assert(::video_widevine_client::sdk::HlsAttributes_Method_IsValid(value));
  set_has_method();
  method_ = value;
}

// optional bytes media_segment_iv = 2;
inline bool HlsAttributes::has_media_segment_iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HlsAttributes::set_has_media_segment_iv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HlsAttributes::clear_has_media_segment_iv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HlsAttributes::clear_media_segment_iv() {
  if (media_segment_iv_ != &::google::protobuf::internal::kEmptyString) {
    media_segment_iv_->clear();
  }
  clear_has_media_segment_iv();
}
inline const ::std::string& HlsAttributes::media_segment_iv() const {
  return *media_segment_iv_;
}
inline void HlsAttributes::set_media_segment_iv(const ::std::string& value) {
  set_has_media_segment_iv();
  if (media_segment_iv_ == &::google::protobuf::internal::kEmptyString) {
    media_segment_iv_ = new ::std::string;
  }
  media_segment_iv_->assign(value);
}
inline void HlsAttributes::set_media_segment_iv(const char* value) {
  set_has_media_segment_iv();
  if (media_segment_iv_ == &::google::protobuf::internal::kEmptyString) {
    media_segment_iv_ = new ::std::string;
  }
  media_segment_iv_->assign(value);
}
inline void HlsAttributes::set_media_segment_iv(const void* value, size_t size) {
  set_has_media_segment_iv();
  if (media_segment_iv_ == &::google::protobuf::internal::kEmptyString) {
    media_segment_iv_ = new ::std::string;
  }
  media_segment_iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HlsAttributes::mutable_media_segment_iv() {
  set_has_media_segment_iv();
  if (media_segment_iv_ == &::google::protobuf::internal::kEmptyString) {
    media_segment_iv_ = new ::std::string;
  }
  return media_segment_iv_;
}
inline ::std::string* HlsAttributes::release_media_segment_iv() {
  clear_has_media_segment_iv();
  if (media_segment_iv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = media_segment_iv_;
    media_segment_iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HlsAttributes::set_allocated_media_segment_iv(::std::string* media_segment_iv) {
  if (media_segment_iv_ != &::google::protobuf::internal::kEmptyString) {
    delete media_segment_iv_;
  }
  if (media_segment_iv) {
    set_has_media_segment_iv();
    media_segment_iv_ = media_segment_iv;
  } else {
    clear_has_media_segment_iv();
    media_segment_iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// File

// optional .video_widevine_client.sdk.File.FileType type = 1;
inline bool File::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void File::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void File::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::video_widevine_client::sdk::File_FileType File::type() const {
  return static_cast< ::video_widevine_client::sdk::File_FileType >(type_);
}
inline void File::set_type(::video_widevine_client::sdk::File_FileType value) {
  assert(::video_widevine_client::sdk::File_FileType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .video_widevine_client.sdk.File.FileVersion version = 2 [default = VERSION_1];
inline bool File::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void File::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void File::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::video_widevine_client::sdk::File_FileVersion File::version() const {
  return static_cast< ::video_widevine_client::sdk::File_FileVersion >(version_);
}
inline void File::set_version(::video_widevine_client::sdk::File_FileVersion value) {
  assert(::video_widevine_client::sdk::File_FileVersion_IsValid(value));
  set_has_version();
  version_ = value;
}

// optional .video_widevine_client.sdk.DeviceCertificate device_certificate = 3;
inline bool File::has_device_certificate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void File::set_has_device_certificate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void File::clear_has_device_certificate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void File::clear_device_certificate() {
  if (device_certificate_ != NULL) device_certificate_->::video_widevine_client::sdk::DeviceCertificate::Clear();
  clear_has_device_certificate();
}
inline const ::video_widevine_client::sdk::DeviceCertificate& File::device_certificate() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_certificate_ != NULL ? *device_certificate_ : *default_instance().device_certificate_;
#else
  return device_certificate_ != NULL ? *device_certificate_ : *default_instance_->device_certificate_;
#endif
}
inline ::video_widevine_client::sdk::DeviceCertificate* File::mutable_device_certificate() {
  set_has_device_certificate();
  if (device_certificate_ == NULL) device_certificate_ = new ::video_widevine_client::sdk::DeviceCertificate;
  return device_certificate_;
}
inline ::video_widevine_client::sdk::DeviceCertificate* File::release_device_certificate() {
  clear_has_device_certificate();
  ::video_widevine_client::sdk::DeviceCertificate* temp = device_certificate_;
  device_certificate_ = NULL;
  return temp;
}
inline void File::set_allocated_device_certificate(::video_widevine_client::sdk::DeviceCertificate* device_certificate) {
  delete device_certificate_;
  device_certificate_ = device_certificate;
  if (device_certificate) {
    set_has_device_certificate();
  } else {
    clear_has_device_certificate();
  }
}

// optional .video_widevine_client.sdk.License license = 4;
inline bool File::has_license() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void File::set_has_license() {
  _has_bits_[0] |= 0x00000008u;
}
inline void File::clear_has_license() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void File::clear_license() {
  if (license_ != NULL) license_->::video_widevine_client::sdk::License::Clear();
  clear_has_license();
}
inline const ::video_widevine_client::sdk::License& File::license() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return license_ != NULL ? *license_ : *default_instance().license_;
#else
  return license_ != NULL ? *license_ : *default_instance_->license_;
#endif
}
inline ::video_widevine_client::sdk::License* File::mutable_license() {
  set_has_license();
  if (license_ == NULL) license_ = new ::video_widevine_client::sdk::License;
  return license_;
}
inline ::video_widevine_client::sdk::License* File::release_license() {
  clear_has_license();
  ::video_widevine_client::sdk::License* temp = license_;
  license_ = NULL;
  return temp;
}
inline void File::set_allocated_license(::video_widevine_client::sdk::License* license) {
  delete license_;
  license_ = license;
  if (license) {
    set_has_license();
  } else {
    clear_has_license();
  }
}

// optional .video_widevine_client.sdk.UsageInfo usage_info = 5;
inline bool File::has_usage_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void File::set_has_usage_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void File::clear_has_usage_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void File::clear_usage_info() {
  if (usage_info_ != NULL) usage_info_->::video_widevine_client::sdk::UsageInfo::Clear();
  clear_has_usage_info();
}
inline const ::video_widevine_client::sdk::UsageInfo& File::usage_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return usage_info_ != NULL ? *usage_info_ : *default_instance().usage_info_;
#else
  return usage_info_ != NULL ? *usage_info_ : *default_instance_->usage_info_;
#endif
}
inline ::video_widevine_client::sdk::UsageInfo* File::mutable_usage_info() {
  set_has_usage_info();
  if (usage_info_ == NULL) usage_info_ = new ::video_widevine_client::sdk::UsageInfo;
  return usage_info_;
}
inline ::video_widevine_client::sdk::UsageInfo* File::release_usage_info() {
  clear_has_usage_info();
  ::video_widevine_client::sdk::UsageInfo* temp = usage_info_;
  usage_info_ = NULL;
  return temp;
}
inline void File::set_allocated_usage_info(::video_widevine_client::sdk::UsageInfo* usage_info) {
  delete usage_info_;
  usage_info_ = usage_info;
  if (usage_info) {
    set_has_usage_info();
  } else {
    clear_has_usage_info();
  }
}

// optional .video_widevine_client.sdk.HlsAttributes hls_attributes = 6;
inline bool File::has_hls_attributes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void File::set_has_hls_attributes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void File::clear_has_hls_attributes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void File::clear_hls_attributes() {
  if (hls_attributes_ != NULL) hls_attributes_->::video_widevine_client::sdk::HlsAttributes::Clear();
  clear_has_hls_attributes();
}
inline const ::video_widevine_client::sdk::HlsAttributes& File::hls_attributes() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hls_attributes_ != NULL ? *hls_attributes_ : *default_instance().hls_attributes_;
#else
  return hls_attributes_ != NULL ? *hls_attributes_ : *default_instance_->hls_attributes_;
#endif
}
inline ::video_widevine_client::sdk::HlsAttributes* File::mutable_hls_attributes() {
  set_has_hls_attributes();
  if (hls_attributes_ == NULL) hls_attributes_ = new ::video_widevine_client::sdk::HlsAttributes;
  return hls_attributes_;
}
inline ::video_widevine_client::sdk::HlsAttributes* File::release_hls_attributes() {
  clear_has_hls_attributes();
  ::video_widevine_client::sdk::HlsAttributes* temp = hls_attributes_;
  hls_attributes_ = NULL;
  return temp;
}
inline void File::set_allocated_hls_attributes(::video_widevine_client::sdk::HlsAttributes* hls_attributes) {
  delete hls_attributes_;
  hls_attributes_ = hls_attributes;
  if (hls_attributes) {
    set_has_hls_attributes();
  } else {
    clear_has_hls_attributes();
  }
}

// -------------------------------------------------------------------

// HashedFile

// optional bytes file = 1;
inline bool HashedFile::has_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HashedFile::set_has_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HashedFile::clear_has_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HashedFile::clear_file() {
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    file_->clear();
  }
  clear_has_file();
}
inline const ::std::string& HashedFile::file() const {
  return *file_;
}
inline void HashedFile::set_file(const ::std::string& value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void HashedFile::set_file(const char* value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void HashedFile::set_file(const void* value, size_t size) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HashedFile::mutable_file() {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  return file_;
}
inline ::std::string* HashedFile::release_file() {
  clear_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HashedFile::set_allocated_file(::std::string* file) {
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    delete file_;
  }
  if (file) {
    set_has_file();
    file_ = file;
  } else {
    clear_has_file();
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes hash = 2;
inline bool HashedFile::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HashedFile::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HashedFile::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HashedFile::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& HashedFile::hash() const {
  return *hash_;
}
inline void HashedFile::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void HashedFile::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void HashedFile::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HashedFile::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* HashedFile::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HashedFile::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sdk
}  // namespace video_widevine_client

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_device_5ffiles_2eproto__INCLUDED
