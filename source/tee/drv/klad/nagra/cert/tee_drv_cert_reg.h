/******************************************************************************

Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
******************************************************************************
File Name     : tee_drv_cert_reg.h
Version       : Initial draft
Author        : Hisilicon hisecurity team
Created       : 2017-04-01
Last Modified :
Description   :
Function List :
History       :
******************************************************************************/
#ifndef __TEE_DRV_CERT_REG_H__
#define __TEE_DRV_CERT_REG_H__

#ifdef __cplusplus
extern "C"
{
#endif

    /*
    PrivilegedModeActivation  :OTP CONFIGURATION
    off:0x5f[4]
    width:4;
    value:
    	0xa:non-privileged mode
    	other: privileged mode

    akl_sec_en:AKL secure attribute configuration register, this register can only be accessed by Trustzone CPU.
    AKL secure flag¡£
    0: Key which is generated by AKL is an non-secure key.
    1: Key which is generated by AKL is a secure key.

    scene 1:
    PrivilegedModeActivation 0xa,  akl_sec_en 0  AKL:REE  KEY STORAGE:REE  CPU ACCESS: nomal CPU and trustzone CPU
    PrivilegedModeActivation 0xa,  akl_sec_en 1  AKL:TEE  KEY STORAGE:TEE  CPU ACCESS: trustzone CPU only
    PrivilegedModeActivation !0xa, akl_sec_en 1  AKL:TEE  KEY STORAGE:TEE  CPU ACCESS: trustzone CPU only
    PrivilegedModeActivation !0xa, akl_sec_en 0  AKL:TEE  KEY STORAGE:REE  CPU ACCESS: trustzone CPU only

    UNLOCK STATE:
    AKL:TEE, generate akl_lock_status 0x01 by REE CPU, 0x00 by trustzone CPU.
    AKL:REE, generate akl_lock_status 0x00 by REE CPU, 0x00 by trustzone CPU.

    LOCK BY REE CPU:

    */
#define AKL_LOCK_IDLE 0b00
#define AKL_REE_LOCKED 0b10
#define AKL_TEE_LOCKED 0b01

    typedef union
    {
        struct
        {
            HI_U32  cert_ip_err      : 1; /*[0]CERT IP error flag:
                                    0:no error
                                    1: generic error*/
            HI_U32  key_output       : 1; /*[1]Key Output Interface info
                                    0: no key pending on the bus
                                    1: key pending on the bus*/
            HI_U32  otp_recrd1_lock  : 1; /*[2]OTP Record 1 lock info
                                    0: not locked
                                    1: locked*/
            HI_U32  otp_recrd1_prog  : 1; /*[3]OTP Record 1 programming info
                                    0: virgin state
                                    1: non-virgin state*/
            HI_U32  otp_recrd1_authentication: 1;/*[4]OTP Record 1 authentication info
                                    0: authentication not passed
                                    1: authentication passed*/

            HI_U32  otp_recrd2_lock  : 1; /*[5]OTP Record 2 lock info
                                    0: not locked
                                    1: locked*/
            HI_U32  otp_recrd2_prog  : 1; /*[6]OTP Record 2 programming info
                                    0: virgin state
                                    1: non-virgin state*/
            HI_U32  otp_recrd2_authentication: 1;/*[7]OTP Record 2 authentication info
                                    0: authentication not passed
                                    1: authentication passed*/

            HI_U32  otp_recrd3_lock  : 1; /*[8]OTP Record 3 lock info
                                    0: not locked
                                    1: locked*/
            HI_U32  otp_recrd3_prog  : 1; /*[9]OTP Record 3 programming info
                                    0: virgin state
                                    1: non-virgin state*/
            HI_U32  otp_recrd3_authentication: 1;/*[10]OTP Record 3 authentication info
                                    0: authentication not passed
                                    1: authentication passed*/

            HI_U32  otp_recrd4_lock  : 1; /*[11]OTP Record 4 lock info
                                    0: not locked
                                    1: locked*/
            HI_U32  otp_recrd4_prog  : 1; /*[12]OTP Record 4 programming info
                                    0: virgin state
                                    1: non-virgin state*/
            HI_U32  otp_recrd4_authentication: 1;/*[13]OTP Record 4 authentication info
                                    0: authentication not passed
                                    1: authentication passed*/

            HI_U32  otp_prog_err     : 1; /*[14]OTP programming error (reported by OTP wrapper)
                                    0: no error
                                    1: error*/
            HI_U32  otp_read_err     : 1; /*[15]OTP read error (reported by OTP wrapper)
                                    0: no error
                                    1: error*/

            HI_U32  rev              : 16; /*[31:16]reserved*/
        } bits;
        HI_U32 u32;
    } CERT_AKL_STATUS_U;

    typedef union
    {
        struct
        {
            HI_U32  send_start       : 1;  /*[0]start the KeyCtrl module to send the key to its destination.
                                    AKL_SEND_CTRL register can config when send_start is 0.
                                        1'b0: idle;
                                        1'b1: start(busy).
                                        this bit is cleared to 0 when key transmission is completed.*/
            HI_U32  port_sel         : 2;  /*[2:1]destination selection.
                                        2'b00: DEMUX;
                                        2'b01: MTI_CIPHER;
                                        2'b10: PL_CIPHER;
                                        others: reserved.
                                        Note:
                                        for CSA2/CSA3/ASA-64/ASA-128, they can only be sent to DEMUX;
                                        for AES, it can be sent to DEMUX¡¢MTI_CIPHER or PL_CIPHER;
                                        for TDES, it can only be sent to DEMUX or MTI_CIPHER.*/
            HI_U32  rev1             : 1; /*[3]reserved*/
            HI_U32  key_addr         : 8;  /*[11:4] content key address.
                                        when port_sel is DEMUX,
                                        addr[11:5]: means the CW stored address.
                                        addr[4]: means even cw or odd cw.
                                          0: the current cw is even;
                                          1: the current cw is odd.
                                        when port_sel is PL_CIPHER,
                                        addr[11:5]: means the CW stored address.
                                        addr[4]: means even cw or odd cw.
                                          0: the current cw is even;
                                          1: the current cw is odd.
                                            for chipset hi3716mv420/421:
	                                            when port_sel is MCipher:
	                                             addr[6:4]: means the contentkey address in  Mcipher hardkey table.
	                                             addr[11:7]: reserved.
                                            for other chipset:
	                                            when port_sel is MCipher:
	                                            addr[11:5]: means the CW stored address.
	                                            addr[4]: means even cw or odd cw.
	                                              0: the current cw is even;
	                                              1: the current cw is odd.*/

            HI_U32  cw_type          : 8;  /*[19:12] content key algorithm type.
                                        when port_sel id DEMUX:
                                        8'h00: CSA2;
                                        8'h10: CSA3;
                                        8'h20: AES128 CBC,ATIS IIF Default Scrambling Algorithm (IDSA);
                                        8'h21: AES-128 ECB mode£¬Termination in clear;
                                        8'h22: AES128 CBC,IV modifiable,Termination in clear(CI+);
                                        8'h70: TDES-ABA CBC£¬All bits set to zero IV. DVS-042 termination;
                                        8'h71: TDES-ABA ECB£¬Termination in clear;
                                        8'h73: TDES-ABA CBC£¬IV modifiable£¬Termination in clear;
                                        8'h91: ASA-128;
                                        others: reserved.
                                        when port_sel id PL_CIPHER:
                                        8'h20: AES128 CBC,ATIS IIF Default Scrambling Algorithm (IDSA);
                                        8'h21: AES-128 ECB mode£¬Termination in clear;
                                        8'h22: AES128 CBC,IV modifiable,Termination in clear(CI+);
                                        others: reserved.
                                        when port_sel is MTI_CIPHER:
                                        8'h00: other algorithms;
                                        8'h10: NAGRA TDES;
                                        8'h11: NAGRA AES;
                                        others: reserved.*/
            HI_U32  rev2             : 12; /*[31:20]reserved*/
        } bits;
        HI_U32 u32;
    } CERT_AKL_SEND_CTL_U;

    typedef union
    {
        struct
        {
            HI_U32  akl_rst_req       : 1;
            HI_U32  rkp_rst_req       : 1;
            HI_U32  dbc_rst_req       : 1;
            HI_U32  hkl_rst_req       : 1;
            HI_U32  rev2             : 28;
        } bits;
        HI_U32 u32;
    } CA_RST_REQ_U;

    typedef union
    {
        struct
        {
            HI_U32  key_valid       : 1;   /*[0]*/
            HI_U32  akl_err         : 3;   /*[3:1]*/
            HI_U32  curr_st         : 4;   /*[7:4]*/
            HI_U32  reserved_1      : 4;   /*[11:8]*/
            HI_U32  sw_cfg_err      : 1;   /*[12]*/
            HI_U32  reserved_2      : 19;  /*[31:13]*/
        } bits;
        HI_U32 u32;
    } CERT_AKL_SEND_DBG_U;

    typedef union
    {
        struct
        {
            HI_U32  decrypt	    : 1; /*0*/
            HI_U32  mode	    : 3; /*3:1*/
            HI_U32  alg_sel	    : 2; /*5:4*/
            HI_U32  width       : 2; /*7:6*/
            HI_U32  ivin_sel    : 1; /*8*/
            HI_U32  key_length  : 2; /*10:9*/
            HI_U32  reserved    : 2; /*12:11*/
            HI_U32  key_sel     : 1; /*13*/
            HI_U32  key_adder   : 3; /*16:14*/
            HI_U32  reserved2   : 15; /*31:17*/
        } bits;
        HI_U32 u32;
    } CHAN_CIPHER_CTRL;

#define CERT_AKL_REG_BASE_ADDR_PHY          (0xF8AB9000)
#define CERT_AKL_REG_BASE_ADDR_LEN          (0X100)

#define CERT_KEY_CTL_REG_BASE_ADDR_PHY          (0xF8ABA000)
#define CERT_KEY_CTL_REG_BASE_ADDR_LEN          (0X1000)

#define CERT_HCPU_REG_BASE_ADDR_PHY          (0xF8AB4000)
#define CERT_HCPU_REG_BASE_ADDR_LEN          (0X300)

#define CERT_AKL_REG_BASE_ADDR                   CERT_AKL_REG_BASE_ADDR_PHY
#define CERT_KEY_CTL_REG_BASE_ADDR               CERT_KEY_CTL_REG_BASE_ADDR_PHY
#define CERT_HCPU_REG_BASE_ADDR                  CERT_HCPU_REG_BASE_ADDR_PHY

#define DATA_IN_0  (CERT_AKL_REG_BASE_ADDR + 0x0000) /*rw xst of Eight data input registers for the CERT IP, read/write, for a total of 256 bits.*/
#define DATA_IN_1  (CERT_AKL_REG_BASE_ADDR + 0x0004) /*rw*/
#define DATA_IN_2  (CERT_AKL_REG_BASE_ADDR + 0x0008) /*rw*/
#define DATA_IN_3  (CERT_AKL_REG_BASE_ADDR + 0x000C) /*rw*/
#define DATA_IN_4  (CERT_AKL_REG_BASE_ADDR + 0x0010) /*rw*/
#define DATA_IN_5  (CERT_AKL_REG_BASE_ADDR + 0x0014) /*rw*/
#define DATA_IN_6  (CERT_AKL_REG_BASE_ADDR + 0x0018) /*rw*/
#define DATA_IN_7  (CERT_AKL_REG_BASE_ADDR + 0x001C) /*rw*/

#define DATA_OUT_0 (CERT_AKL_REG_BASE_ADDR + 0x0020) /*ro xst of Eight data output registers for the CERT IP, read/write, for a total of 256 bits.*/
#define DATA_OUT_1 (CERT_AKL_REG_BASE_ADDR + 0x0024) /*ro*/
#define DATA_OUT_2 (CERT_AKL_REG_BASE_ADDR + 0x0028) /*ro*/
#define DATA_OUT_3 (CERT_AKL_REG_BASE_ADDR + 0x002C) /*ro*/
#define DATA_OUT_4 (CERT_AKL_REG_BASE_ADDR + 0x0030) /*ro*/
#define DATA_OUT_5 (CERT_AKL_REG_BASE_ADDR + 0x0034) /*ro*/
#define DATA_OUT_6 (CERT_AKL_REG_BASE_ADDR + 0x0038) /*ro*/
#define DATA_OUT_7 (CERT_AKL_REG_BASE_ADDR + 0x003C) /*ro*/

#define AKL_STATUS      (CERT_AKL_REG_BASE_ADDR + 0x0040) /*ro CERT IP status register*/
#define AKL_CAMMAND     (CERT_AKL_REG_BASE_ADDR + 0x0044) /*rw command register*/
#define AKL_INTERRUPT   (CERT_AKL_REG_BASE_ADDR + 0x0048) /*rw command register*/

#define AKL_KEY_SEND_DBG        (CERT_KEY_CTL_REG_BASE_ADDR + 0xB08) /*ro 'AKL KEY debug register */

#define AKL_KEY_SEND_CTRL       (CERT_AKL_REG_BASE_ADDR + 0x90) /*rw 'AKL KEY transmit control register */
#define AKL_KEY_SEND_NODE       (CERT_AKL_REG_BASE_ADDR + 0x94) /*rw 'AKL KEY transmit control register */
#define AKL_SEC_EN              (CERT_AKL_REG_BASE_ADDR + 0x84)
#define AKL_REG_INTERRUPT_EN    (CERT_AKL_REG_BASE_ADDR + 0x80)

    /*Before setting AKL to generate content key, TEE/REE CPU should firstly set akl_lock to 1,
    to let AKL to be in TEE lock or REE lock status.
    0: unlock AKL by TEE/REE CPU. Only when akl_lock_status = 2'b01, TEE CPU can set this bit to 0.
    Only when akl_lock_status = 2'b10, REE CPU can set this bit to 0.
    1: lock AKL by TEE/REE CPU. Only when akl_lock_status = 2'b00, TEE/REE CPU can set this bit to 1;*/
#define AKL_LOCK                (CERT_AKL_REG_BASE_ADDR + 0x100)
    /*Before setting AKL to generate content key, TEE/REE CPU should firstly set akl_lock to 1,
    to let AKL to be in TEE lock or REE lock status.
    2'b00: IDLE status, means both TEE/REE can use AKL.
    2'b01: TEE LOCK status, means only TEE can use AKL.
    2'b10: REE LOCK status, means only REE can use AKL.
    2'b11: invalid value, this value will not be occured.*/
#define AKL_LOCK_STATE          (CERT_AKL_REG_BASE_ADDR + 0x104)

#define CA_RST_REQ              (CERT_HCPU_REG_BASE_ADDR + 0x200)
#define CA_RST_REQ_LOCK         (CERT_HCPU_REG_BASE_ADDR + 0x204)

#ifdef HI_FPGA_SUPPORT
#define AKL_RNG_DATA0           (CERT_AKL_REG_BASE_ADDR + 0xf00)
#define AKL_RNG_DATA1           (CERT_AKL_REG_BASE_ADDR + 0xf04)
#define AKL_RNG_DATA2           (CERT_AKL_REG_BASE_ADDR + 0xf08)
#define AKL_RNG_DATA3           (CERT_AKL_REG_BASE_ADDR + 0xf0c)
#define AKL_RNG_DATA4           (CERT_AKL_REG_BASE_ADDR + 0xf10)
#define AKL_RNG_START           (CERT_AKL_REG_BASE_ADDR + 0xf14)
#endif

#ifdef __cplusplus
}
#endif
#endif /* end #ifndef __TEE_DRV_CERT_REG_H__ */

