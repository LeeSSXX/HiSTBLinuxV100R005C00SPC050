/*****************************************************************************
*              Copyright 2004 - 2016, Hisilicon Tech. Co., Ltd.
*                           ALL RIGHTS RESERVED
* FileName: engine_sink.c
* Description: Describe main functionality and purpose of this file.
*
* History:
* Version   Date         Author     DefectNum    Description
* 0.01
*
*****************************************************************************/
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string.h>
#include <dlfcn.h>

#include "drv_ao_ioctl.h"
#include "hi_drv_ao.h"
#include "hi_error_mpi.h"
#include "hi_mpi_ao.h"

#include "render_common.h"

#ifdef __cplusplus
#if __cplusplus
extern "C" {
#endif
#endif /* End of #ifdef __cplusplus */

#define trace()  HI_INFO_AO("%s called\n", __func__)

#define SDK_INTERFACE_NOT_SUPPORT   (1)

#define OUTPUT_TRACK_SLEEP_MS       (5 * 1000)
#define RENDERTRACKBUFLEVELMS       (65)
#define RENDERTRACKBUFTHRESHOLD     (30)
#define AOP_LOW_LATENCY_MS          (20)
#define AOP_NORMAL_LATENCY_MS       (40)
#define FIFO_BLOCK_MS               (32)
#define AIP_FIFO_LOW_LATENCY_MS     (12)
#define AIP_FIFO_NORMAL_LATENCY_MS  (40)
#define HBR_DATA_LENGTH             (0x6000)
#define LBR_DATA_LENGTH             (0x1800)
#define PCM_DATA_LENGTH             (0x1800)
#define BITS_BYTE_PER_FRAME         (0x60001800)
#define PCM_SAMPLES_PER_FRAME       (0x600)

typedef struct hiSink_MANAGER_S
{
    HI_HANDLE hSinkTrack;
    HI_HANDLE bExtTrackUsed;
    HI_BOOL   bCreated;

    HI_U32    u32ExtTrackBufThreshold;
    HI_U32    u32ExtTrackBufLevel;

    HI_BOOL   bFifoValid;
    HI_BOOL   bContinuousOutputEnable;
    HI_BOOL   bExtContinuousOutputCtl;

    ENGINE_MANAGER_S* pstEngineManager;
    SOURCE_MANAGER_S* pstSourceManager;
} SINK_MANAGER_S;

static SINK_MANAGER_S* g_pstSinkManager = HI_NULL;

static const HI_U16 g_ddp_heard[] =
{
    0xF872, 0x4E1F, 0x0015, 0x0600, 0x0B77, 0x02FF, 0x3F87, 0xE021, 0x0620, 0x0000,
    0x0002, 0x0000, 0x0007, 0xF941, 0x013E, 0xD408, 0x0808, 0x0802, 0x0202, 0x0200,
    0x8080, 0x8080, 0x2020, 0x2020, 0x0808, 0x0808, 0x31F3, 0xE7CF, 0x9F3E, 0x7CF9,
    0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCFBF, 0xE757,
    0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3,
    0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCFBF, 0xF9D5, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3,
    0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9,
    0xF3EF, 0xFE75, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9,
    0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CFB, 0xFF9D, 0x5F3E, 0x7CF9,
    0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C,
    0xF9F3, 0xE7CF, 0x9F3E, 0xFFE7, 0x57CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C,
    0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0xBFF9,
    0xD729, 0xE892, 0x49C7, 0x005F, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFF0,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0009, 0x148A, 0x4522, 0x9148, 0xA452, 0x2914,
    0x8A45, 0x22BF, 0xFFFF, 0xFFFF, 0xFFC0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0033, 0x3333, 0x3333, 0x3333, 0x3333, 0x3333, 0x332F, 0xFFFF,
    0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFF8, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0004,
    0x8A45, 0x2291, 0x48A4, 0x5229, 0x148A, 0x4522, 0x915F, 0xFFFF, 0xFFFF, 0xFFFF,
    0xFFFF, 0xFFFF, 0xFFF0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0009, 0x148A, 0x4522,
    0x9148, 0xA452, 0x2914, 0x8A45, 0x22BF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
    0xFFE0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0012, 0x2914, 0x8A45, 0x2291, 0x48A4,
    0x5229, 0x148A, 0x457F, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFC0, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0024, 0x5229, 0x148A, 0x4522, 0x9148, 0xA452, 0x2914,
    0x8AFE, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x4040, 0x5124, 0x9240, 0x4051, 0x2492, 0x4040,
    0x5124, 0x9240, 0x4051, 0x2492, 0x4040, 0x5124, 0x9200, 0x0000, 0x0000, 0x0000,
    0x5FD0, 0xFAC2,
};

static const HI_U16 g_dd_heard[] =
{
    0xF872, 0x4E1F, 0x0001, 0x5000, 0x0B77, 0x0BF5, 0x2430, 0xE1FC, 0x04C0, 0x3F01,
    0x955D, 0x1451, 0x451F, 0xF3AB, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C,
    0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E,
    0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xC99E,
    0xC373, 0xFFCE, 0xAF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F,
    0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF,
    0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F29, 0x86E9, 0x37FF,
    0x3ABE, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7,
    0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3,
    0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xA5F4, 0x373F, 0xFCEA, 0xF9F3,
    0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9,
    0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C,
    0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF267, 0x4A6B, 0x7FF3, 0xABE7, 0xCF9F, 0x3E7C,
    0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E,
    0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F,
    0x3E7C, 0xF9F3, 0xE7CA, 0x9325, 0x7DFF, 0xCEB9, 0x4F8E, 0x2448, 0x9122, 0x4400,
    0x0000, 0x0007, 0x78F1, 0xE3C7, 0x7777, 0x7777, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0EEE, 0xEEED,
    0xB6DB, 0x6DB6, 0xF9F3, 0x5AD6, 0xB5AD, 0x6BE7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF,
    0x9F3E, 0x7CF9, 0xF000, 0x0000, 0x00EF, 0x1E3C, 0x78EE, 0xEEEE, 0xEEE0, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0001, 0xDDDD, 0xDDB6, 0xDB6D, 0xB6DF, 0x3E6B, 0x5AD6, 0xB5AD, 0x7CF9, 0xF3E7,
    0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x0000, 0x0000, 0x1DE3, 0xC78F, 0x1DDD,
    0xDDDD, 0xDC00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x003B, 0xBBBB, 0xB6DB, 0x6DB6, 0xDBE7, 0xCD6B, 0x5AD6,
    0xB5AF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7C0, 0x0000, 0x0003,
    0xBC78, 0xF1E3, 0xBBBB, 0xBBBB, 0x8000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0777, 0x7776, 0xDB6D, 0xB6DB,
    0x7CF9, 0xAD6B, 0x5AD6, 0xB5F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C,
    0xF800, 0x0000, 0x0077, 0x8F1E, 0x3C77, 0x7777, 0x7770, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xEEEE,
    0xEEDB, 0x6DB6, 0xDB6F, 0x9F35, 0xAD6B, 0x5AD6, 0xBE7C, 0xF9F3, 0xE7CF, 0x9F3E,
    0x7CF9, 0xF3E7, 0xCF9F, 0x0000, 0x0000, 0x0EF0, 0x1F80, 0x8000, 0x0000, 0x0000,
    0x0EF1, 0xE3C7, 0x8EEE, 0xEEEE, 0xEE00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x001D, 0xDDDD, 0xDB6D, 0xB6DB,
    0x6DF3, 0xE6B5, 0xAD6B, 0x5AD7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9,
    0xF3E0, 0x0000, 0x0001, 0xDE3C, 0x78F1, 0xDDDD, 0xDDDD, 0xC000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03BB,
    0xBBBB, 0x6DB6, 0xDB6D, 0xBE7C, 0xD6B5, 0xAD6B, 0x5AF9, 0xF3E7, 0xCF9F, 0x3E7C,
    0xF9F3, 0xE7CF, 0x9F3E, 0x7C00, 0x0000, 0x003B, 0xC78F, 0x1E3B, 0xBBBB, 0xBBB8,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x7777, 0x776D, 0xB6DB, 0x6DB7, 0xCF9A, 0xD6B5, 0xAD6B, 0x5F3E,
    0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x8000, 0x0000, 0x0778, 0xF1E3,
    0xC777, 0x7777, 0x7700, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x000E, 0xEEEE, 0xEDB6, 0xDB6D, 0xB6F9, 0xF35A,
    0xD6B5, 0xAD6B, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F0, 0x0000,
    0x0000, 0xEF1E, 0x3C78, 0xEEEE, 0xEEEE, 0xE000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x01DD, 0xDDDD, 0xB6DB,
    0x6DB6, 0xDF3E, 0x6B5A, 0xD6B5, 0xAD7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7,
    0xCF9F, 0x3E00, 0x0000, 0x001D, 0xE03F, 0x0100, 0x0000, 0x0000, 0x001D, 0xE3C7,
    0x8F1D, 0xDDDD, 0xDDDC, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3BBB, 0xBBB6, 0xDB6D, 0xB6DB, 0xE7CD,
    0x6B5A, 0xD6B5, 0xAF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xC000,
    0x0000, 0x03BC, 0x78F1, 0xE3BB, 0xBBBB, 0xBB80, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0007, 0x7777, 0x76DB,
    0x6DB6, 0xDB7C, 0xF9AD, 0x6B5A, 0xD6B5, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF,
    0x9F3E, 0x7CF8, 0x0000, 0x0000, 0x778F, 0x1E3C, 0x7777, 0x7777, 0x7000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x00EE, 0xEEEE, 0xDB6D, 0xB6DB, 0x6F9F, 0x35AD, 0x6B5A, 0xD6BE, 0x7CF9, 0xF3E7,
    0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F00, 0x0000, 0x000E, 0xF1E3, 0xC78E, 0xEEEE,
    0xEEEE, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x1DDD, 0xDDDB, 0x6DB6, 0xDB6D, 0xF3E6, 0xB5AD, 0x6B5A,
    0xD7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE000, 0x0000, 0x01DE,
    0x3C78, 0xF1DD, 0xDDDD, 0xDDC0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0003, 0xBBBB, 0xBB6D, 0xB6DB, 0x6DBE,
    0x7CD6, 0xB5AD, 0x6B5A, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C,
    0x0000, 0x0000, 0x3BC0, 0x7E02, 0x0002, 0x3300, 0xBB23, 0x994F, 0xFC21, 0x1A47,
    0x7AFF, 0x7198, 0xA5EF, 0x8CF2, 0xED20, 0x5D05, 0xC2C1, 0xD282, 0x9404, 0xDC17,
    0xD318, 0x6C75, 0xEE2C, 0x704C, 0x5772, 0xDA4C, 0x7D19, 0x9826, 0xD051, 0x9C88,
    0xC049, 0x0000, 0x0000, 0x1DE3, 0xC78F, 0x1DDD, 0xDDDD, 0xDC00, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x003B,
    0xBBBB, 0xB6DB, 0x6DB6, 0xDBE7, 0xCD6B, 0x5AD6, 0xB5AF, 0x9F3E, 0x7CF9, 0xF3E7,
    0xCF9F, 0x3E7C, 0xF9F3, 0xE7C0, 0x0000, 0x0003, 0xBC78, 0xF1E3, 0xBBBB, 0xBBBB,
    0x8000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0777, 0x7776, 0xDB6D, 0xB6DB, 0x7CF9, 0xAD6B, 0x5AD6, 0xB5F3,
    0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF800, 0x0000, 0x0077, 0x8F1E,
    0x3C77, 0x7777, 0x7770, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xEEEE, 0xEEDB, 0x6DB6, 0xDB6F, 0x9F35,
    0xAD6B, 0x5AD6, 0xBE7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x0000,
    0x0000, 0x0EF1, 0xE3C7, 0x8EEE, 0xEEEE, 0xEE00, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x001D, 0xDDDD, 0xDB6D,
    0xB6DB, 0x6DF3, 0xE6B5, 0xAD6B, 0x5AD7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E,
    0x7CF9, 0xF3E0, 0x0000, 0x0001, 0xDE3C, 0x78F1, 0xDDDD, 0xDDDD, 0xC000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x03BB, 0xBBBB, 0x6DB6, 0xDB6D, 0xBE7C, 0xD6B5, 0xAD6B, 0x5AF9, 0xF3E7, 0xCF9F,
    0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7C00, 0x0000, 0x003B, 0xC07E, 0x0200, 0x0258,
    0x00D4, 0x23BD, 0x3331, 0xA737, 0x3EA4, 0xC49E, 0x991B, 0x2B62, 0x7688, 0x8AF3,
    0x04D9, 0x92C1, 0x7200, 0xF33C, 0xF2EB, 0x5DD4, 0xB38C, 0x80F9, 0xE4D1, 0x0D1B,
    0xB7AB, 0xB2AA, 0x5B0B, 0x2015, 0xFFDF, 0x07CE, 0xD519, 0x1744, 0x0CA7, 0x01E7,
    0xD47B, 0x7327, 0x5C83, 0x1E74, 0xD6B0, 0xB23E, 0x71F3, 0xDFF5, 0x5C3A, 0x5609,
    0xC977, 0xC5EA, 0xE798, 0xDD08, 0x0000, 0x0000, 0x1DE3, 0xC78F, 0x1DDD, 0xDDDD,
    0xDC00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x003B, 0xBBBB, 0xB6DB, 0x6DB6, 0xDBE7, 0xCD6B, 0x5AD6, 0xB5AF,
    0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7C0, 0x0000, 0x0003, 0xBC78,
    0xF1E3, 0xBBBB, 0xBBBB, 0x8000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0777, 0x7776, 0xDB6D, 0xB6DB, 0x7CF9,
    0xAD6B, 0x5AD6, 0xB5F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF800,
    0x0000, 0x0077, 0x8F1E, 0x3C77, 0x7777, 0x7770, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xEEEE, 0xEEDB,
    0x6DB6, 0xDB6F, 0x9F35, 0xAD6B, 0x5AD6, 0xBE7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9,
    0xF3E7, 0xCF9F, 0x0000, 0x0000, 0x0EF1, 0xE3C7, 0x8EEE, 0xEEEE, 0xEE00, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x001D, 0xDDDD, 0xDB6D, 0xB6DB, 0x6DF3, 0xE6B5, 0xAD6B, 0x5AD7, 0xCF9F, 0x3E7C,
    0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E0, 0x0000, 0x0001, 0xDE3C, 0x78F1, 0xDDDD,
    0xDDDD, 0xC000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x03BB, 0xBBBB, 0x6DB6, 0xDB6D, 0xBE7C, 0xD6B5, 0xAD6B,
    0x5AF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7C00, 0x0000, 0x003B,
    0xC07E, 0x0200, 0x0257, 0x00E5, 0x8F4E, 0xD3F5, 0x4AC8, 0xBB46, 0xBBFB, 0x3007,
    0xD098, 0xA26A, 0x7A4D, 0x819E, 0xAACB, 0x3CD2, 0x4EC2, 0x4538, 0x58E2, 0x0BFF,
    0xB6DC, 0xFE57, 0x5A5E, 0x8E6F, 0x3219, 0x2B79, 0x2FBD, 0x45A4, 0x42FA, 0x4C1F,
    0x5981, 0xB01C, 0x6600, 0xE1CA, 0x5728, 0x4F58, 0x1EA9, 0x6AF8, 0xA933, 0xA2D9,
    0xEA76, 0x672A, 0xCF23, 0x291D, 0x49E8, 0x58E1, 0x4900, 0x0000, 0x001D, 0xE3C7,
    0x8F1D, 0xDDDD, 0xDDDC, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3BBB, 0xBBB6, 0xDB6D, 0xB6DB, 0xE7CD,
    0x6B5A, 0xD6B5, 0xAF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xC000,
    0x0000, 0x03BC, 0x78F1, 0xE3BB, 0xBBBB, 0xBB80, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0007, 0x7777, 0x76DB,
    0x6DB6, 0xDB7C, 0xF9AD, 0x6B5A, 0xD6B5, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF,
    0x9F3E, 0x7CF8, 0x0000, 0x0000, 0x778F, 0x1E3C, 0x7777, 0x7777, 0x7000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x00EE, 0xEEEE, 0xDB6D, 0xB6DB, 0x6F9F, 0x35AD, 0x6B5A, 0xD6BE, 0x7CF9, 0xF3E7,
    0xCF9F, 0x3E7C, 0xF9F3, 0xE7CF, 0x9F00, 0x0000, 0x000E, 0xF1E3, 0xC78E, 0xEEEE,
    0xEEEE, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x1DDD, 0xDDDB, 0x6DB6, 0xDB6D, 0xF3E6, 0xB5AD, 0x6B5A,
    0xD7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C, 0xF9F3, 0xE000, 0x0000, 0x01DE,
    0x3C78, 0xF1DD, 0xDDDD, 0xDDC0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0003, 0xBBBB, 0xBB6D, 0xB6DB, 0x6DBE,
    0x7CD6, 0xB5AD, 0x6B5A, 0xF9F3, 0xE7CF, 0x9F3E, 0x7CF9, 0xF3E7, 0xCF9F, 0x3E7C,
    0x0000, 0x0000, 0x3BC0, 0x7523,
};

static HI_BOOL SinkCheckAvalidExtTrack(HI_VOID)
{
    HI_S32 s32Ret;
    HI_HANDLE hExtTrack = g_pstSinkManager->pstEngineManager->hExtTrack;
    HI_UNF_AUDIOTRACK_ATTR_S stTrackAttr;

    if (HI_NULL == hExtTrack)
    {
        HI_INFO_AO("No ext track found\n");
        return HI_FALSE;
    }

    s32Ret = HI_UNF_SND_GetTrackAttr(hExtTrack, &stTrackAttr);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_UNF_SND_GetTrackAttr failed(0x%x)\n", s32Ret);
        return HI_FALSE;
    }

    HI_INFO_AO("ExtTrack Type(0x%x)\n", stTrackAttr.enTrackType);
    if (HI_UNF_SND_TRACK_TYPE_MASTER == stTrackAttr.enTrackType)
    {
        HI_INFO_AO("Use ext mastertrack(0x%x)\n", hExtTrack);
        return HI_TRUE;
    }

    return HI_FALSE;
}

static HI_BOOL SinkIsExtTrackUsed(HI_VOID)
{
    return g_pstSinkManager->bExtTrackUsed;
}

static HI_BOOL SinkIsTrackCreated(HI_VOID)
{
    return g_pstSinkManager->bCreated;
}

static HI_S32 SinkConnectExtTrack(HI_VOID)
{
    HI_S32 s32Ret;
    HI_UNF_AUDIOTRACK_ATTR_S stTrackAttr = {0};

    g_pstSinkManager->hSinkTrack = g_pstSinkManager->pstEngineManager->hExtTrack;
    g_pstSinkManager->bExtTrackUsed = HI_TRUE;
    g_pstSinkManager->bCreated = HI_TRUE;

    s32Ret = HI_MPI_AO_Track_GetAttr(g_pstSinkManager->hSinkTrack, &stTrackAttr);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_MPI_AO_Track_GetAttr failed(0x%x)\n", s32Ret);
        return s32Ret;
    }

    g_pstSinkManager->u32ExtTrackBufThreshold = stTrackAttr.u32StartThresholdMs;
    g_pstSinkManager->u32ExtTrackBufLevel = stTrackAttr.u32BufLevelMs;

    stTrackAttr.u32StartThresholdMs = RENDERTRACKBUFTHRESHOLD;
    stTrackAttr.u32BufLevelMs = RENDERTRACKBUFLEVELMS;

    s32Ret = HI_MPI_AO_Track_SetAttr(g_pstSinkManager->hSinkTrack, &stTrackAttr);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_MPI_AO_Track_SetAttr failed(0x%x)\n", s32Ret);
        return s32Ret;
    }

    s32Ret = HI_MPI_AO_Track_Start(g_pstSinkManager->hSinkTrack);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_MPI_AO_Track_Start failed(0x%x)\n", s32Ret);
    }

    return s32Ret;
}

static HI_VOID SinkDisconnectExtTrack(HI_VOID)
{
    g_pstSinkManager->bExtTrackUsed = HI_FALSE;
    g_pstSinkManager->bCreated = HI_FALSE;
}

static HI_S32 SinkCreateTrack(HI_VOID)
{
    HI_S32 s32Ret;
    HI_UNF_AUDIOTRACK_ATTR_S  stTrackAttr;

    s32Ret = HI_MPI_AO_Track_GetDefaultOpenAttr(HI_UNF_SND_TRACK_TYPE_MASTER, &stTrackAttr);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_UNF_SND_GetDefaultTrackAttr failed(0x%x)\n", s32Ret);
        return s32Ret;
    }

    s32Ret = HI_MPI_AO_Track_Create(HI_UNF_SND_0, &stTrackAttr, &g_pstSinkManager->hSinkTrack);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_UNF_SND_CreateTrack failed(0x%x)\n", s32Ret);
        return s32Ret;
    }

    s32Ret = HI_MPI_AO_Track_GetAttr(g_pstSinkManager->hSinkTrack, &stTrackAttr);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_MPI_AO_Track_GetAttr failed(0x%x)\n", s32Ret);
    }

    stTrackAttr.u32StartThresholdMs = RENDERTRACKBUFTHRESHOLD;
    stTrackAttr.u32BufLevelMs = RENDERTRACKBUFLEVELMS;
    s32Ret = HI_MPI_AO_Track_SetAttr(g_pstSinkManager->hSinkTrack, &stTrackAttr);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_MPI_AO_Track_SetAttr failed(0x%x)\n", s32Ret);
    }

    s32Ret = HI_MPI_AO_Track_Start(g_pstSinkManager->hSinkTrack);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_MPI_AO_Track_Start failed(0x%x)\n", s32Ret);
        goto ERR_CREATTRACK;
    }

    g_pstSinkManager->bExtTrackUsed = HI_FALSE;
    g_pstSinkManager->bCreated = HI_TRUE;

    return HI_SUCCESS;

ERR_CREATTRACK:
    HI_UNF_SND_DestroyTrack(g_pstSinkManager->hSinkTrack);

    return s32Ret;
}

static HI_S32 SinkDestoryTrack(HI_VOID)
{
    g_pstSinkManager->bExtTrackUsed = HI_FALSE;
    g_pstSinkManager->bCreated = HI_FALSE;

    HI_MPI_AO_Track_Stop(g_pstSinkManager->hSinkTrack);

    return HI_UNF_SND_DestroyTrack(g_pstSinkManager->hSinkTrack);
}

static HI_S32 SinkSetTrackOutLatency(HI_U32 u32AopDmaMS, HI_U32 u32AipFifoMs, HI_BOOL bContinueEnable)
{
    HI_S32 s32Ret;
    trace();

#ifndef SDK_INTERFACE_NOT_SUPPORT
    s32Ret = HI_MPI_AO_SetContinueOutputEnable(HI_UNF_SND_0, bContinueEnable);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_MPI_AO_SetContinueOutputEnable failed(0x%x)\n", s32Ret);
        return s32Ret;
    }
#endif

    if (HI_TRUE == g_pstSinkManager->bCreated)
    {
#ifndef SDK_INTERFACE_NOT_SUPPORT
        s32Ret = HI_MPI_AO_SetTrackFifoLatency(g_pstSinkManager->hSinkTrack, u32AipFifoMs);
        if (HI_SUCCESS != s32Ret)
        {
            HI_ERR_AO("call HI_MPI_AO_SetTrackFifoLatency failed(0x%x)\n", s32Ret);
            return s32Ret;
        }
#endif
    }

    s32Ret = HI_UNF_SND_SetLowLatency(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_ALL, u32AopDmaMS);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_UNF_SND_SetLowLatency failed(0x%x)\n", s32Ret);
    }

    return s32Ret;
}

static HI_S32 SinkCreate(HI_VOID)
{
    HI_BOOL bAvalidExtTrack;
    HI_S32 s32Ret = HI_SUCCESS;

    trace();

    bAvalidExtTrack = SinkCheckAvalidExtTrack();
    if (HI_TRUE == bAvalidExtTrack)
    {
        s32Ret = SinkConnectExtTrack();
        if (HI_SUCCESS != s32Ret)
        {
            HI_ERR_AO("call SinkConnectExtTrack failed(0x%x)\n", s32Ret);
            return s32Ret;
        }

        s32Ret = SinkSetTrackOutLatency(AOP_LOW_LATENCY_MS, AIP_FIFO_LOW_LATENCY_MS, HI_TRUE);
        if (HI_SUCCESS != s32Ret)
        {
            HI_ERR_AO("call SinkSetTrackOutLatency failed(0x%x)\n", s32Ret);
        }

        return s32Ret;
    }

    if (HI_TRUE == g_pstSinkManager->bCreated)
    {
        return s32Ret;
    }

    s32Ret = SinkCreateTrack();
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call SinkCreateTrack failed(0x%x)\n", s32Ret);
        return s32Ret;
    }

    s32Ret = SinkSetTrackOutLatency(AOP_LOW_LATENCY_MS, AIP_FIFO_LOW_LATENCY_MS, HI_TRUE);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call SinkSetTrackOutLatency failed(0x%x)\n", s32Ret);
    }

    return s32Ret;
}

static HI_S32 SinkDestory(HI_VOID)
{
    HI_S32 s32Ret;

    trace();

    s32Ret = SinkSetTrackOutLatency(AOP_NORMAL_LATENCY_MS, AIP_FIFO_NORMAL_LATENCY_MS, HI_FALSE);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call SinkSetTrackOutLatency failed(0x%x)\n", s32Ret);
    }

    if (HI_FALSE == SinkIsTrackCreated())
    {
        return HI_SUCCESS;
    }

    if (HI_TRUE == SinkIsExtTrackUsed())
    {
        SinkDisconnectExtTrack();
        return HI_SUCCESS;
    }

    return SinkDestoryTrack();
}

#ifndef SDK_INTERFACE_NOT_SUPPORT
static HI_S32 SinkAddMuteData(HI_VOID)
{
    HI_S32 s32Ret;
    HI_U8* pu8Buf;
    HI_UNF_AO_FRAMEINFO_S stAOFrame;

    pu8Buf = (HI_U8*)malloc(PCM_DATA_LENGTH + LBR_DATA_LENGTH + HBR_DATA_LENGTH);
    if (HI_NULL == pu8Buf)
    {
        HI_ERR_AO("ao frame buffer malloc failed!\n");
        return HI_FAILURE;
    }

    memset(pu8Buf, 0, PCM_DATA_LENGTH + LBR_DATA_LENGTH + HBR_DATA_LENGTH);
    memcpy(pu8Buf + PCM_DATA_LENGTH, g_dd_heard, sizeof(g_dd_heard));
    memcpy(pu8Buf + PCM_DATA_LENGTH + LBR_DATA_LENGTH, g_ddp_heard, sizeof(g_ddp_heard));

    stAOFrame.s32BitPerSample = RENDER_OUT_FRAME_BITWIDTH;
    stAOFrame.u32Channels   = RENDER_OUT_FRAME_CHANNEL;
    stAOFrame.bInterleaved  = HI_TRUE;
    stAOFrame.u32SampleRate = RENDER_OUT_FRAME_SAMPLERATE;
    stAOFrame.u32PtsMs = HI_INVALID_PTS;
    stAOFrame.u32BitsBytesPerFrame = BITS_BYTE_PER_FRAME;
    stAOFrame.ps32BitsBuffer = (HI_S32*)(pu8Buf + PCM_DATA_LENGTH);
    stAOFrame.u32FrameIndex = 0;
    stAOFrame.u32PcmSamplesPerFrame = PCM_SAMPLES_PER_FRAME;
    stAOFrame.ps32PcmBuffer = (HI_S32*)pu8Buf;
    stAOFrame.u32IEC61937DataType = 0;

    s32Ret = HI_MPI_AO_Track_SendData(g_pstSinkManager->hSinkTrack, &stAOFrame);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_MPI_AO_Track_SendData failed(0x%x)\n", s32Ret);
    }

    free(pu8Buf);

    return s32Ret;
}
#endif

HI_S32  Sink_Init(RENDER_MANAGER_S* pstRender)
{
    trace();

    g_pstSinkManager = (SINK_MANAGER_S*)malloc(sizeof(SINK_MANAGER_S));
    if (HI_NULL == g_pstSinkManager)
    {
        HI_ERR_AO("Sink manager malloc failed!\n");
        return HI_FAILURE;
    }

    memset(g_pstSinkManager, 0, sizeof(SINK_MANAGER_S));

    g_pstSinkManager->pstEngineManager = pstRender->pstEngineManger;
    g_pstSinkManager->pstSourceManager = pstRender->pstSourceManager;

    return HI_SUCCESS;
}

HI_S32  Sink_Deinit(HI_VOID)
{
    HI_S32 s32Ret;

    trace();

    s32Ret = SinkDestory();
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call SinkDestory failed(0x%x)\n", s32Ret);
    }

    if (HI_NULL != g_pstSinkManager)
    {
        free(g_pstSinkManager);
        g_pstSinkManager = HI_NULL;
    }

    return s32Ret;
}

HI_S32 Sink_SendData(HA_MS12_STREAM_S* pstMS12DecodeStream)
{
    HI_S32 s32Ret;
    HI_UNF_AO_FRAMEINFO_S stAOFrame;
    HI_UNF_AO_FRAMEINFO_S* pstAOFrame;
    HI_HADECODE_OUTPUT_S* pstPackOut = pstMS12DecodeStream->stOutput.pstOutput;

    CHANNEL_TRACE();

    HI_WARN_AO("PcmOutSamplesPerFrame is %d\n", pstPackOut->u32PcmOutSamplesPerFrame);

    if (0 == pstPackOut->u32PcmOutSamplesPerFrame)
    {
        return HI_SUCCESS;
    }

    SINK_LOCK();

    if (HI_TRUE == g_pstSinkManager->bExtContinuousOutputCtl)
    {
        if (HI_FALSE == g_pstSinkManager->bContinuousOutputEnable)
        {
            SINK_UNLOCK();
            HI_WARN_AO("ExtContinuousOutPutctl enalbed and output is disable, drop track data\n");
            usleep(OUTPUT_TRACK_SLEEP_MS);
            return HI_SUCCESS;
        }
    }
    else
    {
        if (HI_FALSE == SinkIsTrackCreated())
        {
                s32Ret = SinkCreate();
                if (HI_SUCCESS != s32Ret)
                {
                    HI_ERR_AO("call SinkCreate failed(0x%x)\n", s32Ret);
                    return s32Ret;
                }
        }
    }

    SINK_UNLOCK();

    stAOFrame.s32BitPerSample = RENDER_OUT_FRAME_BITWIDTH;
    stAOFrame.u32Channels   = RENDER_OUT_FRAME_CHANNEL;
    stAOFrame.bInterleaved  = HI_TRUE;
    stAOFrame.u32SampleRate = RENDER_OUT_FRAME_SAMPLERATE;
    stAOFrame.u32PtsMs = 0xffffffff;
    stAOFrame.u32BitsBytesPerFrame = pstPackOut->u32BitsOutBytesPerFrame;
    stAOFrame.ps32BitsBuffer = pstPackOut->ps32BitsOutBuf;
    stAOFrame.u32FrameIndex = 0;
    stAOFrame.u32PcmSamplesPerFrame = pstPackOut->u32PcmOutSamplesPerFrame;
    stAOFrame.ps32PcmBuffer = pstPackOut->ps32PcmOutBuf;
    stAOFrame.u32IEC61937DataType = 0;

    s32Ret = HI_MPI_AO_Track_Start(g_pstSinkManager->hSinkTrack);
    if (HI_SUCCESS != s32Ret)
    {
        HI_WARN_AO("call HI_MPI_AO_Track_Start failed(0x%x)\n", s32Ret);
        return s32Ret;
    }

    HI_WARN_AO("Track_SendData in\n");

    while (1)
    {
        SINK_LOCK();

        if (HI_TRUE == g_pstSinkManager->bExtContinuousOutputCtl)
        {
            if (HI_FALSE == g_pstSinkManager->bContinuousOutputEnable)
            {
                SINK_UNLOCK();
                HI_WARN_AO("ExtContinuousOutPutctl enalbed and output is disable, drop2 track data\n");
                usleep(OUTPUT_TRACK_SLEEP_MS);
                return HI_SUCCESS;
            }
        }

        pstAOFrame = &stAOFrame;

        s32Ret = HI_MPI_AO_Track_SendData(g_pstSinkManager->hSinkTrack, pstAOFrame);
        if (HI_ERR_AO_OUT_BUF_FULL == s32Ret)
        {
            SINK_UNLOCK();
            usleep(OUTPUT_TRACK_SLEEP_MS);
            continue;
        }
        else
        {
            if (HI_SUCCESS != s32Ret)
            {
                HI_ERR_AO("call HI_MPI_AO_Track_SendData failed(0x%x)\n", s32Ret);
            }
            //avoid gettrackdelay with the repeat fifo data size  avoid the async between sendtrackdata and gettrackdelayms
            g_pstSinkManager->bFifoValid = HI_FALSE;

            //source inst2 lock avoid the deadlock between sendtrackdata(sink lock, inst1 lock) and Sink_GetSyncDelayMs(inst1 lock, sink lock) if using the same source inst1 lock
            SOURCE_INST2_LOCK(SOURCE_ID_MAIN);
            //update main audio sinkpts, avoid the async between sendtrackdata and gettrackpts
            SOURCE_S* pstSource = g_pstSinkManager->pstSourceManager->pstSource[SOURCE_ID_MAIN];
            if ((HI_NULL != pstSource) &&  pstSource->bWorking &&
               ((SOURCE_STATE_RUNNING == pstSource->enState) || (SOURCE_STATE_PAUSE == pstSource->enState)))
            {
                pstSource->u32DecoderPcmDelay = pstMS12DecodeStream->stOutput.u32PcmDelayMs[SOURCE_ID_MAIN];
                pstSource->u32SinkPts = pstSource->u32CurStreamPts;
                pstSource->bSinkStarted = HI_TRUE;
            }

            SOURCE_INST2_UNLOCK(SOURCE_ID_MAIN);
            SINK_UNLOCK();
            break;
        }
    }

    HI_WARN_AO("Track_SendData out\n");

    return s32Ret;
}

HI_S32 Sink_GetDelayMs(HI_U32* pu32DelayMs)
{
    HI_S32 s32Ret = HI_SUCCESS;

    CHANNEL_TRACE();

    *pu32DelayMs = 0;

    if (g_pstSinkManager && (HI_TRUE == g_pstSinkManager->bCreated))
    {
        SINK_LOCK();

        s32Ret = HI_MPI_AO_Track_GetDelayMs(g_pstSinkManager->hSinkTrack, pu32DelayMs);
        if (HI_SUCCESS != s32Ret)
        {
            SINK_UNLOCK();
            HI_ERR_AO("call HI_MPI_AO_Track_GetDelayMs failed(0x%x)\n", s32Ret);
            return s32Ret;
        }

        if (HI_TRUE == g_pstSinkManager->bFifoValid)
        {
            *pu32DelayMs += FIFO_BLOCK_MS;
        }

        SINK_UNLOCK();

        HI_WARN_AO("drv Track_GetDelayMs(%d)\n", *pu32DelayMs);
    }

    return HI_SUCCESS;
}

HI_S32 Sink_GetSyncDelayMs(SOURCE_S* pstSource, HI_U32* pu32Pts)
{
    CHANNEL_TRACE();

    if (g_pstSinkManager && (HI_TRUE == g_pstSinkManager->bCreated))
    {
        HI_S32 s32Ret = HI_SUCCESS;
        SINK_LOCK();

        s32Ret = HI_MPI_AO_Track_GetDelayMs(g_pstSinkManager->hSinkTrack, &pstSource->u32DelayMs);
        if (HI_SUCCESS != s32Ret)
        {
            SINK_UNLOCK();
            HI_ERR_AO("call HI_MPI_AO_Track_GetDelayMs failed(0x%x)\n", s32Ret);
            return s32Ret;
        }

        *pu32Pts = (pstSource->u32SinkPts > (pstSource->u32DelayMs + pstSource->u32DecoderStaticDelay + pstSource->u32DecoderPcmDelay + pstSource->u32PreDecodePts)) ?
                   (pstSource->u32SinkPts - (pstSource->u32DelayMs + pstSource->u32DecoderStaticDelay + pstSource->u32DecoderPcmDelay)) : pstSource->u32PreDecodePts;

        SINK_UNLOCK();

        //for pts trace avoid async case
        HI_WARN_AO("Source(%d) Pts:%d (Sink pts:%d Track DelayMs:%d DecoderStaticDelay:%d DecoderPcmDelay:%d CurStream Pts:%d)\n",
                   pstSource->enSourceID, *pu32Pts, pstSource->u32SinkPts, pstSource->u32DelayMs, pstSource->u32DecoderStaticDelay,
                   pstSource->u32DecoderPcmDelay, pstSource->u32CurStreamPts);
    }

    return HI_SUCCESS;
}

HI_S32 Sink_SetFifoBufValid(HI_BOOL bValid)
{
    CHANNEL_TRACE();

    if (g_pstSinkManager && (HI_TRUE == g_pstSinkManager->bCreated))
    {
        g_pstSinkManager->bFifoValid = bValid;
    }

    return HI_SUCCESS;
}

HI_S32 Sink_DeattchExtTrack(HI_VOID)
{
    HI_S32 s32Ret;
    HI_UNF_AUDIOTRACK_ATTR_S stTrackAttr;

    if (HI_TRUE != g_pstSinkManager->bExtTrackUsed)
    {
        return HI_SUCCESS;
    }

    s32Ret = HI_MPI_AO_Track_GetAttr(g_pstSinkManager->hSinkTrack, &stTrackAttr);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_MPI_AO_Track_GetAttr failed(0x%x)\n", s32Ret);
        return s32Ret;
    }

    stTrackAttr.u32StartThresholdMs = g_pstSinkManager->u32ExtTrackBufThreshold;
    stTrackAttr.u32BufLevelMs = g_pstSinkManager->u32ExtTrackBufLevel;

    s32Ret = HI_MPI_AO_Track_SetAttr(g_pstSinkManager->hSinkTrack, &stTrackAttr);
    if (HI_SUCCESS != s32Ret)
    {
        HI_ERR_AO("call HI_MPI_AO_Track_SetAttr failed(0x%x)\n", s32Ret);
        return s32Ret;
    }

    return HI_SUCCESS;
}

HI_S32 Sink_EnableContinuousOutput(HI_BOOL bEnable)
{
#ifndef SDK_INTERFACE_NOT_SUPPORT
    HI_S32 s32Ret = HI_SUCCESS;

    HI_WARN_AO("Sink_SetContinuousOutputEnbale %d\n", bEnable);
    SINK_LOCK();

    if ((HI_FALSE == g_pstSinkManager->bContinuousOutputEnable) && (HI_TRUE == bEnable))
    {
        s32Ret = SinkCreate();
        if (HI_SUCCESS != s32Ret)
        {
            HI_ERR_AO("call SinkCreateTrack failed(0x%x)\n", s32Ret);
            SINK_UNLOCK();
            return s32Ret;
        }

        s32Ret = SinkAddMuteData();
        if (HI_SUCCESS != s32Ret)
        {
            HI_ERR_AO("call SinkAddMuteData failed(0x%x)\n", s32Ret);
            SINK_UNLOCK();
            return s32Ret;
        }
        //mastertrack created by ext app for continuous output
        g_pstSinkManager->bExtContinuousOutputCtl = HI_TRUE;
    }

    if ((HI_TRUE == g_pstSinkManager->bContinuousOutputEnable) && (HI_FALSE == bEnable))
    {
        s32Ret = SinkDestory();
        if (HI_SUCCESS != SinkDestory())
        {
            HI_ERR_AO("call SinkCreateTrack failed(0x%x)\n", s32Ret);
            SINK_UNLOCK();
            return s32Ret;
        }
    }

    g_pstSinkManager->bContinuousOutputEnable = bEnable;
    SINK_UNLOCK();
#endif

    return HI_SUCCESS;
}

#ifdef __cplusplus
#if __cplusplus
}
#endif
#endif /* End of #ifdef __cplusplus */
